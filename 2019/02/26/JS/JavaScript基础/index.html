<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="English">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">




  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">






  <meta name="keywords" content="JS,基础,">










<meta name="description" content="概述 什么是 JavaScript 语言？JavaScript (JS for short) is the programming language that enables web pages to respond to user interaction beyond the basic level. It was created in 1995 by Brendan Eich, and is">
<meta name="keywords" content="JS,基础">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript基础">
<meta property="og:url" content="https://supremeyh.github.io/2019/02/26/JS/JavaScript基础/index.html">
<meta property="og:site_name" content="Supremeyh">
<meta property="og:description" content="概述 什么是 JavaScript 语言？JavaScript (JS for short) is the programming language that enables web pages to respond to user interaction beyond the basic level. It was created in 1995 by Brendan Eich, and is">
<meta property="og:locale" content="English">
<meta property="og:image" content="https://supremeyh.github.io/images/expressions-operator-precedence.jpg">
<meta property="og:updated_time" content="2019-07-23T01:25:36.333Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript基础">
<meta name="twitter:description" content="概述 什么是 JavaScript 语言？JavaScript (JS for short) is the programming language that enables web pages to respond to user interaction beyond the basic level. It was created in 1995 by Brendan Eich, and is">
<meta name="twitter:image" content="https://supremeyh.github.io/images/expressions-operator-precedence.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://supremeyh.github.io/2019/02/26/JS/JavaScript基础/">





  <title>JavaScript基础 | Supremeyh</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="English">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Supremeyh</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">a paradise for sharing knowledge and ideas</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://supremeyh.github.io/2019/02/26/JS/JavaScript基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Supremeyh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Supremeyh">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaScript基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-26T17:52:37+08:00">
                2019-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JS/" itemprop="url" rel="index">
                    <span itemprop="name">JS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>什么是 JavaScript 语言？<br>JavaScript (JS for short) is the programming language that enables web pages to respond to user interaction beyond the basic level. It was created in 1995 by Brendan Eich, and is today one of the most famous and used programming languages.</li>
</ul>
<p>JavaScript 是一种轻量级的脚本语言。所谓“脚本语言”（script language），指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”。</p>
<p>JavaScript 也是一种嵌入式（embedded）语言。它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I/O（输入/输出）相关的 API，都要靠宿主环境（host）提供，所以 JavaScript 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。</p>
<blockquote>
<p>编译型语言 vs 解释型语言<br>编译型语言，首先是将源代码编译compile生成机器指令，再由机器运行机器码 (二进制)。执行效率高。如C、C++<br>解释型语言，源代码先翻译成中间代码，再由解释器对中间代码进行解释运行。每次运行的时候都要逐行解释一遍，有良好的平台兼容性。如JavaScript、Python、PHP</p>
</blockquote>
<blockquote>
<p>动态类型语言 vs 静态类型语言<br>动态类型语言，是指数据类型的检查是在运行时做的。用动态类型语言编程时，不用给变量指定数据类型，该语言会在你第一次赋值给变量时，在内部记录数据类型。<br>静态类型语言，是指数据类型的检查是在运行前（如编译阶段）做的。</p>
</blockquote>
<ul>
<li>JavaScript语言的历史</li>
</ul>
<p>1995年5月，Brendan Eich只用了10天，就设计完成了这种语言的第一版。<br>基本语法：借鉴C语言和Java语言。<br>数据结构：借鉴Java语言，包括将值分成原始值和对象两大类。<br>函数的用法：借鉴Scheme语言和Awk语言，将函数当作第一等公民，并引入闭包。<br>原型继承模型：借鉴Self语言（Smalltalk的一种变种）。<br>正则表达式：借鉴Perl语言。<br>字符串和数组处理：借鉴Python语言。</p>
<p>1996年，样式表标准CSS第一版发布。<br>1997年，DHTML（Dynamic HTML，动态HTML）发布，允许动态改变网页内容。这标志着DOM模式（Document Object Model，文档对象模型）正式应用。</p>
<p>1997年7月，ECMAScript 1.0。<br>1998年6月，ECMAScript 2.0。格式修正，以使得其形式与ISO/IEC16262国际标准一致。<br>1999年12月，ECMAScript 3.0。强大的正则表达式，更好的文字链处理，新的控制指令，异常处理，错误定义更加明确，数输出的格式化及其它改变。</p>
<p>2001年，微软公司时隔5年之后，发布了IE浏览器的下一个版本Internet Explorer 6。<br>2002年，Mozilla项目发布了它的浏览器的第一版，后来起名为Firefox。<br>2003年，苹果公司发布了Safari浏览器的第一版。<br>2005年，Ajax方法（Asynchronous JavaScript and XML）正式诞生。Google Maps项目大量采用该方法。促成了Web 2.0时代的来临。<br>2005年，Apache基金会发布了CouchDB数据库。基于JSON格式的数据库，可以用JavaScript函数定义视图和索引，标识着NoSQL类型的数据库诞生。<br>2006年，jQuery函数库诞生，作者为John Resig。<br>2006年，微软公司发布IE 7，标志重新开始启动浏览器的开发。<br>2008年，V8编译器诞生。这是Google公司为Chrome浏览器而开发的，它的特点是让JavaScript的运行变得非常快。V8是开源的，拓展了JavaScript的应用领域。<br>2009年，Node.js项目诞生，创始人为Ryan Dahl，它标志着JavaScript可以用于服务器端编程，从此网站的前端和后端可以使用同一种语言开发。</p>
<p>2009年12月，ECMAScript 5.0。<br>2011年6月，ECMAscript 5.1，并且成为ISO国际标准（ISO/IEC 16262:2011）。到了2012年底，所有主要浏览器都支持ECMAScript 5.1版的全部功能。</p>
<p>2012年，SPA单页面应用程序框架开始崛起，AngularJS项目和Ember项目都发布了1.0版本。<br>2012年，微软发布TypeScript语言。该语言被设计成JavaScript的超集，这意味着所有JavaScipt程序，都可以不经修改地在TypeScript中运行。<br>2013年5月，Facebook发布UI框架库React，引入了新的JSX语法，使得UI层可以用组件开发。<br>2015年3月，Facebook公司发布了React Native项目，将React框架移植到了手机端，可以用来开发手机原生App。<br>2015年4月，Angular框架宣布，2.0版将基于微软公司的TypeScript语言开发，这等于为JavaScript语言引入了强类型。</p>
<p>2015年6月17日，ECMAScript 6，更名为 ECMAScript 2015。新增let、const、class、modules、arrow functions、rest argument、binary data、promises等等。这个标准从提出到批准，历时10年，而JavaScript语言从诞生至今也已经20年了。<br>2016年06月，ECMAScript 2016。完善ES6规范，两个新的功能：求幂运算符（*）和array.prototype.includes方法。<br>2017年06月：ECMAScript 2017。增加新的功能，如并发、原子操作、Object.values/Object.entries、字符串填充、promises、await/asyn等等。<br>2017年11月，所有主流浏览器全部支持 WebAssembly，这意味着任何语言都可以编译成 JavaScript，在浏览器运行。</p>
<h3 id="ES6、ES7、ES8、ES9、ES10新特性一览"><a href="#ES6、ES7、ES8、ES9、ES10新特性一览" class="headerlink" title="ES6、ES7、ES8、ES9、ES10新特性一览"></a>ES6、ES7、ES8、ES9、ES10新特性一览</h3><ul>
<li><p>ES6新特性（2015） 2015年6月17日<br>let、const<br>class 类<br>modules 模块化(import、export)<br>arrow functions 箭头函数<br>函数参数默认值<br>模板字符串 ${}<br>解构赋值。 通过解构赋值可以方便的交换两个变量的值。 如 var foo = [“one”, “two”, “three”, “four”];  var [first, , , last] = foo;<br>spread operator 延展操作符。 构造对象时,进行克隆或者属性拷贝，如let objClone = { …obj }  浅拷贝<br>对象属性简写<br>Promise</p>
</li>
<li><p>ES7新特性（2016） 2016年06月<br>array.prototype.includes() 方法，用来判断一个数组是否包含一个指定的值，包含则返回true，否则返回false<br><strong> 指数运算符，它与 a </strong> b === Math.pow(a, b)</p>
</li>
<li><p>ES8新特性（2017） 2017年06月<br>async/await 异步迭代器<br>Object.values(obj), 返回obj自身属性的值，不包括继承的值<br>Object.entries(obj), 返回obj对象自身可枚举属性的键值对的数组<br>String padding:  String.padStart(targetLength,padString]) 和padEnd()，填充字符串达到当前长度<br>Object.getOwnPropertyDescriptors(obj), 获取一个对象的所有自身属性的描述符,如果没有任何自身属性，则返回空对象<br>ShareArrayBuffer 对象, 表示一个通用的、固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，但 SharedArrayBuffer 不能被分离<br>Atomics对象，对 SharedArrayBuffer 对象进行原子操作<br>函数参数列表结尾允许逗号, 主要作用是方便使用git进行多人协作开发时修改同一个函数减少不必要的行变更。</p>
</li>
<li><p>ES9新特性（2018） 2018年6月<br>异步迭代, 在async/await的某些时刻，你可能尝试在同步循环中调用异步函数<br>Promise.finally()<br>Rest/Spread 属性<br>正则表达式命名捕获组（Regular Expression Named Capture Groups）<br>正则表达式反向断言（lookbehind）<br>正则表达式dotAll模式<br>正则表达式 Unicode 转义<br>非转义序列的模板字符串</p>
</li>
<li><p>ES10新特性（2019）<br>行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与JSON匹配<br>更加友好的 JSON.stringify<br>Array.prototype.flat() 和flatMap()方法， 数组降维和去除数组的空项<br>String.prototype.trimStart() 和 trimEnd()方法，分别去除字符串首尾空白字符<br>Object.fromEntries(), 返回一个给定对象自身可枚举属性的键值对数组, 是 Object.entries() 的反转, 可以将 Map/Array 转化为 Object<br>Symbol.prototype.description<br>String.prototype.matchAll, 返回一个包含所有匹配正则表达式及分组捕获结果的迭代器<br>Function.prototype.toString(), 返回精确字符，包括空格和注释<br>简化try {} catch {},修改 catch 绑定</p>
</li>
</ul>
<p>BigInt 新的基本数据类型, 任意精度整数, 意味着变量可以定义2⁵³的数字了，不再有9007199254740992的最大限制。<br>至此，JS共有七种基本数据类型 String、Number、Boolean、Null、Undefined、Symbol、BigInt</p>
<p>globalThis, 标准化全局对象，无视环境，直接获取当前的全局对象<br>Dynamic import, 动态引入js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(<span class="string">'click'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">`./some.js`</span>)</span><br><span class="line">  <span class="built_in">module</span>.clickEvent()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li>语句 和 表达式<br>JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。<br>语句（statement）是为了完成某种任务而进行的操作，以分号结尾，一个分号就表示一个语句结束。var a = 2 + 3;<br>表达式（expression），指一个为了得到返回值的计算式，不需要分号结尾，一旦在表达式后面添加分号，则引擎就将其视为语句。 2 + 3</li>
<li>变量<br>变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。</li>
</ul>
<p>注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。</p>
<ul>
<li><p>变量提升<br>JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hoisting</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正运行的是下面的代码</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>标识符<br>标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。</p>
</li>
</ul>
<p>规则：第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。</p>
<p>中文是合法的标识符，可以用作变量名。  var 临时变量 = 1;</p>
<p>JavaScript 有一些保留字，不能用作标识符：<br>arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。</p>
<ul>
<li>循环语句<br>while 循环，只要条件为真，就不断循环执行代码块<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, world'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>for 循环, 可以指定循环的起点、终点和终止条件, for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有for循环，都可以改写成while循环</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; x) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>do…while 循环，与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。至少运行一次，while语句后面的分号注意不要省略<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">&#125; <span class="keyword">while</span>(i &lt; x);</span><br></pre></td></tr></table></figure></p>
<p>break 语句和 continue 语句，都具有跳转作用，可以让代码不按既有的顺序执行<br>break语句用于跳出代码块或循环。for循环也可以使用break语句跳出循环。<br>continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。</p>
<p>标签 label，语句的前面有标签，相当于定位符，用于跳转到程序的任意位置。标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。通常与break语句和continue语句配合使用，跳出特定的循环。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">break</span> top;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'i='</span> + i + <span class="string">', j='</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i=0, j=0</span></span><br><span class="line"><span class="comment">// i=0, j=1</span></span><br><span class="line"><span class="comment">// i=0, j=2</span></span><br><span class="line"><span class="comment">// i=1, j=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="七种数据类型"><a href="#七种数据类型" class="headerlink" title="七种数据类型"></a>七种数据类型</h4><p>共有七种: 数值 number、字符串 string、布尔值 boolean、undefined、uull、symbol 和 对象 object<br>基本类型: number、string、boolean、undefined、uull、symbol。 按值访问，可以操作保存在变量中的实际的值，任何方法都无法改变一个基本类型的值，变量存放在栈区。<br>引用类型, Object、Array和Function。 按引用访问，值是同时保存在栈内存和堆内存中的对象，比较是引用的比较即堆内存中的地址是否相同</p>
<h4 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h4><p>JavaScript 有三种方法，可以确定一个值到底是什么类型。typeof运算符、instanceof运算符、Object.prototype.toString方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值、字符串、布尔值分别返回number、string、boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'123'</span> <span class="comment">// "string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span> <span class="comment">// "boolean"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined返回undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// "undefined"  利用这一点，typeof可以用来检查一个没有声明的变量，而不报错 if (typeof v === "undefined") &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象返回object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">window</span> <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// "object"   这表示在 JavaScript 内部，数组本质上只是一种特殊的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// instanceof运算符可以区分数组和对象</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;, a = [];</span><br><span class="line">o <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null返回object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// "object"   由于历史原因造成的,第一版没有null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回function。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> f <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure>
<h4 id="null-undefined-和布尔值"><a href="#null-undefined-和布尔值" class="headerlink" title="null, undefined 和布尔值"></a>null, undefined 和布尔值</h4><p>null是一个表示“空”的对象，表示空值，即该处的值现在为空，转为数值时为0<br>undefined是一个表示”未定义”的原始值，转为数值时为NaN<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="number">5</span> + <span class="literal">undefined</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></p>
<p>布尔值代表“真”和“假”两个状态， true 和 false<br>false: undefined、null、false、0、NaN、””或’’（空字符串）<br>true:  除上面六个值外。  注意，空数组（[]）和空对象（{}）对应的布尔值都是true<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ok'</span>)  <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下运算符会返回布尔值: 前置逻辑运算符 (! Not)、 相等运算符（===，!==，==，!=）、 比较运算符（&gt;，&gt;=，&lt;，&lt;=）</p>
<h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><p>JavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此，就是说，JS语言的底层根本没有整数，所有数字都是小数（64位浮点数）。。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1.0</span> <span class="comment">// true  1与1.0是相同的，是同一个数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心</span></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.30000000000000004</span></span><br><span class="line"><span class="number">0.2</span><span class="number">-0.1</span> === <span class="number">0.1</span></span><br><span class="line"><span class="number">0.3</span><span class="number">-0.2</span> === <span class="number">0.09999999999999998</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>JavaScript 浮点数的64个二进制位<br>第1位：符号位，0表示正数，1表示负数<br>第2位到第12位（共11位）：指数部分，大小范围就是0 - 2047(2的11次方减1)<br>第13位到第64位（共52位）：小数部分（即有效数字）</p>
</li>
<li><p>数值精度:<br>最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示。大于2的53次方的数值，都无法保持精度。<br>由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。</p>
</li>
<li><p>数值范围:<br>JavaScript 能够表示的数值范围为(2^1024,2^-1023)，超出这个范围的数无法表示。<br>如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity<br>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，这时会直接返回0。</p>
</li>
<li><p>JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。<br>Number.MAX_VALUE // 1.7976931348623157e+308<br>Number.MIN_VALUE // 5e-324</p>
</li>
<li><p>正零和负零:<br>JavaScript 的64位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的负值，就连0也不例外。<br>JavaScript 内部实际上存在2个0：一个是+0，一个是-0，区别就是64位浮点数表示法的符号位不同。它们是等价的。<br>几乎所有场合，正零和负零都会被当作正常的0。唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> === +<span class="number">0</span>  === <span class="number">-0</span>  <span class="comment">// true</span></span><br><span class="line">+<span class="number">0</span>  <span class="comment">// 0</span></span><br><span class="line"><span class="number">-0</span>  <span class="comment">// 0</span></span><br><span class="line">(<span class="number">-0</span>).toString() <span class="comment">// '0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。因为除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的</span></span><br><span class="line">(<span class="number">1</span> / +<span class="number">0</span>) === (<span class="number">1</span> / <span class="number">-0</span>) <span class="comment">// false   </span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* NaN:</span></span><br><span class="line"><span class="string">NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number）</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>JavaScript</span><br><span class="line"><span class="comment">// 主要出现在将字符串解析成数字出错的场合</span></span><br><span class="line"><span class="number">5</span> - <span class="string">'x'</span> <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些数学函数的运算结果会出现NaN</span></span><br><span class="line"><span class="built_in">Math</span>.acos(<span class="number">2</span>) <span class="comment">// NaN   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0除以0也会得到NaN。</span></span><br><span class="line"><span class="number">0</span> / <span class="number">0</span> <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> <span class="comment">// 'number'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NaN不等于任何值，包括它本身。</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。</span></span><br><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NaN在布尔运算时被当作false。</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NaN与任何数（包括它自己）的运算，得到的都是NaN。</span></span><br><span class="line"><span class="literal">NaN</span> + <span class="number">666</span> <span class="comment">// NaN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Infinity:<br>Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>)  <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> / <span class="number">0</span>  <span class="comment">// NaN</span></span><br><span class="line"><span class="number">1</span> / <span class="number">0</span>  <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。</span></span><br><span class="line"><span class="literal">Infinity</span> === -<span class="literal">Infinity</span>  <span class="comment">// false</span></span><br><span class="line"><span class="number">1</span> / <span class="number">-0</span>  <span class="comment">// -Infinity</span></span><br><span class="line"><span class="number">-1</span> / <span class="number">-0</span>  <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。</span></span><br><span class="line"><span class="literal">Infinity</span> &gt; <span class="number">1000</span>  <span class="comment">// true</span></span><br><span class="line">-<span class="literal">Infinity</span> &lt; <span class="number">-1000</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Infinity与NaN比较，总是返回false。</span></span><br><span class="line"><span class="literal">Infinity</span> &gt; <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Infinity的四则运算，符合无穷的数学计算规则。</span></span><br><span class="line"><span class="number">5</span> * <span class="literal">Infinity</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">5</span> - <span class="literal">Infinity</span> <span class="comment">// -Infinity</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="number">5</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">5</span> / <span class="literal">Infinity</span> <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。</span></span><br><span class="line"><span class="number">0</span> * <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="number">0</span> / <span class="literal">Infinity</span> <span class="comment">// 0</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="number">0</span> <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Infinity加上或乘以Infinity，返回的还是Infinity。</span></span><br><span class="line"><span class="literal">Infinity</span> + <span class="literal">Infinity</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="literal">Infinity</span> * <span class="literal">Infinity</span> <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Infinity减去或除以Infinity，得到NaN。</span></span><br><span class="line"><span class="literal">Infinity</span> - <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Infinity与null计算时，null会转成0，等同于与0的计算。</span></span><br><span class="line"><span class="literal">null</span> * <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">null</span> / <span class="literal">Infinity</span> <span class="comment">// 0</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">null</span> <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Infinity与undefined计算，返回的都是NaN。</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">undefined</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>与数值相关的全局方法<br>parseInt()  用于将字符串转为整数, 返回值只有两种可能，要么是一个十进制整数，要么是NaN。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123'</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'   81'</span>) <span class="comment">// 81    如果字符串头部有空格，空格会被自动去除。</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">1.23</span>) <span class="comment">// 1   如果parseInt的参数不是字符串，则会先转为字符串再转换。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'15px'</span>) <span class="comment">// 15   字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'abc'</span>) <span class="comment">// NaN   如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0x10'</span>) <span class="comment">// 16  如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'011'</span>) <span class="comment">// 11  如果字符串以0开头，将其按照10进制解析。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0.0000008</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'8e-7'</span>) <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进制转换</span></span><br><span class="line"><span class="comment">// parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认第二个参数为10，即默认是十进制转十进制</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1000'</span>, <span class="number">2</span>) <span class="comment">// 8     二进制、八进制的1000，分别等于十进制的8、和512</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1000'</span>, <span class="number">8</span>) <span class="comment">// 512</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="number">37</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="number">0</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="literal">null</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="literal">undefined</span>) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1546'</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'546'</span>, <span class="number">2</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>parseFloat()：  用于将一个字符串转为浮点数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'3.14'</span>) <span class="comment">// 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果字符串符合科学计数法，则会进行相应的转换</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'314e-2'</span>) <span class="comment">// 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'3.14more non-digit characters'</span>) <span class="comment">// 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parseFloat方法会自动过滤字符串前导的空格</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'\t\v\r12.34\n '</span>) <span class="comment">// 12.34</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>([]) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'FF2'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">''</span>) <span class="comment">// NaN    尤其值得注意，parseFloat会将空字符串转为NaN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些特点使得parseFloat的转换结果不同于Number函数</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">true</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">null</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">''</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">''</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'123.45#'</span>) <span class="comment">// 123.45</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'123.45#'</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></p>
<p>isNaN():   可以用来判断一个值是否为NaN<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">123</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只对数值有效，如果传入其他值，会被先转成数值</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'Hello'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>(<span class="string">'Hello'</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 出于同样的原因，对于对象和数组，isNaN也返回true</span></span><br><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>(&#123;&#125;)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，对于空数组和只有一个数值成员的数组，isNaN返回false ，因为这些数组能被Number函数转成数值</span></span><br><span class="line"><span class="built_in">isNaN</span>([]) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="number">123</span>]) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">'123'</span>]) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此，使用isNaN之前，最好判断一下数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIsNaN</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'number'</span> &amp;&amp; <span class="built_in">isNaN</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIsNaN</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value !== value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>isFinite():  返回一个布尔值，表示某个值是否为正常的数值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">null</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="number">-1</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。</p>
<ul>
<li>转义, 反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">\<span class="number">0</span> ：<span class="literal">null</span>（\u0000）</span><br><span class="line">\b ：后退键（\u0008）</span><br><span class="line">\f ：换页符（\u000C）</span><br><span class="line">\n ：换行符（\u000A）</span><br><span class="line">\r ：回车键（\u000D）</span><br><span class="line">\t ：制表符（\u0009）</span><br><span class="line">\v ：垂直制表符（\u000B）</span><br><span class="line">\<span class="string">' ：单引号（\u0027）</span></span><br><span class="line"><span class="string">\" ：双引号（\u0022）</span></span><br><span class="line"><span class="string">\\ ：反斜杠（\u005C）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 反斜杠还有三种特殊用法</span></span><br><span class="line"><span class="string">\HHH     //  反斜杠后面紧跟三个八进制数（000到377），代表一个字符  HHH对应该字符的 Unicode 码点, 只能输出256种字符。 如\251表示版权符号</span></span><br><span class="line"><span class="string">\xHH     //  \x后面紧跟两个十六进制数（00到FF），代表一个字符     HH对应该字符的 Unicode 码点，只能输出256种字符比如\xA9表示版权符号</span></span><br><span class="line"><span class="string">\uXXXX   //  \u后面紧跟四个十六进制数（0000到FFFF），代表一个字符 XXXX对应该字符的 Unicode 码点，比如\u00A9表示版权符号</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。</span></span><br><span class="line"><span class="string">'</span>\a<span class="string">'  // "a"</span></span><br><span class="line"><span class="string">``` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* 字符集:</span></span><br><span class="line"><span class="string">JavaScript 引擎内部，所有字符都用 Unicode 表示。不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符。</span></span><br><span class="line"><span class="string">每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。</span></span><br><span class="line"><span class="string">对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。 如 '</span>𝌆<span class="string">'.length === 2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* Base64 转码： 一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。</span></span><br><span class="line"><span class="string">文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。</span></span><br><span class="line"><span class="string">有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。</span></span><br><span class="line"><span class="string">使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">JavaScript 原生提供两个 Base64 相关的方法， 但不适合非 ASCII 码的字符，会报错</span></span><br><span class="line"><span class="string">btoa()：任意值转为 Base64 编码</span></span><br><span class="line"><span class="string">atob()：Base64 编码转为原来的值</span></span><br><span class="line"><span class="string">```JavaScript</span></span><br><span class="line"><span class="string">var str = '</span>Hello World!<span class="string">';</span></span><br><span class="line"><span class="string">btoa(str)  // "SGVsbG8gV29ybGQh"</span></span><br><span class="line"><span class="string">atob('</span>SGVsbG8gV29ybGQh<span class="string">') // "Hello World!</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用encodeURIComponent、decodeURIComponent这两个方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任意值转为 Base64 编码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Encode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> btoa(<span class="built_in">encodeURIComponent</span>(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Base64 编码转为原来的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b64Decode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(atob(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b64Encode(<span class="string">'你好'</span>) <span class="comment">// "JUU0JUJEJUEwJUU1JUE1JUJE"</span></span><br><span class="line">b64Decode(<span class="string">'JUU0JUJEJUEwJUU1JUE1JUJE'</span>) <span class="comment">// "你好"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对象就是一组“键值对”（key-value）成员的集合，是一种无序的复合数据集合。<br>对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。<br>如果键名是数值，会被自动转为字符串。如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。</p>
<p>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。<br>属性可以动态创建，不必在对象声明时就指定。</p>
<h5 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line">o1.a = <span class="number">1</span>;</span><br><span class="line">o2.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line">o1 = <span class="number">1</span>;</span><br><span class="line">o2 <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = x;</span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">y <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h5 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h5><ul>
<li><p>读取对象的属性<br>有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。<br>请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。方括号运算符内部还可以使用表达式。<br>数字键可以不加引号，因为会自动转成字符串，但数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo   <span class="comment">// 1  引用对象obj的foo属性时，如果使用点运算符，foo就是字符串</span></span><br><span class="line">obj[foo]  <span class="comment">// 2  如果使用方括号运算符，但是不使用引号，那么foo就是一个变量，指向字符串bar</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>属性的查看<br>Object.keys(obj): 返回对象自身的所有可枚举的属性名称的数组<br>Object.values(obj):  返回给定对象自身可枚举值的数组<br>Object.entries():  返回一个给定对象自身可枚举属性的键值对数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj)    <span class="comment">//  ['foo', 'baz']</span></span><br><span class="line"><span class="built_in">Object</span>.values(obj)  <span class="comment">//  ['bar', 42]</span></span><br><span class="line"><span class="built_in">Object</span>.entries(object1)  <span class="comment">// [[ 'foo', 'bar' ], [ 'baz', 42 ]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'key:'</span>, key, <span class="string">'value: '</span>,obj[key])  </span><br><span class="line">   <span class="comment">// key: foo  value: bar</span></span><br><span class="line">   <span class="comment">// key: baz  value: 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性的遍历<br>for…in  遍历对象自身的和继承的可枚举的属性。 对象obj继承了toString属性，该属性不会被for…in循环遍历到，因为它默认是“不可遍历”的。</p>
</li>
<li><p>属性是否存在：<br>in 运算符，如’name’ in obj，检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。它不能识别哪些属性是对象自身的，哪些属性是继承的。</p>
</li>
</ul>
<p>hasOwnProperty：是否为对象自身的属性。如 obj.hasOwnProperty(‘toString’))  false</p>
<ul>
<li>属性的删除<br>delete: 删除对象本身的属性，无法删除继承的属性，删除成功后返回true。 注意，删除一个不存在的属性，delete不报错，而且返回true。只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。<br>本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。<br>JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（2^32 - 1），length属性的最大值就是 4294967295。</p>
<p>清空数组的一个有效方法，就是将length属性设为0。</p>
<ul>
<li><p>in 运算符<br>检查某个键名是否存在的运算符in，适用于对象，也适用于数组。</p>
</li>
<li><p>数组的遍历<br>可以考虑使用for循环、while循环，或者forEach。 不推荐使用for…in遍历数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> ]</span><br><span class="line"><span class="keyword">typeof</span> arr <span class="comment">// "object"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'2'</span> <span class="keyword">in</span> arr <span class="comment">// true  数组存在键名为2的键</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">in</span> arr  <span class="comment">// true   由于键名都是字符串，所以数值2会自动转成字符串</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">in</span> arr <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr2.foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr2.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr2[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while循环</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; arr2.length) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr2[i]);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆向遍历</span></span><br><span class="line"><span class="keyword">var</span> len = arr2.length;</span><br><span class="line"><span class="keyword">while</span> (len--) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr2[len]);  <span class="comment">// 3 2 1   </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach</span></span><br><span class="line">arr2.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。但是，for...in不仅会遍历数组所有的数字键，还会遍历非数字键</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> arr2) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);   <span class="comment">// 0 1 2 foo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组的空位<br>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, , <span class="number">2</span>,]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的空位不影响length属性</span></span><br><span class="line">a.length <span class="comment">// 3   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性</span></span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">2</span>]  <span class="comment">// true</span></span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// undefined</span></span><br><span class="line">a.length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>length属性不过滤空位。所以，使用length属性进行数组遍历，一定要非常小心<br>数组的某个位置是空位，与某个位置是undefined，是不一样的。<br>如果是空位，使用数组的forEach方法、for…in结构、以及Object.keys方法进行遍历，空位都会被跳过。如果某个位置是undefined，遍历的时候就不会被跳过,输出undefined。</p>
<ul>
<li>类似数组的对象 array-like object<br>如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”<br>但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。没有数组的push方法，使用该方法就会报错。length属性不是动态值，不会随着成员的变化而变。<br>典型的“类似数组的对象”是函数的arguments对象，以及大多数 DOM 元素集，还有字符串。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的slice方法可以将“类似数组的对象”变成真正的数组。</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过call()把数组的方法放到对象上面。</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.forEach.call(arrayLike, print)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index + <span class="string">' : '</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。</p>
<h5 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h5><p>JavaScript 有三种声明函数的方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function 命令</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式   </span></span><br><span class="line"><span class="comment">// 采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效</span></span><br><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;; <span class="comment">// 函数的表达式需要在语句的结尾加上分号，表示语句结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function 构造函数   </span></span><br><span class="line"><span class="comment">// Function构造函数可以不使用new命令，返回结果完全一样</span></span><br><span class="line"><span class="comment">// 最后一个参数是函数的“函数体”，其他参数都是add函数的参数。如果只有一个参数，该参数就是函数体。</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'return x + y'</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数的重复声明: 函数名视同变量名，函数名会提升。如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。</p>
<p>第一等公民: 函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。</p>
<ul>
<li>函数的属性和方法<br>name: 函数的name属性返回函数的名字<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f1.name <span class="comment">// "f1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是通过变量赋值定义的函数，那么name属性返回变量名</span></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">f2.name <span class="comment">// "f2"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么name属性返回function关键字之后的那个函数名。</span></span><br><span class="line"><span class="keyword">var</span> f3 = <span class="function"><span class="keyword">function</span> <span class="title">myName</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">f3.name <span class="comment">// 'myName'    返回了函数表达式的名字。注意，真正的函数名还是f3，而myName这个名字只在函数体内部可用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// name属性的一个用处，就是获取参数函数的名字</span></span><br><span class="line"><span class="keyword">var</span> myFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f.name);</span><br><span class="line">&#125;</span><br><span class="line">test(myFunc) <span class="comment">// myFunc  函数test内部通过name属性，就可以知道传入的参数是什么函数。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>length： 函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。与实际传入的参数个数无关。</p>
<p>toString(): 函数的toString方法返回一个字符串，内容是函数的源码。函数内部的注释也可以返回。利用这一点，可以变相实现多行字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> multiline = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = fn.toString().split(<span class="string">'\n'</span>);</span><br><span class="line">  <span class="keyword">return</span> arr.slice(<span class="number">1</span>, arr.length - <span class="number">1</span>).join(<span class="string">'\n'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是一个</span></span><br><span class="line"><span class="comment">  多行注释</span></span><br><span class="line"><span class="comment">*/</span>&#125;</span><br><span class="line"></span><br><span class="line">multiline(f);</span><br><span class="line"><span class="comment">// " 这是一个</span></span><br><span class="line"><span class="comment">//   多行注释"</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>函数本身的作用域<br>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时/定义时所在的作用域，与其运行时/调用时所在的作用域无关。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  x();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1   函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>参数的传递方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">p1</span>) </span>&#123;</span><br><span class="line">  p1 = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">f(p1);</span><br><span class="line">p1 <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。传入函数的原始值的地址，在函数内部修改参数，将会影响到原始值。</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">p2</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o.p2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">f(obj1);</span><br><span class="line">obj1.p2 <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值</span></span><br><span class="line"><span class="keyword">var</span> obj2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line">f(obj2);</span><br><span class="line">obj2 <span class="comment">// [1, 2, 3]  这是因为，形式参数（o）的值实际是参数obj的地址，重新对o赋值导致o指向另一个地址，保存在原地址上的值当然不受影响</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>arguments 对象<br>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。<br>arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。<br>通过arguments对象的length属性，可以判断函数调用时到底带几个参数。<br>正常模式下，arguments对象可以在运行时修改。严格模式下，arguments对象与函数参数不具有联动关系。也就是说，修改arguments对象不会影响到实际的函数参数。</p>
</li>
</ul>
<p>需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slice方法</span></span><br><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐一填入新数组</span></span><br><span class="line"><span class="keyword">var</span> args = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">  args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>闭包  closure<br>理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。但是，函数外部无法读取函数内部声明的变量。</li>
</ul>
<p>如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。</p>
<p>这就是 JavaScript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="comment">// 闭包就是函数f2，即能够读取其他函数内部变量的函数。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure></p>
<p>由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p>闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。闭包可以看作是函数内部作用域的一个接口，闭包使得内部变量记住上一次调用时的运算结果。始终在内存中，不会在调用结束后，被垃圾回收机制回收。</p>
<p>闭包的另一个用处，是封装对象的私有属性和私有方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _age;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setAge</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    _age = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    getAge: getAge,</span><br><span class="line">    setAge: setAge</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = Person(<span class="string">'张三'</span>);</span><br><span class="line">p1.setAge(<span class="number">25</span>);</span><br><span class="line">p1.getAge() <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码中，函数Person的内部变量_age，通过闭包getAge和setAge，变成了返回对象p1的私有变量。</span></span><br></pre></td></tr></table></figure></p>
<p>注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p>
<ul>
<li>立即调用的函数表达式 IIFE （Immediately-Invoked Function Expression）<br>在 JavaScript 中，圆括号()是一种运算符，跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。</li>
</ul>
<p>有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;();  <span class="comment">// Uncaught SyntaxError: Unexpected token (</span></span><br><span class="line"><span class="comment">// 产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。</span></span><br><span class="line"><span class="comment">// 语句</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句。因此，JavaScript 引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。</p>
<p>解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”，简称 IIFE。</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;());</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;)();</span><br><span class="line"><span class="comment">// 注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">-<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">+<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure></p>
<p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符是处理数据的基本方法，用来从现有的值得到新的值。JavaScript 提供了多种运算符，覆盖了所有主要的运算。</p>
<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>JavaScript 共提供10个算术运算符，用来完成基本的算术运算。<br>加法x + y、 减法 x - y、 乘法 x * y、 除法x / y、 指数x ** y、 余数x % y、 自增++x 或者 x++、 自减–x 或者 x–、 数值 +x、 负数值-x</p>
<ul>
<li><p>加法运算符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加法运算符（+）是最常见的运算符，用来求两个数值的和。</span></span><br><span class="line"><span class="number">1</span> + <span class="number">1</span> <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript 允许非数值的相加。</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span> <span class="comment">// 2  布尔值都会自动转成数值，然后再相加</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">true</span> <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起。</span></span><br><span class="line"><span class="string">'a'</span> + <span class="string">'bc'</span> <span class="comment">// "abc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。</span></span><br><span class="line"><span class="number">1</span> + <span class="string">'a'</span> <span class="comment">// "1a"</span></span><br><span class="line"><span class="literal">false</span> + <span class="string">'a'</span> <span class="comment">// "falsea"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）</span></span><br><span class="line"><span class="string">'3'</span> + <span class="number">4</span> + <span class="number">5</span> <span class="comment">// "345"</span></span><br><span class="line"><span class="number">3</span> + <span class="number">4</span> + <span class="string">'5'</span> <span class="comment">// "75"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。</span></span><br><span class="line"><span class="number">1</span> - <span class="string">'2'</span> <span class="comment">// -1</span></span><br><span class="line"><span class="number">1</span> * <span class="string">'2'</span> <span class="comment">// 2</span></span><br><span class="line"><span class="number">1</span> / <span class="string">'2'</span> <span class="comment">// 0.5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的相加  如果运算子是对象，必须先转成原始类型的值，然后再相加。</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj1 + <span class="number">2</span> <span class="comment">// "[object Object]2"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象转成原始类型的值，规则如下。</span></span><br><span class="line"><span class="comment">// 首先，自动调用对象的valueOf方法。一般来说，对象的valueOf方法总是返回对象自身，这时再自动调用对象的toString方法，将其转为字符串。对象的toString方法默认返回[object Object]</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line">obj1.valueOf() <span class="comment">// &#123;p: 1&#125;</span></span><br><span class="line">obj1.valueOf().toString() <span class="comment">// "[object Object]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 知道了这个规则以后，就可以自己定义valueOf方法或toString方法，得到想要的结果。</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj2 + <span class="number">2</span> <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj3 + <span class="number">2</span> <span class="comment">// "hello2"   只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里有一个特例，如果运算子是一个Date对象的实例，那么会优先执行toString方法。</span></span><br><span class="line"><span class="keyword">var</span> obj4 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">obj4.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &#125;;</span><br><span class="line">obj4.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'hello'</span> &#125;;</span><br><span class="line">obj4 + <span class="number">2</span> <span class="comment">// "hello2"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>余数运算符<br>余数运算符（%）返回前一个运算子被后一个运算子除，所得的余数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span> % <span class="number">5</span> <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是，运算结果的正负号由第一个运算子的正负号决定。</span></span><br><span class="line"><span class="number">-1</span> % <span class="number">2</span> <span class="comment">// -1</span></span><br><span class="line"><span class="number">1</span> % <span class="number">-2</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以，为了得到负数的正确余数值，可以先使用绝对值函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOdd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// return n % 2 === 1;   // 错误的写法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(n % <span class="number">2</span>) === <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自增和自减运算符<br>自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量。</p>
</li>
</ul>
<p>运算之后，变量的值发生变化，这种效应叫做运算的副作用（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。</p>
<p>注意，运算符放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">x++ <span class="comment">// 1</span></span><br><span class="line">++y <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<h4 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h4><p>布尔运算符用于将表达式转为布尔值，一共包含四个运算符。</p>
<p>取反运算符：!<br>将布尔值变为相反值, 对于非布尔值，取反运算符会将其转为布尔值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// undefined、null、false、0、NaN、空字符串（''）六个值取反后为true，其他值都为false。</span></span><br><span class="line">!<span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line">!<span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line">!<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line">!<span class="literal">NaN</span> <span class="comment">// true</span></span><br><span class="line">!<span class="string">""</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">!<span class="number">54</span> <span class="comment">// false</span></span><br><span class="line">!<span class="string">'hello'</span> <span class="comment">// false</span></span><br><span class="line">![] <span class="comment">// false</span></span><br><span class="line">!&#123;&#125; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对一个值连续做两次取反运算，等于将其转为对应的布尔值，与Boolean函数的作用相同。这是一种常用的类型转换的写法。</span></span><br><span class="line">!!x</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Boolean</span>(x)</span><br></pre></td></tr></table></figure></p>
<p>且运算符 &amp;&amp;<br>它的运算规则是：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i) &#123;</span><br><span class="line">  doSomething()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">i &amp;&amp; doSomething()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。如果所有表达式的布尔值都为true，则返回最后一个表达式的值。</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="number">0</span> &amp;&amp; <span class="number">3</span>  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p>
<p>或运算符 ||<br>如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 或运算符可以多个连用，这时返回第一个布尔值为true的表达式的值。如果所有表达式都为false，则返回最后一个表达式的值。</span></span><br><span class="line"><span class="literal">false</span> || <span class="number">0</span> || <span class="string">''</span> || <span class="number">4</span> || <span class="string">'foo'</span> || <span class="literal">true</span>     <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或运算符常用于为一个变量设置默认值。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  text = text || <span class="string">''</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者写成</span></span><br><span class="line">saveText(<span class="keyword">this</span>.text || <span class="string">''</span>)</span><br></pre></td></tr></table></figure></p>
<p>三元运算符 ? :<br>JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值。</p>
<p>通常来说，三元条件表达式与if…else语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，if…else是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用if..else<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'t'</span> ? <span class="string">'hello'</span> : <span class="string">'world'</span>  <span class="comment">// "hello"</span></span><br><span class="line"><span class="number">0</span> ? <span class="string">'hello'</span> : <span class="string">'world'</span>   <span class="comment">// "world"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> ? <span class="string">'T'</span> : <span class="string">'F'</span>)</span><br><span class="line"><span class="comment">// 上面代码中，console.log方法的参数必须是一个表达式，这时就只能使用三元条件表达式。如果要用if...else语句，就必须改变整个代码写法了。</span></span><br></pre></td></tr></table></figure></p>
<h4 id="二进制位运算符"><a href="#二进制位运算符" class="headerlink" title="二进制位运算符"></a>二进制位运算符</h4><p>二进制位运算符用于直接对二进制位进行计算，一共有7个。</p>
<p>这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错。</p>
<p>有一点需要特别注意，位运算符只对整数起作用，遇到小数时，会将小数部分舍去，只保留整数部分，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。</p>
<p>二进制或运算符（or）：符号为|，表示若两个二进制位之中只要有一个为1，则结果为1，否则为0<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> | <span class="number">3</span>  <span class="comment">// 3    0和3的二进制形式分别是00和11，所以进行二进制或运算会得到11（即3）</span></span><br><span class="line"><span class="comment">// 位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与0进行二进制或运算，等同于对该数去除小数部分，即取整数位。</span></span><br><span class="line">i = i | <span class="number">0</span>;  <span class="comment">// 就是将i（不管是整数或小数）转为32位整数。  </span></span><br><span class="line"><span class="number">2147483649.4</span> | <span class="number">0</span>;  <span class="comment">// -2147483647   不适用超过32位整数最大值2147483647的数</span></span><br></pre></td></tr></table></figure></p>
<p>二进制与运算符（and）：符号为&amp;，表示若两个二进制位都为1，则结果为1，否则为0<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> &amp; <span class="number">3</span> <span class="comment">// 0    0（二进制00）和3（二进制11）进行二进制与运算会得到00（即0）</span></span><br></pre></td></tr></table></figure></p>
<p>二进制否运算符（not）：符号为~，表示对一个二进制位取反（0变为1，1变为0）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="number">3</span> <span class="comment">// -4</span></span><br><span class="line"><span class="comment">// JavaScript 内部将所有的运算子都转为32位的二进制整数再进行运算。 3的32位整数形式是00000000000000000000000000000011，二进制否运算以后得到11111111111111111111111111111100。由于第一位（符号位）是1，所以这个数是一个负数。JavaScript 内部采用补码形式表示负数，即需要将这个数减去1，再取一次反，然后加上负号，才能得到这个负数对应的10进制值。这个数减去1等于11111111111111111111111111111011，再取一次反得到00000000000000000000000000000100，再加上负号就是-4。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单记忆成，一个数与自身的取反值相加，等于-1。</span></span><br><span class="line">~ <span class="number">-3</span> <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对一个整数连续两次二进制否运算，得到它自身。</span></span><br><span class="line">~~<span class="number">3</span> <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用二进制否运算取整，是所有取整方法中最快的一种。</span></span><br><span class="line">~~<span class="number">1.999</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对字符串进行二进制否运算，JavaScript 引擎会先调用Number函数，将字符串转为数值。</span></span><br><span class="line">~<span class="string">'011'</span>  <span class="comment">// -12  // 相当于~Number('011')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于其他类型的值，二进制否运算也是先用Number转为数值，然后再进行处理。</span></span><br><span class="line">~[] <span class="comment">// -1    // 相当于 ~Number([])</span></span><br><span class="line">~<span class="literal">NaN</span> <span class="comment">// -1   // 相当于 ~Number(NaN)</span></span><br><span class="line">~<span class="literal">null</span> <span class="comment">// -1  // 相当于 ~Number(null)</span></span><br></pre></td></tr></table></figure></p>
<p>异或运算符（xor）：符号为^，表示若两个二进制位不相同，则结果为1，否则为0<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ^ <span class="number">3</span> <span class="comment">// 3    0（二进制00）与3（二进制11）进行异或运算，它们每一个二进制位都不同，所以得到11（即3）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异或运算 有一个特殊运用，连续对两个数a和b进行三次异或运算，可以互换它们的值。 这是互换两个变量的值的最快方法。</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>, b = <span class="number">3</span></span><br><span class="line">a ^= b </span><br><span class="line">b ^= a </span><br><span class="line">a ^= b</span><br><span class="line"></span><br><span class="line">a <span class="comment">// 3</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异或运算也可以用来取整。</span></span><br><span class="line"><span class="number">12.9</span> ^ <span class="number">0</span> <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p>
<p>左移运算符（left shift）：符号为&lt;&lt;  ，表示将一个数的二进制值向左移动指定的位数，尾部补0，即乘以2的指定次方。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> &lt;&lt; <span class="number">1</span>   <span class="comment">// 8    4 的二进制形式为100，左移一位为1000（即十进制的8），相当于乘以2的1次方</span></span><br><span class="line"><span class="number">-4</span> &lt;&lt; <span class="number">1</span>  <span class="comment">// -8  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效。</span></span><br><span class="line"><span class="number">13.5</span> &lt;&lt; <span class="number">0</span>  <span class="comment">// 13</span></span><br><span class="line"><span class="number">-13.5</span> &lt;&lt; <span class="number">0</span>  <span class="comment">// -13</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 左移运算符用于二进制数值非常方便。</span></span><br><span class="line"><span class="comment">// 使用左移运算符，将颜色的 RGB 值转为 HEX 值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RGB to HEX</span></span><br><span class="line"><span class="comment">// (1 &lt;&lt; 24)的作用为保证结果是6位数</span></span><br><span class="line"><span class="keyword">var</span> rgb2hex = <span class="function"><span class="keyword">function</span>(<span class="params">r, g, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'#'</span> + ((<span class="number">1</span> &lt;&lt; <span class="number">24</span>) + (r &lt;&lt; <span class="number">16</span>) + (g &lt;&lt; <span class="number">8</span>) + b)</span><br><span class="line">    .toString(<span class="number">16</span>) <span class="comment">// 先转成十六进制，然后返回字符串</span></span><br><span class="line">    .substr(<span class="number">1</span>);   <span class="comment">// 去除字符串的最高位，返回后面六个字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> color = &#123;<span class="attr">r</span>: <span class="number">186</span>, <span class="attr">g</span>: <span class="number">218</span>, <span class="attr">b</span>: <span class="number">85</span>&#125;;</span><br><span class="line">rgb2hex(color.r, color.g, color.b)   <span class="comment">// "#bada55"</span></span><br></pre></td></tr></table></figure></p>
<p>右移运算符（right shift）：符号为&gt;&gt;，表示将一个数的二进制值向右移动指定的位数，头部补0，即除以2的指定次方（最高位即符号位不参与移动）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> &gt;&gt; <span class="number">1</span>   <span class="comment">// 2   4的二进制形式为 00000000000000000000000000000100，右移一位得到00000000000000000000000000000010，即为十进制的2</span></span><br><span class="line"><span class="number">-4</span> &gt;&gt; <span class="number">1</span>  <span class="comment">// -2  -4的二进制形式为11111111111111111111111111111100，右移一位，头部补1，得到11111111111111111111111111111110,即为十进制的-2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 右移运算可以模拟 2 的整除运算。</span></span><br><span class="line"><span class="number">21</span> &gt;&gt; <span class="number">3</span>  <span class="comment">// 2   相当于 21 / 8 = 2</span></span><br></pre></td></tr></table></figure></p>
<p>带符号位的右移运算符（zero filled right shift）：符号为&gt;&gt;&gt; ，表示将一个数的二进制形式向右移动，包括符号位也参与移动，头部补0。<br>所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（&gt;&gt;）完全一致，区别主要在于负数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> &gt;&gt;&gt; <span class="number">1</span>   <span class="comment">// 2</span></span><br><span class="line"><span class="number">-4</span> &gt;&gt;&gt; <span class="number">1</span>  <span class="comment">// 2147483646  将-4的二进制形式，带符号位的右移一位，得到01111111111111111111111111111110，即为十进制的2147483646</span></span><br><span class="line"><span class="comment">// 这个运算实际上将一个值转为32位无符号整数。</span></span><br><span class="line"><span class="comment">// 查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符。</span></span><br><span class="line"><span class="number">-1</span> &gt;&gt;&gt; <span class="number">0</span> <span class="comment">// 4294967295   </span></span><br><span class="line"><span class="comment">// -1作为32位整数时，内部的储存形式使用无符号整数格式解读，值为 4294967295，即(2^32)-1，等于11111111111111111111111111111111</span></span><br></pre></td></tr></table></figure></p>
<h4 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h4><p>void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void运算符的优先性很高，建议总是使用圆括号</span></span><br><span class="line"><span class="keyword">void</span> <span class="number">0</span>   <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">void</span>(<span class="number">0</span>)  <span class="comment">// undefined   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转。</span></span><br><span class="line"></span><br><span class="line">&lt;a href=<span class="string">"http://example.com"</span> onclick=<span class="string">"f(); return false;"</span>&gt;点击&lt;<span class="regexp">/a&gt;   /</span><span class="regexp">/ 点击链接后，会先执行onclick的代码，由于onclick返回false，所以浏览器不会跳转到 example.com。</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ void运算符可以取代上面的写法。</span></span><br><span class="line"><span class="regexp">&lt;a href="javascript: void(f())"&gt;文字&lt;/</span>a&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转。</span></span><br><span class="line">&lt;a href=<span class="string">"javascript: void(document.form.submit())"</span>&gt;提交&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h4><p>逗号运算符用于对两个表达式求值，并返回后一个表达式的值。逗号运算符的一个用途是，在返回一个值之前，进行一些辅助操作。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> y = (x++, <span class="number">10</span>);</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = (<span class="built_in">console</span>.log(<span class="string">'Hi!'</span>), <span class="literal">true</span>);  <span class="comment">// Hi!</span></span><br><span class="line">value <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h4><ul>
<li><p>运算符的优先级别（Operator Precedence）<br><img src="/images/expressions-operator-precedence.jpg" alt="JS运算符的优先级"></p>
</li>
<li><p>圆括号的作用<br>圆括号不是运算符，而是一种语法结构，所以不具有求值作用。<br>共有两种用法：一种是把表达式放在圆括号之中，提升运算的优先级，它的优先级是最高的；跟在函数的后面，作用是调用函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(f) <span class="comment">// function f()&#123;return 1;&#125;</span></span><br><span class="line">f() <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆括号之中，只能放置表达式，如果将语句放在圆括号之中，就会报错。</span></span><br><span class="line">(<span class="keyword">var</span> a = <span class="number">1</span>)   <span class="comment">// SyntaxError: Unexpected token var</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>左结合与右结合<br>对于优先级别相同的运算符，大多数情况，计算顺序总是从左到右，这叫做运算符的“左结合”（left-to-right associativity），即从左边开始计算。</p>
</li>
</ul>
<p>少数运算符的计算顺序是从右到左，即从右边开始计算，这叫做运算符的“右结合”。<br>一元运算符(逻辑非、按位非、一元加/减、前置递增/减、typeof、void、delete、await)、赋值运算符（=）、三元条件运算符（?:）和 指数运算符（**）、yield等<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w = x = y = z;   <span class="comment">// 相当于 w = (x = (y = z));</span></span><br><span class="line">q = a ? b : c ? d : e ? f : g;   <span class="comment">// 相当于 q = a ? b : (c ? d : (e ? f : g));</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span>   <span class="comment">// 512   相当于 2 ** (3 ** 2)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h3><p>JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。</p>
<h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><p>强制转换主要指使用Number()、String()和Boolean()三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。</p>
<ul>
<li><p>Number()  可以将任意类型的值转化成数值。分两种情况，一种是参数是原始类型的值，另一种是参数是对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始类型值的转换规则如下:</span></span><br><span class="line"><span class="comment">// 数值：转换后还是原来的值</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">324</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果可以被解析为数值，则转换为相应的数值</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'324'</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果不可以被解析为数值，返回 NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'324abc'</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空字符串转为0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">''</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值：true 转成 1，false 转成 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined：转成 NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null：转成0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'42 cats'</span>) <span class="comment">// 42   parseInt逐个解析字符</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'42 cats'</span>) <span class="comment">// NaN    Number函数整体转换字符串的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'\t\v\r12.34\n'</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'\t\v\r12.34\n'</span>) <span class="comment">// 12.34</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象:</span></span><br><span class="line"><span class="comment">// 第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。</span></span><br><span class="line"><span class="comment">// 第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。</span></span><br><span class="line"><span class="comment">// 第三步，如果toString方法返回的是对象，就报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">5</span>]) <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认情况下，对象的valueOf方法返回对象本身，所以一般总是会调用toString方法，而toString方法返回对象的类型字符串（比如[object Object]）</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;&#125;) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// valueOf和toString方法，都是可以自定义的。valueOf方法先于toString方法执行</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>String()  将任意类型的值转化成字符串  分两种情况，一种是参数是原始类型的值，另一种是参数是对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始类型值:</span></span><br><span class="line"><span class="comment">// 数值：转为相应的字符串。</span></span><br><span class="line"><span class="comment">// 字符串：转换后还是原来的值。</span></span><br><span class="line"><span class="comment">// 布尔值：true转为字符串"true"，false转为字符串"false"。</span></span><br><span class="line"><span class="comment">// undefined：转为字符串"undefined"。</span></span><br><span class="line"><span class="comment">// null：转为字符串"null"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">123</span>) <span class="comment">// "123"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="string">'abc'</span>) <span class="comment">// "abc"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">true</span>) <span class="comment">// "true"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">undefined</span>) <span class="comment">// "undefined"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">null</span>) <span class="comment">// "null"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象:  </span></span><br><span class="line"><span class="comment">// String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。</span></span><br><span class="line"><span class="comment">// 先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。</span></span><br><span class="line"><span class="comment">// 如果toString方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤。</span></span><br><span class="line"><span class="comment">// 如果valueOf方法返回的是对象，就报错。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</span></span><br><span class="line"><span class="built_in">String</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">String</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// "1,2,3"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// valueOf和toString方法，都是可以自定义的。toString方法先于valueOf方法执行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Boolean()   将任意类型的值转为布尔值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它的转换规则相对简单：除了 "", 0, NaN, null, undefined, false 几个值的转换结果为false，其他的值全部为true。</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">''</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有对象（包括空对象）的布尔值都是true，甚至连false对应的布尔对象new Boolean(false)也是true</span></span><br><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 因为 JavaScript 语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于obj1 &amp;&amp; obj2这样的场景，可能会需要较多的计算。为了保证性能，就统一规定，对象的布尔值为true。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h4><p>自动转换是以强制转换为基础的。遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种情况，不同类型的数据互相运算。</span></span><br><span class="line"><span class="number">123</span> + <span class="string">'abc'</span> <span class="comment">// "123abc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种情况，对非布尔值类型的数据求布尔值。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'abc'</span>) &#123;<span class="built_in">console</span>.log(<span class="string">'true'</span>);&#125;  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种情况，对非数值类型的值使用一元运算符（即+和-）。</span></span><br><span class="line">+ &#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125; <span class="comment">// NaN</span></span><br><span class="line">- [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用String函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。 由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String函数进行显式转换。</span></span><br><span class="line"><span class="comment">// 自动转换为布尔值</span></span><br><span class="line"><span class="comment">// JavaScript 遇到预期为布尔值的地方（比如if语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用Boolean函数。</span></span><br><span class="line"><span class="comment">// 除了 "", 0, NaN, null, undefined, false 几个值，其他都是自动转为true。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'abc'</span>) &#123;<span class="built_in">console</span>.log(<span class="string">'true'</span>);&#125;  <span class="comment">// true</span></span><br><span class="line">expression ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">!! expression</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动转换为字符串</span></span><br><span class="line"><span class="comment">// JavaScript 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串。具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串。</span></span><br><span class="line"><span class="comment">// 字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。</span></span><br><span class="line"><span class="string">'5'</span> + <span class="number">1</span> <span class="comment">// '51'</span></span><br><span class="line"><span class="string">'5'</span> + <span class="literal">true</span> <span class="comment">// "5true"</span></span><br><span class="line"><span class="string">'5'</span> + &#123;&#125; <span class="comment">// "5[object Object]"</span></span><br><span class="line"><span class="string">'5'</span> + [] <span class="comment">// "5"</span></span><br><span class="line"><span class="string">'5'</span> + <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125; <span class="comment">// "5function ()&#123;&#125;"</span></span><br><span class="line"><span class="string">'5'</span> + <span class="literal">undefined</span> <span class="comment">// "5undefined"</span></span><br><span class="line"><span class="string">'5'</span> + <span class="literal">null</span> <span class="comment">// "5null"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动转换为数值</span></span><br><span class="line"><span class="comment">// JavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用Number函数。</span></span><br><span class="line"><span class="comment">// 除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。</span></span><br><span class="line"><span class="string">'5'</span> - <span class="string">'2'</span> <span class="comment">// 3</span></span><br><span class="line"><span class="literal">true</span> - <span class="number">1</span>  <span class="comment">// 0</span></span><br><span class="line"><span class="string">'5'</span> * []    <span class="comment">// 0</span></span><br><span class="line"><span class="literal">false</span> / <span class="string">'5'</span> <span class="comment">// 0</span></span><br><span class="line"><span class="string">'abc'</span> - <span class="number">1</span>   <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// null转为数值时为0，而undefined转为数值时为NaN</span></span><br><span class="line"><span class="literal">null</span> + <span class="number">1</span> <span class="comment">// 1</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="number">1</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 一元运算符也会把运算子转成数值。</span></span><br><span class="line">+<span class="string">'abc'</span> <span class="comment">// NaN</span></span><br><span class="line">-<span class="string">'abc'</span> <span class="comment">// NaN</span></span><br><span class="line">+<span class="literal">true</span> <span class="comment">// 1</span></span><br><span class="line">-<span class="literal">false</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h3><h4 id="Error-实例对象"><a href="#Error-实例对象" class="headerlink" title="Error 实例对象"></a>Error 实例对象</h4><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">err.message <span class="comment">// "出错了"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// message：错误提示信息。 必须有message属性</span></span><br><span class="line"><span class="comment">// name：错误名称（非标准属性）</span></span><br><span class="line"><span class="comment">// stack：错误的堆栈（非标准属性）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">catchit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    throwit();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.stack); <span class="comment">// print stack trace</span></span><br><span class="line">    <span class="comment">// Error</span></span><br><span class="line">    <span class="comment">//    at throwit (~/examples/throwcatch.js:9:11)</span></span><br><span class="line">    <span class="comment">//    at catchit (~/examples/throwcatch.js:3:9)</span></span><br><span class="line">    <span class="comment">//    at repl:1:5</span></span><br><span class="line">    <span class="comment">// 上面代码中，错误堆栈的最内层是throwit函数，然后是catchit函数，最后是函数的运行环境</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catchit()</span><br></pre></td></tr></table></figure></p>
<h4 id="原生错误类型"><a href="#原生错误类型" class="headerlink" title="原生错误类型"></a>原生错误类型</h4><p>Error实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。</p>
<ul>
<li><p>SyntaxError 对象<br>解析代码时发生的语法错误。当Javascript语言解析代码时,Javascript引擎发现了不符合语法规范的token或token顺序时抛出SyntaxError.<br>new SyntaxError([message[, fileName[, lineNumber]]])</p>
</li>
<li><p>ReferenceError 对象<br>引用一个不存在的变量时发生的错误，或者将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值</p>
</li>
<li><p>RangeError 对象<br>一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。</p>
</li>
<li><p>TypeError 对象<br>TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。 调用对象不存在的方法，也会抛出TypeError错误，因为obj.unknownMethod的值是undefined，而不是一个函数。</p>
</li>
<li><p>URIError 对象<br>URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。</p>
</li>
<li><p>EvalError 对象<br>eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</p>
</li>
<li><p>自定义错误<br>除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.message = message || <span class="string">'默认信息'</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'UserError'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">UserError.prototype.constructor = UserError;</span><br><span class="line"><span class="comment">// 上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义类型的错误了。</span></span><br><span class="line"><span class="keyword">new</span> UserError(<span class="string">'这是自定义的错误！'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>throw 语句<br>手动中断程序执行，抛出一个错误。throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。<br>遇到throw语句，程序就中止了。引擎会接收到throw抛出的信息，可能是一个错误实例，也可能是其他类型的值。</p>
</li>
<li><p>try…catch…finally<br>一旦发生错误，程序就中止执行了。JavaScript 提供了try…catch结构，允许对错误进行处理，选择是否往下执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;  <span class="comment">// catch接受一个参数，表示try代码块抛出的值</span></span><br><span class="line">  <span class="comment">// 捕获错误，处理错误。 catch代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="built_in">SyntaxError</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e.message)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="built_in">RangeError</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e.message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'完成了'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h3><p>“编程风格”（programming style）指的是编写代码的样式规则，要考虑如何尽量使代码清晰易读、减少出错，风格一致。<br>主要涉及缩进、区块、圆括号、行尾的分号、全局变量、变量声明、相等和严格相等、语句的合并、自增和自减运算符等。</p>
<ul>
<li>switch…case 结构<br>建议switch…case结构可以用对象结构代替。switch…case结构要求，在每一个case的最后一行必须是break语句，否则会接着运行下一个case。这样不仅容易忘记，还会造成代码的冗长。而且，switch…case不使用大括号，不利于代码形式的统一。此外，这种结构类似于goto语句，容易造成程序流程的混乱，使得代码结构混乱不堪，不符合面向对象编程的原则。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAction</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'hack'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'hack'</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'slash'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'slash'</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'run'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'run'</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Invalid action.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议改写成对象结构</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAction</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> actions = &#123;</span><br><span class="line">    <span class="string">'hack'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'hack'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'slash'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'slash'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'run'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'run'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actions[action] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Invalid action.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> actions[action]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="console-对象与控制台"><a href="#console-对象与控制台" class="headerlink" title="console 对象与控制台"></a>console 对象与控制台</h3><p>console对象是 JavaScript 的原生对象，类似 Unix 系统的标准输出stdout和标准错误stderr，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。<br>打开控制台: 按 F12 或者Control + Shift + i（PC）/ Command + Option + i（Mac）。</p>
<h4 id="console-对象的静态方法"><a href="#console-对象的静态方法" class="headerlink" title="console 对象的静态方法"></a>console 对象的静态方法</h4><ul>
<li><p>console.log()<br>console.log方法用于在控制台输出信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">' %s + %s = %s'</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)  <span class="comment">//  1 + 1 = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 它可以接受一个或多个参数，将它们连接起来输出。会自动在每次输出的结尾，添加换行符。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello World'</span>) <span class="comment">// Hello World</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)  <span class="comment">// a b c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">' %s + %s = %s'</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)  <span class="comment">//  1 + 1 = 2</span></span><br><span class="line"><span class="comment">// 支持以下占位符: %s 字符串、%d 整数、%i 整数、%f 浮点数、%o 对象的链接、%c CSS 格式字符串。不同类型的数据必须使用对应的占位符</span></span><br><span class="line"><span class="keyword">var</span> number = <span class="number">11</span> * <span class="number">9</span>;</span><br><span class="line"><span class="keyword">var</span> color = <span class="string">'red'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'%d %s balloons'</span>, number, color);  <span class="comment">// 99 red balloons</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用%c占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'%cThis text is styled!'</span>, <span class="string">'color: red; background: yellow; font-size: 24px;'</span>)   <span class="comment">// 输出的内容将显示为黄底红字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果参数是一个对象，console.log会显示该对象的值。</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125;)  <span class="comment">// &#123;foo: "bar"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>)  <span class="comment">// function Date() &#123; [native code] &#125;    输出Date对象的值，结果为一个构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义console.log方法。</span></span><br><span class="line">[<span class="string">'log'</span>, <span class="string">'info'</span>, <span class="string">'warn'</span>, <span class="string">'error'</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>[method] = <span class="built_in">console</span>[method].bind(</span><br><span class="line">    <span class="built_in">console</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Date</span>().toISOString()</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"出错了！"</span>);   <span class="comment">// 2019-03-02T11:01:37.745Z 出错了！</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>console.table()<br>对于某些复合类型的数据，console.table方法可以将其转为表格显示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> languages = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"JavaScript"</span>, <span class="attr">fileExtension</span>: <span class="string">".js"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"TypeScript"</span>, <span class="attr">fileExtension</span>: <span class="string">".ts"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"CoffeeScript"</span>, <span class="attr">fileExtension</span>: <span class="string">".coffee"</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.table(languages);</span><br></pre></td></tr></table></figure>
</li>
<li><p>console.count()<br>count方法用于计数，输出它被调用了多少次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.count();</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hi '</span> + user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每次调用greet函数，内部的console.count方法就输出执行次数。</span></span><br><span class="line">greet(<span class="string">'bob'</span>)     <span class="comment">// default: 1   // "hi bob"</span></span><br><span class="line">greet(<span class="string">'alice'</span>)   <span class="comment">// default: 2   // "hi alice"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.count(user);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hi "</span> + user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">'bob'</span>)  <span class="comment">// bob: 1   // "hi bob"</span></span><br><span class="line">greet(<span class="string">'bob'</span>)  <span class="comment">// bob: 2   // "hi bob"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>console.dir()、console.dirxml()<br>dir方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">f1</span>: <span class="string">'foo'</span>, <span class="attr">f2</span>: <span class="string">'bar'</span>&#125;)   <span class="comment">// &#123;f1: "foo", f2: "bar"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.dir(&#123;<span class="attr">f1</span>: <span class="string">'foo'</span>, <span class="attr">f2</span>: <span class="string">'bar'</span>&#125;)   <span class="comment">// Object  f1: "foo"   f2: "bar"__proto__: Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。</span></span><br><span class="line"><span class="built_in">console</span>.dir(<span class="built_in">document</span>.body)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node 环境之中，还可以指定以代码高亮的形式输出。</span></span><br><span class="line"><span class="built_in">console</span>.dir(obj, &#123;<span class="attr">colors</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// dirxml方法主要用于以目录树的形式，显示 DOM 节点。</span></span><br><span class="line"><span class="built_in">console</span>.dirxml(<span class="built_in">document</span>.body)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果参数不是 DOM 节点，而是普通的 JavaScript 对象，console.dirxml等同于console.dir。</span></span><br><span class="line"><span class="built_in">console</span>.dirxml([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">console</span>.dir([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>console.assert()<br>主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。<br>它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.assert(<span class="literal">false</span>, <span class="string">'判断条件不成立'</span>)  <span class="comment">// Assertion failed: 判断条件不成立</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'判断条件不成立'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如，判断子节点的个数是否大于等于500。如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。</span></span><br><span class="line"><span class="built_in">console</span>.assert(list.childNodes.length &lt; <span class="number">500</span>, <span class="string">'节点个数大于等于500'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>console.time()，console.timeEnd()<br>用于计时，可以算出一个操作所花费的准确时间。time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，控制台会显示“计时器名称: 所耗费的时间”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">'Array initialize'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array= <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  array[i] = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'Array initialize'</span>);    <span class="comment">// Array initialize: 339.818115234375ms</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>console.group()，console.groupEnd()，console.groupCollapsed()<br>console.group和console.groupEnd这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容。</span></span><br><span class="line"><span class="built_in">console</span>.group(<span class="string">'一级分组'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'一级分组的内容'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.group(<span class="string">'二级分组'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'二级分组的内容'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.groupEnd(); <span class="comment">// 二级分组结束</span></span><br><span class="line"><span class="built_in">console</span>.groupEnd(); <span class="comment">// 一级分组结束</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>console.groupCollapsed方法与console.group方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</p>
<ul>
<li><p>console.trace()<br>显示当前执行的代码在堆栈中的调用路径</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.trace()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trace</span></span><br><span class="line"><span class="comment">//     at repl:1:9</span></span><br><span class="line"><span class="comment">//     at ContextifyScript.Script.runInThisContext (vm.js:50:33)</span></span><br><span class="line"><span class="comment">//     ...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>console.clear()<br>用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，console.clear方法将不起作用。</p>
</li>
</ul>
<h4 id="控制台命令行-API"><a href="#控制台命令行-API" class="headerlink" title="控制台命令行 API"></a>控制台命令行 API</h4><ul>
<li>$_   返回上一个表达式的值</li>
<li>$0 - $4   控制台保存了最近5个在 Elements 面板选中的 DOM 元素，$0代表倒数第一个（最近一个），$1代表倒数第二个，以此类推直到$4。</li>
<li>$(selector)   返回第一个匹配的元素，等同于document.querySelector()</li>
<li>$$(selector)  返回选中的 DOM 对象，等同于document.querySelectorAll</li>
<li>inspect(window)  打开相关面板，并选中相应的元素，显示它的细节。 比如inspect(document)会在 Elements 面板显示document元素</li>
<li>getEventListeners(object) 返回一个对象，该对象的成员为object登记了回调函数的各种事件（比如click或keydown），每个事件对应一个数组，数组的成员为该事件的回调函数</li>
<li>keys(object)  返回一个数组，包含object的所有键名</li>
<li>values(object)  返回一个数组，包含object的所有键值</li>
<li>（9）monitorEvents(object[, events]) 监听特定对象上发生的特定事件。事件发生时，会返回一个Event对象，包含该事件的相关信息</li>
<li><p>unmonitorEvents(object[, events])  用于停止监听   如monitorEvents(window, [“resize”, “scroll”]) </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码分别表示单个事件和多个事件的监听方法。</span></span><br><span class="line">monitorEvents(<span class="built_in">window</span>, [<span class="string">"resize"</span>, <span class="string">"scroll"</span>])</span><br><span class="line">monitorEvents(<span class="built_in">window</span>, <span class="string">"resize"</span>);</span><br><span class="line"><span class="comment">// 下面代码表示如何停止监听</span></span><br><span class="line">monitorEvents($<span class="number">0</span>, <span class="string">'mouse'</span>);</span><br><span class="line">unmonitorEvents($<span class="number">0</span>, <span class="string">'mousemove'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// monitorEvents允许监听同一大类的事件。所有事件可以分成四个大类。</span></span><br><span class="line">mouse：<span class="string">"mousedown"</span>, <span class="string">"mouseup"</span>, <span class="string">"click"</span>, <span class="string">"dblclick"</span>, <span class="string">"mousemove"</span>, <span class="string">"mouseover"</span>, <span class="string">"mouseout"</span>, <span class="string">"mousewheel"</span></span><br><span class="line">key：<span class="string">"keydown"</span>, <span class="string">"keyup"</span>, <span class="string">"keypress"</span>, <span class="string">"textInput"</span></span><br><span class="line">touch：<span class="string">"touchstart"</span>, <span class="string">"touchmove"</span>, <span class="string">"touchend"</span>, <span class="string">"touchcancel"</span></span><br><span class="line">control：<span class="string">"resize"</span>, <span class="string">"scroll"</span>, <span class="string">"zoom"</span>, <span class="string">"focus"</span>, <span class="string">"blur"</span>, <span class="string">"select"</span>, <span class="string">"change"</span>, <span class="string">"submit"</span>, <span class="string">"reset"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听所有key大类的事件</span></span><br><span class="line">monitorEvents($(<span class="string">"#msg"</span>), <span class="string">"key"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>clear()：清除控制台的历史</p>
</li>
<li>copy(object)：复制特定 DOM 元素到剪贴板</li>
<li>dir(object)：显示特定对象的所有属性，是console.dir方法的别名</li>
</ul>
<h4 id="debugger-语句"><a href="#debugger-语句" class="headerlink" title="debugger 语句"></a>debugger 语句</h4><p>debugger语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到debugger语句时会自动停下。如果没有除错工具，debugger语句不会产生任何结果，JavaScript 引擎自动跳过这一句。</p>
<p>Chrome 浏览器中，当代码运行到debugger语句时，就会暂停运行，自动打开脚本源码界面。</p>
<h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><h4 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h4><p>JavaScript 原生提供Object对象,JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。</p>
<p>Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object对象本身的方法,即直接定义在Object对象的方法。</span></span><br><span class="line"><span class="built_in">Object</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123; <span class="built_in">console</span>.log(o) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object的实例方法，即定义在Object原型对象Object.prototype上的方法。它可以被Object实例直接使用</span></span><br><span class="line"><span class="comment">// 凡是定义在Object.prototype对象上面的属性和方法，将被所有实例对象共享</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.print() <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="Object-工具方法"><a href="#Object-工具方法" class="headerlink" title="Object() 工具方法"></a>Object() 工具方法</h5><p>Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果参数为空（或者为undefined和null），Object()返回一个空对象。</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(<span class="literal">undefined</span>);    <span class="comment">// 将undefined和null转为对象，结果得到了一个空对象obj</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(<span class="literal">null</span>);</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例(原始类型值对应的包装对象)</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(<span class="number">1</span>);</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(arr); <span class="comment">// 返回原数组</span></span><br><span class="line">obj === arr <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用这一点，可以写一个判断变量是否为对象的函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value === <span class="built_in">Object</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isObject([]) <span class="comment">// true</span></span><br><span class="line">isObject(<span class="literal">true</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<h5 id="new-Object-构造函数"><a href="#new-Object-构造函数" class="headerlink" title="new Object() 构造函数"></a>new Object() 构造函数</h5><p>Object不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用new命令。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object构造函数的首要用途，是直接通过它来生成新对象。</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以接受一个参数，如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;; </span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>(o1);</span><br><span class="line">o1 === o2 <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object构造函数的用法与工具方法虽然用法相似,但语义不同，Object(value)表示将value转成一个对象，new Object(value)则表示新生成一个对象，它的值是value</span></span><br></pre></td></tr></table></figure></p>
<h5 id="Object-的静态方法"><a href="#Object-的静态方法" class="headerlink" title="Object 的静态方法"></a>Object 的静态方法</h5><ul>
<li>Object.keys()，Object.getOwnPropertyNames()<br>由于 JavaScript 没有提供计算对象属性个数的方法，所以可以用这两个方法代替。如Object.keys(obj).length<br>Object.keys方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）可枚举的属性名。<br>Object.getOwnPropertyNames方法与Object.keys类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有(含不可枚举)属性名。</li>
<li>对象属性模型的相关方法<br>Object.getOwnPropertyDescriptor()：获取某个属性的描述对象。<br>Object.defineProperty()：通过描述对象，定义某个属性。<br>Object.defineProperties()：通过描述对象，定义多个属性。</li>
<li>控制对象状态的方法<br>Object.preventExtensions()：防止对象扩展。<br>Object.isExtensible()：判断对象是否可扩展。<br>Object.seal()：禁止对象配置。<br>Object.isSealed()：判断一个对象是否可配置。<br>Object.freeze()：冻结一个对象。<br>Object.isFrozen()：判断一个对象是否被冻结</li>
<li>原型链相关方法<br>Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。<br>Object.getPrototypeOf()：获取对象的Prototype对象。</li>
</ul>
<h5 id="Object-的实例方法"><a href="#Object-的实例方法" class="headerlink" title="Object 的实例方法"></a>Object 的实例方法</h5><p>除了静态方法，还有不少方法定义在Object.prototype对象。它们称为实例方法，所有Object的实例对象都继承了这些方法。</p>
<ul>
<li><p>Object.prototype.valueOf()：返回当前对象对应的值。默认情况下返回对象本身。自动类型转换时会默认调用这个方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="number">1</span> + obj <span class="comment">// "1[object Object]"    默认调用valueOf()方法，求出obj的值再与1相加。可自定义valueOf方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.prototype.toString()：返回当前对象对应的字符串形式。默认情况下返回类型字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于一个对象调用toString方法，会返回字符串[object Object]，该字符串说明对象的类型</span></span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o1.toString() <span class="comment">// "[object Object]"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line">o2.toString() <span class="comment">// "[object Object]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString原始方法。</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].toString() <span class="comment">// "1,2,3"</span></span><br><span class="line"><span class="string">'123'</span>.toString() <span class="comment">// "123"</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;).toString()</span><br><span class="line"><span class="comment">// "function () &#123;</span></span><br><span class="line"><span class="comment">//   return 123;</span></span><br><span class="line"><span class="comment">// &#125;"</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Date</span>()).toString()  <span class="comment">// "Sun Mar 03 2019 13:11:11 GMT+0800 (China Standard Time)"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.prototype.toString方法返回对象的类型字符串，是一个十分有用的判断数据类型的方法。 不使用可能被覆盖的obj.toString()自定义方法。</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(value)</span><br><span class="line"><span class="comment">// 不同数据类型的Object.prototype.toString方法返回值如下。</span></span><br><span class="line">数值：返回[object <span class="built_in">Number</span>]。</span><br><span class="line">字符串：返回[object <span class="built_in">String</span>]。</span><br><span class="line">布尔值：返回[object <span class="built_in">Boolean</span>]。</span><br><span class="line"><span class="literal">undefined</span>：返回[object Undefined]。</span><br><span class="line"><span class="literal">null</span>：返回[object Null]。</span><br><span class="line">数组：返回[object <span class="built_in">Array</span>]。</span><br><span class="line"><span class="built_in">arguments</span> 对象：返回[object Arguments]。</span><br><span class="line">函数：返回[object <span class="built_in">Function</span>]。</span><br><span class="line"><span class="built_in">Error</span> 对象：返回[object <span class="built_in">Error</span>]。</span><br><span class="line"><span class="built_in">Math</span> 对象：返回[object <span class="built_in">Math</span>]。</span><br><span class="line"><span class="built_in">Date</span> 对象：返回[object <span class="built_in">Date</span>]。</span><br><span class="line"><span class="built_in">RegExp</span> 对象：返回[object <span class="built_in">RegExp</span>]。</span><br><span class="line">其他对象：返回[object <span class="built_in">Object</span>]。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用这个特性，可以写出一个比typeof运算符更准确的类型判断函数。</span></span><br><span class="line"><span class="keyword">var</span> type = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="built_in">Object</span>.prototype.toString.call(o);</span><br><span class="line">  <span class="keyword">return</span> s.match(<span class="regexp">/\[object (.*?)\]/</span>)[<span class="number">1</span>].toLowerCase();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type(&#123;&#125;); <span class="comment">// "object"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在上面这个type函数的基础上，还可以加上专门判断某种类型数据的方法。</span></span><br><span class="line">[<span class="string">'Null'</span>, <span class="string">'Undefined'</span>, <span class="string">'Object'</span>, <span class="string">'Array'</span>, <span class="string">'String'</span>, <span class="string">'Number'</span>, <span class="string">'Boolean'</span>, <span class="string">'Function'</span>, <span class="string">'RegExp'</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">  type[<span class="string">'is'</span> + t] = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type(o) === t.toLowerCase();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">type.isRegExp(<span class="regexp">/abc/</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。</p>
</li>
<li>Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。</li>
<li>Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。</li>
<li>Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。</li>
</ul>
<h4 id="属性描述对象"><a href="#属性描述对象" class="headerlink" title="属性描述对象"></a>属性描述对象</h4><p>JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性描述对象提供6个元属性</span></span><br><span class="line">&#123;</span><br><span class="line">  value: <span class="literal">undefined</span>,  <span class="comment">// 目标属性的值，默认为 undefined</span></span><br><span class="line">  writable: <span class="literal">true</span>,    <span class="comment">// 是否可写，默认为 true</span></span><br><span class="line">  enumerable: <span class="literal">true</span>,  <span class="comment">// 是否可枚举，默认为true   </span></span><br><span class="line">  <span class="comment">// 有四个操作会忽略enumerable为false的属性</span></span><br><span class="line">    <span class="comment">// for...in循环：只遍历对象自身的和继承的可枚举的属性。</span></span><br><span class="line">    <span class="comment">// Object.keys()：返回对象自身的所有可枚举的属性的键名。</span></span><br><span class="line">    <span class="comment">// JSON.stringify()：只串行化对象自身的可枚举的属性。</span></span><br><span class="line">    <span class="comment">// Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性</span></span><br><span class="line">  configurable: <span class="literal">true</span>,   <span class="comment">// 是否可配置性，默认为true</span></span><br><span class="line">  <span class="comment">// 若为false，将阻止某些操作改写该属性，比如无法删除，也不得改变该属性的属性描述对象（value除外）,即configurable属性控制了属性描述对象的可写性</span></span><br><span class="line">  get: <span class="literal">undefined</span>,  <span class="comment">// 该属性的取值函数（getter），默认为undefined</span></span><br><span class="line">  set: <span class="literal">undefined</span>   <span class="comment">// 该属性的存值函数（setter），默认为undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript 还提供了存取器的另一种写法。这种写法与上面定义属性描述对象是等价的，而且使用更广泛。</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  get p() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'getter'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  set p(value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setter: '</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存取器往往用于，属性的值依赖对象内部数据的场合。</span></span><br><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">  $n : <span class="number">5</span>,</span><br><span class="line">  get next() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.$n++ &#125;,</span><br><span class="line">  set next(n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="keyword">this</span>.$n) <span class="keyword">this</span>.$n = n;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'新的值必须大于当前值'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.next <span class="comment">// 5    next属性的存值函数和取值函数，都依赖于内部属性$n。</span></span><br><span class="line">obj.next = <span class="number">10</span>;</span><br><span class="line">obj.next <span class="comment">// 10</span></span><br><span class="line">obj.next = <span class="number">5</span>;  <span class="comment">// Uncaught Error: 新的值必须大于当前值</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>Object.getOwnPropertyDescriptor()<br>可以获取自身属性描述对象，不能用于继承的属性。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="string">'a'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'p'</span>)  <span class="comment">// &#123; value: "a", writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.getOwnPropertyNames()<br>返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames([])   <span class="comment">// [ 'length' ]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(<span class="built_in">Object</span>.prototype)   </span><br><span class="line"><span class="comment">// ["constructor", "__defineGetter__", "__defineSetter__", "hasOwnProperty", "__lookupGetter__", "__lookupSetter__", "isPrototypeOf", "propertyIsEnumerable", "toString", "valueOf", "__proto__", "toLocaleString"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.defineProperty(object, propertyName, attributesObject)<br>允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value默认为undefined，writable、configurable、enumerable默认为false</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'p'</span>, &#123;</span><br><span class="line">  value: <span class="literal">undefined</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一次性定义或修改多个属性，可以使用Object.defineProperties()方法。</span></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">  p1: &#123; <span class="attr">value</span>: <span class="number">123</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  p2: &#123; <span class="attr">value</span>: <span class="string">'abc'</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  p3: &#123; <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.p1 + <span class="keyword">this</span>.p2 &#125;, <span class="attr">enumerable</span>:<span class="literal">true</span>, <span class="attr">configurable</span>:<span class="literal">true</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，如果一个描述符同时有(get或set) 和 (value或writable)关键字，将会产生一个异常</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.prototype.propertyIsEnumerable()<br>返回一个布尔值，用来判断某个属性是否可遍历。注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回false。<br>如obj.propertyIsEnumerable(‘toString’) // false</p>
</li>
<li><p>对象的拷贝<br>有时，我们需要将一个对象的所有属性，拷贝到另一个对象，可以用下面的方法实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extend = <span class="function"><span class="keyword">function</span> (<span class="params">to, from</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> property <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">from</span>.hasOwnProperty(property)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(to, property, <span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="keyword">from</span>, property));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extend(&#123;&#125;, &#123; get a()&#123; <span class="keyword">return</span> <span class="number">1</span> &#125; &#125;)  <span class="comment">// &#123; get a()&#123; return 1 &#125; &#125;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>控制对象状态<br>有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，<br>最弱的一种是Object.preventExtensions，其次是Object.seal，最强的是Object.freeze。</p>
</li>
</ul>
<p>Object.preventExtensions() 无法再添加新的属性。 用 Object.isExtensible()检测<br>Object.seal() 禁止新增或删除旧属性，并不影响修改某个属性的值。实质是把属性描述对象的configurable属性设为false。 用 Object.isSealed()检测<br>Object.freeze() 无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。 用 Object.isFrozen()检测</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。一种解决方案是，把obj的原型也冻结住。</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proto = <span class="built_in">Object</span>.getPrototypeOf(obj);</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proto);</span><br><span class="line"></span><br><span class="line">proto.t = <span class="string">'hello'</span>;</span><br><span class="line">obj.t <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: [<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line"></span><br><span class="line">obj.bar.push(<span class="string">'c'</span>);</span><br><span class="line">obj.bar <span class="comment">// ["a", "b", "c"]   obj.bar属性指向一个数组，obj对象被冻结以后，这个指向无法改变，即无法指向其他值，但是所指向的数组是可以改变的。</span></span><br></pre></td></tr></table></figure>
<h4 id="Array-对象"><a href="#Array-对象" class="headerlink" title="Array 对象"></a>Array 对象</h4><p>Array是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。</p>
<h5 id="构造函数-new-Array"><a href="#构造函数-new-Array" class="headerlink" title="构造函数 new Array()"></a>构造函数 new Array()</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);   <span class="comment">// [ empty x 2 ] 生成一个两个成员的数组，每个位置都是空值</span></span><br><span class="line"><span class="comment">// 如果没有使用new，运行结果也是一样的。等同于</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。</span></span><br><span class="line"><span class="comment">// 无参数时，返回一个空数组</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="comment">// 单个正整数参数，表示返回的新数组的长度</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>) <span class="comment">// [ empty x 2 ]</span></span><br><span class="line"><span class="comment">// 非正整数的数值作为参数，会报错</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3.2</span>) <span class="comment">// RangeError: Invalid array length</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">-3</span>) <span class="comment">// RangeError: Invalid array length</span></span><br><span class="line"><span class="comment">// 单个非数值（比如字符串、布尔值、对象等）作为参数，则该参数是返回的新数组的成员</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'abc'</span>) <span class="comment">// ['abc']</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>([<span class="number">1</span>]) <span class="comment">// [Array[1]]</span></span><br><span class="line"><span class="comment">// 多参数时，所有参数都是返回的新数组的成员</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>) <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];  <span class="comment">// good</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回undefined，但实际上该位置没有任何值。虽然可以取到length属性，但是取不到键名。</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);  <span class="comment">// [empty × 2]</span></span><br><span class="line"><span class="keyword">var</span> b = [<span class="literal">undefined</span>, <span class="literal">undefined</span>];  <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure>
<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p>Array.isArray() 方法返回一个布尔值，表示参数是否为数组。它可以弥补 typeof 运算符的不足。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeof 运算符只能显示数组的类型是Object，而Array.isArray() 方法可以识别数组。</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">typeof</span> arr <span class="comment">// "object"</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h5 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h5><ul>
<li>valueOf() 方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的valueOf方法不尽一致，数组的valueOf方法返回数组本身。</li>
<li><p>toString() 方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.valueOf() <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.toString() <span class="comment">// "1,2,3"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line">arr.toString() <span class="comment">// "1,2,3,4,5,6"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>push() 方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p>
</li>
<li><p>pop() 方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// push和pop结合使用，就构成了 LIFO（Last-In-First-Out，后进先出）的栈结构（stack）。最新添加的项最早被移除。比如，箱子里的书，后放入的先取出。</span></span><br><span class="line">arr.push(<span class="string">'d'</span>) <span class="comment">// 4</span></span><br><span class="line">arr <span class="comment">// ["a", "b", "c", "d"]</span></span><br><span class="line"></span><br><span class="line">arr.pop() <span class="comment">// 'd'   </span></span><br><span class="line">arr  <span class="comment">// ["a", "b", "c"]   'd'是最后进入数组的，但是最早离开数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对空数组使用pop方法，不会报错，而是返回undefined。</span></span><br><span class="line">[].pop() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>shift()方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。</p>
</li>
<li><p>unshift()方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">arr.shift()  <span class="comment">// 'a'</span></span><br><span class="line">arr  <span class="comment">// ['b', 'c']</span></span><br><span class="line"></span><br><span class="line">arr.unshift(<span class="string">'x'</span>);  <span class="comment">// 3</span></span><br><span class="line">arr  <span class="comment">// ["x", "b", "c"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unshift()方法可以接受多个参数，这些参数都会添加到目标数组头部。</span></span><br><span class="line">arr.unshift(<span class="string">'1'</span>, <span class="string">'2'</span>)  <span class="comment">// 5</span></span><br><span class="line">arr  <span class="comment">// ["1", "2", "x", "b", "c"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// push和shift结合使用，就构成了 FIFO(Fist-In-First-Out,先进先出) 队列结构（queue）。即在数组的后端添加项，从数组的前端移除项。比如，火车站排队买票，先到的先买，买好的先走。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>join()方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">a.join() <span class="comment">// "1,2,3,4"</span></span><br><span class="line">a.join(<span class="string">' '</span>) <span class="comment">// '1 2 3 4'</span></span><br><span class="line">a.join(<span class="string">' | '</span>) <span class="comment">// "1 | 2 | 3 | 4"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果数组成员是undefined或null或空位，会被转成空字符串。</span></span><br><span class="line">[<span class="literal">undefined</span>, , <span class="literal">null</span>].join(<span class="string">'#'</span>)  <span class="comment">// '##'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过call方法，这个方法也可以用于字符串或类似数组的对象。</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(obj, <span class="string">'-'</span>)  <span class="comment">// "a-b"</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(<span class="string">'hello'</span>, <span class="string">'-'</span>)  <span class="comment">// "h-e-l-l-o"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>concat() 方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'hello'</span>].concat([<span class="string">'world'</span>], [<span class="string">'!'</span>])   <span class="comment">// ["hello", "world", "!"]</span></span><br><span class="line">[].concat(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;)  <span class="comment">// [&#123; a: 1 &#125;, &#123; b: 2 &#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了数组作为参数，concat也接受其他类型的值作为参数，添加到目标数组尾部。</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].concat(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)   <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用，改变原对象以后，新数组跟着改变。</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> oldArray = [obj];</span><br><span class="line"><span class="keyword">var</span> newArray = oldArray.concat();</span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line">newArray[<span class="number">0</span>].a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>reverse() 方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</p>
</li>
<li><p>slice() 方法用于提取目标数组的一部分，返回一个新数组，它是一个由 start和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它的第一个参数为起始位置（从0开始），第二个参数为终止位置（不含）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</span></span><br><span class="line">arr.slice(start,end)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果slice没有参数，实际上等于返回一个原数组的拷贝。</span></span><br><span class="line"><span class="comment">// 如果slice方法的参数是负数，则表示倒数计算的位置。</span></span><br><span class="line"><span class="comment">// 如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice方法的一个重要应用，是将类似数组的对象转为真正的数组。</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(&#123; <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;)  <span class="comment">// ['a', 'b']</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">document</span>.querySelectorAll(<span class="string">"div"</span>));</span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">arr.splice(index,howmany,item1,.....,itemX)</span><br><span class="line"><span class="comment">// index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</span></span><br><span class="line"><span class="comment">// howmany	必需。要删除的项目数量。如果设置为 0，则不会删除项目。</span></span><br><span class="line"><span class="comment">// item1, ..., itemX	可选。向数组添加的新项目。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面代码从原数组2号位置，删除了两个数组成员，还插入了两个新成员。</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">a.splice(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// ["c", "d"]</span></span><br><span class="line">a <span class="comment">// ["a", "b", 1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只是单纯地插入元素，splice方法的第二个参数可以设为0。</span></span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line">b.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>) <span class="comment">// []</span></span><br><span class="line">b <span class="comment">// [1, 2, 1, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</span></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">c.splice(<span class="number">2</span>) <span class="comment">// [3, 4]</span></span><br><span class="line">c <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>sort() 方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">arr.sort([compareFunction])</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字符串Unicode码点进行比较</span></span><br><span class="line">[<span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>].sort()  <span class="comment">// ['a', 'b', 'c', 'd']</span></span><br><span class="line">[<span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>].sort()  <span class="comment">// [7, 8, 9]</span></span><br><span class="line">[<span class="number">10111</span>, <span class="number">1101</span>, <span class="number">111</span>].sort()  <span class="comment">// [10111, 1101, 111]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果让sort方法按照自定义方式排序，可以传入一个函数作为参数。接受两个参数，表示进行比较的两个数组成员。</span></span><br><span class="line"><span class="comment">// 如果返回值小于 0 ，那么 a 会被排列到 b 之前；</span></span><br><span class="line"><span class="comment">// 如果返回值等于 0 ，那么  a 和 b 的相对位置不变；</span></span><br><span class="line"><span class="comment">// 如果返回值大于 0 ，那么 b 会被排列到 a 之前。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要比较数字而非字符串，比较函数可以简单的以 a和b相减。a-b升序，b-a降序。</span></span><br><span class="line">[<span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//a-b升序，b-a降序</span></span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [7, 8, 9]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>map() 方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回，原数组没有变化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> new_arr = array.map(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">map</span>方法接受一个函数作为参数，创建一个新数组。该函数调用时，<span class="title">map</span>方法向它传入三个参数：当前成员<span class="title">currentValue</span>、当前位置<span class="title">index</span>和数组本身<span class="title">arr</span>。 </span></span><br><span class="line"><span class="function">// 此外还可以接受第二个参数<span class="title">thisValue</span>用来绑定回调函数内部的<span class="title">this</span>。如果省略了 <span class="title">thisValue</span>，或者传入 <span class="title">null</span>、<span class="title">undefined</span>，那么回调函数的 <span class="title">this</span> 为全局对象。</span></span><br><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ele + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [2, 3, 4]</span></span><br><span class="line">arr  <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面代码通过map方法的第二个参数，将回调函数内部的this对象，指向arr数组。</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>[e];</span><br><span class="line">&#125;, arr2)</span><br><span class="line"><span class="comment">// ['b', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果数组有空位，map方法的回调函数在这个位置不会执行，会跳过数组的空位。map方法不会跳过undefined和null，但是会跳过空位。</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123; <span class="keyword">return</span> <span class="string">'a'</span> &#125;;</span><br><span class="line">[<span class="number">1</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,,<span class="number">2</span>].map(f) <span class="comment">// ["a", "a", "a", empty, "a"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>forEach() 方法 对数组的所有成员依次执行参数函数。和map很相似，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 但是，<span class="title">forEach</span>方法不像 <span class="title">map</span>(<span class="params"></span>) 或者 <span class="title">reduce</span>(<span class="params"></span>)，它总是返回<span class="title">undefined</span>值，只用来操作数据，并且不可链式调用(<span class="params">在一个链的最后执行副作用</span>)。这就是说，如果数组遍历的目的是为了得到返回值，那么使用<span class="title">map</span>方法，否则使用<span class="title">forEach</span>方法。</span></span><br><span class="line">['a', 'b', 'c'].forEach(function(ele) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ele);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a b c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach方法也可以接受第二个参数，绑定参数函数的this变量。注意，如果使用箭头函数，thisArg 参数会被忽略，因为箭头函数在词法上绑定了 this 值。</span></span><br><span class="line"><span class="comment">// forEach方法也不会跳过undefined和null，但是会跳过空位。</span></span><br><span class="line"><span class="keyword">var</span> out = [];</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, ,<span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.push(elem * elem);</span><br><span class="line">&#125;, out);</span><br><span class="line"></span><br><span class="line">out <span class="comment">// (5) [1, 4, 0, NaN, 9] 注意索引2被跳过了，因为在数组的这个位置是空位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，forEach方法无法中断执行或跳出循环，总是会将所有成员遍历完，除了抛出一个异常。若你需要提前终止循环，你可以使用for、for...of、every、some、find、findIndex，他们可以对数组元素判断，以便确定是否需要继续遍历。或者也可以使用 filter() 提前过滤出需要遍历的部分，再用 forEach() 处理。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>filter() 方法用于过滤数组成员，满足条件的成员组成一个新数组返回。如果没有通过测试则返回空数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> new_array = array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisArg</span>])</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 它的参数是一个函数，所有数组成员依次执行该函数，返回结果为<span class="title">true</span>的成员组成一个新数组返回。该方法不会改变原数组。</span></span><br><span class="line">[1, 2, 3, 4, 5].filter(function (ele) &#123;</span><br><span class="line">  <span class="keyword">return</span> (ele &gt; <span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].filter(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> index % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [1, 3, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter方法还可以接受第二个参数，用来绑定参数函数内部的this变量。</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">MAX</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> myFilter = <span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (item &gt; <span class="keyword">this</span>.MAX) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 过滤器myFilter内部有this变量，它可以被filter方法的第二个参数obj绑定</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>];</span><br><span class="line">arr.filter(myFilter, obj) <span class="comment">// [8, 4, 9]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>some()、every()<br>这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。被调用时不会改变数组。<br>它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。<br>some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。<br>every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">array.some(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisArg</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 示例</span></span><br><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">elem, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elem &gt;= <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数测试数组元素的值 更简洁</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>].some(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">10</span>);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断数组元素中是否存在某个值</span></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'mango'</span>, <span class="string">'guava'</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAvailability</span>(<span class="params">arr, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">arrVal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val === arrVal;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkAvailability(fruits, <span class="string">'banana'</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEven</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x % <span class="number">2</span> === <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">[].some(isEven) <span class="comment">// false</span></span><br><span class="line">[].every(isEven) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>reduce()、reduceRight() 依次处理数组的每个成员，最终累计为一个值。<br>它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reduce为数组中的每一个元素依次执行callback函数，不包括数组中被删除或从未被赋值的元素，对于空数组是不会执行回调函数的。接受四个参数：</span></span><br><span class="line">array.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, currentIndex, arr</span>), <span class="title">initialValue</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 求数组里所有值的和</span></span><br><span class="line">var sum = [1, 2, 3, 4, 5].reduce(function (acc, cur) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(acc, cur);</span><br><span class="line">  <span class="keyword">return</span> acc + cur;</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 1 2</span></span><br><span class="line"><span class="comment">// 3 3</span></span><br><span class="line"><span class="comment">// 6 4</span></span><br><span class="line"><span class="comment">// 10 5</span></span><br><span class="line"><span class="comment">// 15  最后结果</span></span><br><span class="line"><span class="comment">// 可以写成箭头函数的形式</span></span><br><span class="line"><span class="keyword">var</span> total = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ].reduce(<span class="function">(<span class="params"> acc, cur </span>) =&gt;</span> acc + cur, <span class="number">0</span>);  <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。</span></span><br><span class="line"><span class="comment">// 如果数组为空且没有提供initialValue，会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。</span></span><br><span class="line"><span class="comment">// 因此，提供初始值通常更安全。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是一个reduceRight方法的例子。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prev - cur;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].reduce(subtract)       <span class="comment">// 0    reduce方法相当于3减去2再减去1</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].reduceRight(subtract)  <span class="comment">// -4   reduceRight方法相当于1减去2再减去3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于这两个方法会遍历数组，所以实际上还可以用来做一些遍历相关的操作。比如，找出字符长度最长的数组成员。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLongest</span>(<span class="params">entries</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> entries.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">longest, entry</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> entry.length &gt; longest.length ? entry : longest;</span><br><span class="line">  &#125;, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line">findLongest([<span class="string">'aaa'</span>, <span class="string">'bb'</span>, <span class="string">'c'</span>]) <span class="comment">// "aaa"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将二维数组转化为一维</span></span><br><span class="line"><span class="keyword">var</span> flattened = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.concat(b);</span><br><span class="line">&#125;,[]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> result = arr.sort().reduce(<span class="function">(<span class="params">init, current</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(init.length===<span class="number">0</span> || init[init.length<span class="number">-1</span>]!==current)&#123;</span><br><span class="line">        init.push(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;, []);</span><br><span class="line">result <span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算数组中每个元素出现的次数</span></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">'Alice'</span>, <span class="string">'Bob'</span>, <span class="string">'Tiff'</span>, <span class="string">'Bruce'</span>, <span class="string">'Alice'</span>];</span><br><span class="line"><span class="keyword">var</span> countedNames = names.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">allNames, name</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (name <span class="keyword">in</span> allNames) &#123;</span><br><span class="line">    allNames[name]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    allNames[name] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> allNames;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line">countedNames  <span class="comment">// &#123; 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>indexOf()，lastIndexOf()<br>indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">a.indexOf(<span class="string">'b'</span>) <span class="comment">// 1</span></span><br><span class="line">a.indexOf(<span class="string">'y'</span>) <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// indexOf方法还可以接受第二个参数，表示搜索的开始位置。</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].indexOf(<span class="string">'a'</span>, <span class="number">1</span>) <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>];</span><br><span class="line">a.lastIndexOf(<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line">a.lastIndexOf(<span class="number">7</span>) <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，这两个方法不能用来搜索NaN的位置，即它们无法确定数组成员是否包含NaN。这是因为这两个方法内部，使用严格相等运算符（===）进行比较，而NaN是唯一一个不等于自身的值。</span></span><br><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></span><br><span class="line">[<span class="literal">NaN</span>].lastIndexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>链式使用<br>上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'tom'</span>, <span class="attr">email</span>: <span class="string">'tom@example.com'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'peter'</span>, <span class="attr">email</span>: <span class="string">'peter@example.com'</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">users</span><br><span class="line">  .map(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user.email;</span><br><span class="line">  &#125;)</span><br><span class="line">  .filter(<span class="function"><span class="keyword">function</span> (<span class="params">email</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^t/</span>.test(email);</span><br><span class="line">  &#125;)</span><br><span class="line">  .forEach(<span class="function"><span class="keyword">function</span> (<span class="params">email</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(email);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// "tom@example.com"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h4><p>对象是 JavaScript 语言最主要的数据类型，三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。</p>
<ul>
<li><p>包装对象<br>所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码中，基于原始类型的值，生成了三个对应的包装对象。</span></span><br><span class="line"><span class="keyword">var</span> v1 = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);    <span class="comment">// Number &#123;123&#125;</span></span><br><span class="line"><span class="keyword">var</span> v2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abc'</span>);  <span class="comment">// String &#123;"abc"&#125;</span></span><br><span class="line"><span class="keyword">var</span> v3 = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);  <span class="comment">// Boolean &#123;true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> v1 <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> v2 <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> v3 <span class="comment">// "object"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装对象的最大目的，首先是使得 JavaScript 的对象涵盖所有的值，其次使得原始类型的值可以方便地调用某些方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number、String和Boolean如果不作为构造函数调用（即调用时不加new），常常用于将任意类型的值转为数值、字符串和布尔值。</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">123</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">String</span>(<span class="string">'abc'</span>) <span class="comment">// "abc"</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">true</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 总结一下，这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可将任意类型的值，转为原始类型的值。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实例方法<br>三种包装对象各自提供了许多实例方法。这里介绍两种它们共同具有、从Object对象继承的方法：valueOf和toString。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// valueOf方法返回包装对象实例对应的原始类型的值。</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>).valueOf()  <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abc'</span>).valueOf() <span class="comment">// "abc"</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>).valueOf() <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toString方法返回对应的字符串形式。</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>).valueOf()  <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abc'</span>).valueOf() <span class="comment">// "abc"</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>).valueOf() <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于一些特殊值，如null、undefined、false， Boolean对象前面加不加new，会得到完全相反的结果，必须小心。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Boolean</span>(<span class="literal">false</span>)) &#123;   <span class="comment">// false</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'true'</span>);  <span class="comment">// 无输出</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)) &#123;  <span class="comment">// Boolean &#123;false&#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'true'</span>);    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原始类型与实例对象的自动转换<br>原始类型的值，可以自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，在使用后立刻销毁实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如，字符串可以调用length属性，返回字符串的长度。</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abc'</span>;</span><br><span class="line">str.length <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> strObj = <span class="keyword">new</span> <span class="built_in">String</span>(str)</span><br><span class="line">strObj.length <span class="comment">// 3</span></span><br><span class="line">strObj <span class="comment">// String &#123;0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"&#125;</span></span><br><span class="line"><span class="comment">// abc是一个字符串，本身不是对象，不能调用length属性。JavaScript 引擎自动将其转为包装对象，在这个对象上调用length属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello World'</span>;</span><br><span class="line">s.x = <span class="number">123</span>;</span><br><span class="line">s.x <span class="comment">// undefined  为字符串s添加了一个x属性，结果无效，总是返回undefined。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一方面，调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象String.prototype上定义。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义方法<br>除了原生的实例方法，包装对象还可以自定义方法和属性，供原始类型的值直接调用。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如，我们可以新增一个double方法，使得字符串和数字翻倍。</span></span><br><span class="line"><span class="built_in">String</span>.prototype.double = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.valueOf() + <span class="keyword">this</span>.valueOf();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="string">'abc'</span>.double()  <span class="comment">// abcabc</span></span><br><span class="line"><span class="comment">// 但是，这种自定义方法和属性的机制，只能定义在包装对象的原型上，如果直接对原始类型的变量添加属性，则无效。</span></span><br></pre></td></tr></table></figure>
<h4 id="Number-对象"><a href="#Number-对象" class="headerlink" title="Number 对象"></a>Number 对象</h4><p>Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。</p>
<ul>
<li><p>包装对象 和 工具函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为构造函数时，它用于生成值为数值的对象。</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>);  <span class="comment">// Number &#123;1&#125;</span></span><br><span class="line"><span class="comment">// 作为工具函数时，它可以将任何类型的值转为数值。</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>静态属性<br>Number对象拥有以下一些静态属性（即直接定义在Number对象上的属性，而不是定义在实例上的属性）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.POSITIVE_INFINITY：正的无限，指向<span class="literal">Infinity</span>。</span><br><span class="line"><span class="built_in">Number</span>.NEGATIVE_INFINITY：负的无限，指向-<span class="literal">Infinity</span>。</span><br><span class="line"><span class="built_in">Number</span>.NaN：表示非数值，指向<span class="literal">NaN</span>。</span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE：表示最小的正数（即最接近<span class="number">0</span>的正数，在<span class="number">64</span>位浮点数体系中为<span class="number">5e-324</span>），相应的，最接近<span class="number">0</span>的负数为-<span class="built_in">Number</span>.MIN_VALUE。</span><br><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即<span class="number">9007199254740991</span>。</span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即<span class="number">-9007199254740991</span>。</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例方法<br>Number对象有4个实例方法，都跟将数值转换成指定格式有关。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.toString()  将一个数值转为字符串形式。</span><br><span class="line"><span class="comment">// toString方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串。</span></span><br><span class="line"><span class="comment">// toString方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用parseInt方法。</span></span><br><span class="line">(<span class="number">10</span>).toString() <span class="comment">// "10"</span></span><br><span class="line">(<span class="number">10</span>).toString(<span class="number">2</span>) <span class="comment">// "1010"</span></span><br><span class="line">(<span class="number">10</span>).toString(<span class="number">8</span>) <span class="comment">// "12"</span></span><br><span class="line">(<span class="number">10</span>).toString(<span class="number">16</span>) <span class="comment">// "a"</span></span><br><span class="line"><span class="comment">// 通过方括号运算符也可以调用toString方法。</span></span><br><span class="line"><span class="number">10</span>[<span class="string">'toString'</span>](<span class="number">2</span>) <span class="comment">// "1010"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.prototype.toFixed()  将一个数转为指定位数的小数，然后返回这个小数对应的字符串</span><br><span class="line"><span class="comment">// 参数为小数位数，有效范围为0到20，超出这个范围将抛出 RangeError 错误</span></span><br><span class="line">(<span class="number">10</span>).toFixed(<span class="number">2</span>) <span class="comment">// "10.00"</span></span><br><span class="line"><span class="number">10.005</span>.toFixed(<span class="number">2</span>) <span class="comment">// "10.01"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.prototype.toExponential()  将一个数转为科学计数法形式</span><br><span class="line"><span class="comment">// 参数是小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个 RangeError 错误</span></span><br><span class="line">(<span class="number">10</span>).toExponential()  <span class="comment">// "1e+1"</span></span><br><span class="line">(<span class="number">10</span>).toExponential(<span class="number">1</span>) <span class="comment">// "1.0e+1"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.prototype.toPrecision()  将一个数转为指定位数的有效数字</span><br><span class="line"><span class="comment">// 参数为有效数字的位数，范围是1到21，超出这个范围会抛出 RangeError 错误</span></span><br><span class="line">(<span class="number">12.34</span>).toPrecision(<span class="number">1</span>) <span class="comment">// "1e+1"</span></span><br><span class="line">(<span class="number">12.34</span>).toPrecision(<span class="number">2</span>) <span class="comment">// "12"</span></span><br><span class="line">(<span class="number">12.34</span>).toPrecision(<span class="number">3</span>) <span class="comment">// "12.3"</span></span><br><span class="line"><span class="comment">// toPrecision方法用于四舍五入时不太可靠，跟浮点数不是精确储存有关。</span></span><br><span class="line">(<span class="number">12.15</span>).toPrecision(<span class="number">3</span>) <span class="comment">// "12.2"</span></span><br><span class="line">(<span class="number">12.45</span>).toPrecision(<span class="number">3</span>) <span class="comment">// "12.4"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义方法<br>与其他对象一样，Number.prototype对象上面可以自定义方法，被Number的实例继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于add方法返回的还是数值，所以可以链式运算</span></span><br><span class="line"><span class="built_in">Number</span>.prototype.subtract = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span> - x;</span><br><span class="line">&#125;;</span><br><span class="line">(<span class="number">8</span>).add(<span class="number">2</span>).subtract(<span class="number">4</span>)  <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，数值的自定义方法，只能定义在它的原型对象Number.prototype上面，数值本身是无法自定义属性的。</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line">n.x = <span class="number">1</span>;</span><br><span class="line">n.x <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 上面代码中，n是一个原始类型的数值。直接在它上面新增一个属性x，不会报错，但毫无作用，总是返回undefined。这是因为一旦被调用属性，n就自动转为Number的实例对象，调用结束后，该对象自动销毁。所以，下一次调用n的属性时，实际取到的是另一个对象，属性x当然就读不出来。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h4><p>String对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abc'</span>);   <span class="comment">// String &#123;"abc"&#125;</span></span><br><span class="line"><span class="keyword">typeof</span> s1 <span class="comment">// "string"</span></span><br><span class="line"><span class="keyword">typeof</span> s2 <span class="comment">// "object"</span></span><br><span class="line">s2.valueOf() <span class="comment">// "abc"   返回的就是它所对应的原始字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串对象是一个类似数组的对象（很像数组，但不是数组）。有数值键（0、1、2）和length属性，所以可以像数组那样取值。</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abc'</span>)  <span class="comment">// String &#123;0: "a", 1: "b", 2: "c", length: 3&#125;</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abc'</span>))[<span class="number">1</span>] <span class="comment">// "b"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了用作构造函数，String对象还可以当作工具方法使用，将任意类型的值转为字符串。</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">true</span>) <span class="comment">// "true"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">5</span>) <span class="comment">// "5"</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>静态方法 (即定义在对象本身，而不是定义在对象实例的方法）<br>String.fromCharCode()  该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode()   <span class="comment">// ""    参数为空，就返回空字符串</span></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">97</span>) <span class="comment">// "a"   否则，返回参数对应的 Unicode 字符串。</span></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>)  <span class="comment">// "hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，该方法不支持 Unicode 码点大于0xFFFF的字符，即传入的参数不能大于0xFFFF（即十进制的 65535）。因码点大于0xFFFF的字符占用四个字节，而 JavaScript 默认支持两个字节的字符。这种情况下，必须拆成两个字符表示。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实例属性<br>String.prototype.length  字符串实例的length属性返回字符串的长度。 如’abc’.length // 3</p>
</li>
<li><p>实例方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">str.charAt()  返回指定位置的字符，参数是从<span class="number">0</span>开始编号的位置</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'abc'</span>);</span><br><span class="line">s.charAt(<span class="number">1</span>) <span class="comment">// "b"</span></span><br><span class="line"><span class="comment">// 这个方法完全可以用数组下标替代。</span></span><br><span class="line"><span class="string">'abc'</span>[<span class="number">1</span>] <span class="comment">// "b"</span></span><br><span class="line"><span class="comment">// 如果参数为负数，或大于等于字符串的长度，charAt返回空字符串。</span></span><br><span class="line"><span class="string">'abc'</span>.charAt(<span class="number">-1</span>) <span class="comment">// ""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str.charCodeAt()  方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于<span class="built_in">String</span>.fromCharCode()的逆操作</span><br><span class="line"><span class="string">'abc'</span>.charCodeAt(<span class="number">1</span>) <span class="comment">// 98</span></span><br><span class="line"><span class="comment">// 如果没有任何参数，charCodeAt返回首字符的 Unicode 码点。如果参数为负数，或大于等于字符串的长度，charCodeAt返回NaN。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str.concat()  用于连接两个字符串，返回一个新字符串，不改变原字符串。</span><br><span class="line">可以接受多个参数。如果参数不是字符串，concat方法会将其先转为字符串，然后再连接。</span><br><span class="line"><span class="string">'a'</span>.concat(<span class="string">'b'</span>, <span class="string">'c'</span>) <span class="comment">// "abc"</span></span><br><span class="line"><span class="comment">// 作为对比，加号运算符在两个运算数都是数值时，不会转换类型</span></span><br><span class="line"><span class="string">''</span>.concat(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// "123"</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>  <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str.slice(start,end)  从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含）</span><br><span class="line"><span class="string">'JavaScript'</span>.slice(<span class="number">0</span>, <span class="number">4</span>) <span class="comment">// "Java"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str.substring(start,stop)从原字符串取出子字符串并返回，不改变原字符串。第一个参数表示子字符串的开始位置，第二个位置表示结束位置（不含）。不建议使用。</span><br><span class="line"><span class="string">'JavaScript'</span>.substring(<span class="number">0</span>, <span class="number">4</span>) <span class="comment">// "Java"</span></span><br><span class="line"><span class="comment">// 如果第一个参数大于第二个参数，substring方法会自动更换两个参数的位置。 如果参数是负数，substring方法会自动将负数转为0。</span></span><br><span class="line"><span class="string">'JavaScript'</span>.substring(<span class="number">4</span>, <span class="number">-3</span>) <span class="comment">// "Java"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str.substr(start,length)  从原字符串取出子字符串并返回，不改变原字符串，跟slice和substring方法的作用相同。第一个参数是子字符串的开始位置（从<span class="number">0</span>开始），第二个参数是子字符串的长度。如果省略第二个参数，则表示子字符串一直到原字符串的结束。</span><br><span class="line"><span class="string">'JavaScript'</span>.substr(<span class="number">4</span>, <span class="number">6</span>) <span class="comment">// "Script"</span></span><br><span class="line"><span class="comment">// 如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。</span></span><br><span class="line"><span class="string">'JavaScript'</span>.substr(<span class="number">-6</span>) <span class="comment">// "Script"</span></span><br><span class="line"><span class="string">'JavaScript'</span>.substr(<span class="number">4</span>, <span class="number">-1</span>) <span class="comment">// ""</span></span><br><span class="line"></span><br><span class="line">str.indexOf() indexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回<span class="number">-1</span>，就表示不匹配。indexOf方法还可以接受第二个参数，表示从该位置开始向后匹配。</span><br><span class="line"></span><br><span class="line">str.lastIndexOf()  lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。第二个参数表示从该位置起向前匹配。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str.trim()  trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</span><br><span class="line"><span class="comment">// 该方法去除的不仅是空格，还包括制表符（\t、\v）、换行符（\n）和回车符（\r）。</span></span><br><span class="line"><span class="string">'  hello world  '</span>.trim()   <span class="comment">// "hello world"</span></span><br><span class="line"><span class="string">'\r\nabc \t'</span>.trim() <span class="comment">// 'abc'</span></span><br><span class="line"></span><br><span class="line">str.toLowerCase()  将一个字符串全部转为小写。返回一个新字符串，不改变原字符串</span><br><span class="line"></span><br><span class="line">str.toUpperCase()  将一个字符串全部转为大写。返回一个新字符串，不改变原字符串</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str.match(regexp)  用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回<span class="literal">null</span>。</span><br><span class="line"><span class="string">'cat, bat, sat, fat'</span>.match(<span class="string">'at'</span>) <span class="comment">// ["at"]</span></span><br><span class="line"><span class="string">'cat, bat, sat, fat'</span>.match(<span class="string">'xt'</span>) <span class="comment">// null</span></span><br><span class="line"><span class="comment">// 返回的数组还有index属性和input属性，分别表示匹配字符串开始的位置和原始字符串。</span></span><br><span class="line"><span class="keyword">var</span> matches = <span class="string">'cat, bat, sat, fat'</span>.match(<span class="string">'at'</span>);</span><br><span class="line">matches.index <span class="comment">// 1</span></span><br><span class="line">matches.input <span class="comment">// "cat, bat, sat, fat"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str.search(regexp)  用法基本等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回<span class="number">-1</span>。</span><br><span class="line"><span class="string">'cat, bat, sat, fat'</span>.search(<span class="string">'at'</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str.replace(regexp, replacement)  用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）</span><br><span class="line"><span class="string">'aaa'</span>.replace(<span class="string">'a'</span>, <span class="string">'b'</span>) <span class="comment">// "baa"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str.split(separator, limit)  用指定的分隔符分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置</span><br><span class="line"><span class="string">'a|b|c'</span>.split(<span class="string">'|'</span>) <span class="comment">// ["a", "b", "c"]</span></span><br><span class="line"><span class="comment">// 如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。与 Array.join() 执行的操作相反。</span></span><br><span class="line"><span class="string">'a|b|c'</span>.split(<span class="string">''</span>) <span class="comment">// ["a", "|", "b", "|", "c"]   </span></span><br><span class="line"><span class="comment">// 如果省略参数，则返回数组的唯一成员就是原字符串。</span></span><br><span class="line"><span class="string">'a|b|c'</span>.split() <span class="comment">// ["a|b|c"]</span></span><br><span class="line"><span class="comment">// 如果满足分割规则的两个部分紧邻着（即两个分割符中间没有其他字符），则返回数组之中会有一个空字符串。</span></span><br><span class="line"><span class="string">'a||c'</span>.split(<span class="string">'|'</span>) <span class="comment">// ['a', '', 'c']</span></span><br><span class="line"><span class="comment">// split方法还可以接受第二个参数，限定返回数组的最大成员数。</span></span><br><span class="line"><span class="string">'a|b|c'</span>.split(<span class="string">'|'</span>, <span class="number">2</span>) <span class="comment">// ["a", "b"]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h4><p>Math是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。</p>
<ul>
<li><p>静态属性<br>Math对象的静态属性，提供以下一些数学常数。这些属性都是只读的，不能修改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.E：常数e。  <span class="comment">// 2.718281828459045</span></span><br><span class="line"><span class="built_in">Math</span>.LN2：<span class="number">2</span> 的自然对数。 <span class="comment">// 0.6931471805599453</span></span><br><span class="line"><span class="built_in">Math</span>.LN10：<span class="number">10</span> 的自然对数。 <span class="comment">// 2.302585092994046</span></span><br><span class="line"><span class="built_in">Math</span>.LOG2E：以 <span class="number">2</span> 为底的e的对数。 <span class="comment">// 1.4426950408889634</span></span><br><span class="line"><span class="built_in">Math</span>.LOG10E：以 <span class="number">10</span> 为底的e的对数。 <span class="comment">// 0.4342944819032518</span></span><br><span class="line"><span class="built_in">Math</span>.PI：常数π。 <span class="comment">// 3.141592653589793</span></span><br><span class="line"><span class="built_in">Math</span>.SQRT1_2：<span class="number">0.5</span> 的平方根。 <span class="comment">// 0.7071067811865476</span></span><br><span class="line"><span class="built_in">Math</span>.SQRT2：<span class="number">2</span> 的平方根。 <span class="comment">// 1.4142135623730951</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>静态方法<br>Math对象提供以下一些静态方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs()：绝对值</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.ceil()：向上取整，大于参数值的最小整数（天花板值）</span><br><span class="line"><span class="built_in">Math</span>.floor()：向下取整，小于参数值的最大整数（地板值）</span><br><span class="line"><span class="comment">// 实现一个总是返回数值的整数部分的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ToInteger</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x = <span class="built_in">Number</span>(x);</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(x) : <span class="built_in">Math</span>.floor(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.max()：最大值  <span class="comment">// 如果参数为空, 返回-Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.min()：最小值  <span class="comment">// 如果参数为空, 返回Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow()：指数运算。以第一个参数为底数、第二个参数为幂的指数值</span><br><span class="line"><span class="comment">// Math.pow(2, 3) // 8  等同于 2 ** 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.sqrt()：平方根。如果参数是一个负值，则返回<span class="literal">NaN</span></span><br><span class="line"><span class="built_in">Math</span>.log()：自然对数</span><br><span class="line"><span class="built_in">Math</span>.exp()：e的指数。返回常数e的参数次方</span><br><span class="line"><span class="built_in">Math</span>.round()：四舍五入。</span><br><span class="line"><span class="comment">// 注意，它对负数的处理（主要是对0.5的处理）。</span></span><br><span class="line"><span class="comment">// Math.round(-1.1) // -1</span></span><br><span class="line"><span class="comment">// Math.round(-1.5) // -1</span></span><br><span class="line"><span class="comment">// Math.round(-1.6) // -2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.random()：伪随机数，[<span class="number">0</span>, <span class="number">1</span>)之间</span><br><span class="line"><span class="comment">// 任意范围的随机数生成函数如下。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomArbitrary</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() * (max - min) + min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任意范围的随机整数生成函数如下。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomInt</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>三角函数方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sin()：返回参数的正弦（参数为弧度值）</span><br><span class="line"><span class="built_in">Math</span>.cos()：返回参数的余弦（参数为弧度值）</span><br><span class="line"><span class="built_in">Math</span>.tan()：返回参数的正切（参数为弧度值）</span><br><span class="line"><span class="built_in">Math</span>.asin()：返回参数的反正弦（返回值为弧度值）</span><br><span class="line"><span class="built_in">Math</span>.acos()：返回参数的反余弦（返回值为弧度值）</span><br><span class="line"><span class="built_in">Math</span>.atan()：返回参数的反正切（返回值为弧度值</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Date-对象"><a href="#Date-对象" class="headerlink" title="Date 对象"></a>Date 对象</h4><p>Date对象是 JavaScript 原生的时间库。它以国际标准时间（UTC）1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）。</p>
<ul>
<li><p>普通函数的用法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，即使带有参数，Date作为普通函数使用时，返回的还是当前时间。</span></span><br><span class="line"><span class="built_in">Date</span>()  <span class="comment">// "Mon Mar 04 2019 23:24:09 GMT+0800 (China Standard Time)"</span></span><br><span class="line"><span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">3</span>, <span class="number">4</span>)   <span class="comment">// 返回结果一样，参数不生效</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数的用法<br>Date还可以当作构造函数使用。对它使用new命令，会返回一个Date对象的实例。如果不加参数，实例代表的就是当前时间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Date实例有一个独特的地方。其他对象求值的时候，都是默认调用.valueOf()方法，但是Date实例求值的时候，默认调用的是toString()方法。</span></span><br><span class="line"><span class="comment">// 这导致对Date实例求值，返回的是一个字符串，代表该实例对应的时间。</span></span><br><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">today <span class="comment">// Mon Mar 04 2019 23:27:51 GMT+0800 (China Standard Time)</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">today.toString() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为构造函数时，Date对象可以接受多种格式的参数，返回一个该参数对应的时间实例。</span></span><br><span class="line"><span class="comment">// 参数为时间零点开始计算的毫秒数</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1551713492442</span>)  <span class="comment">// Mon Mar 04 2019 23:31:32 GMT+0800 (China Standard Time)</span></span><br><span class="line"><span class="comment">// 参数为日期字符串</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'Mar 4, 2019'</span>);</span><br><span class="line"><span class="comment">// 参数为多个整数。 代表年、月、日、小时、分钟、秒、毫秒</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 参数可以是负数，表示从基准日扣去相应的时间。</span></span><br><span class="line"><span class="comment">// 只要是能被Date.parse()方法解析的字符串，都可以当作参数。</span></span><br><span class="line"><span class="comment">// 参数为年、月、日等多个整数时，年和月是不能省略的，其他参数都可以省略的。因为如果只使用“年”这一个参数，Date会将其解释为毫秒数。</span></span><br><span class="line"><span class="comment">// 各个参数的取值范围如下，</span></span><br><span class="line"><span class="comment">// 年：使用四位数年份，比如2000。如果写成两位数或个位数，则加上1900，即10代表1910年。如果是负数，表示公元前。</span></span><br><span class="line"><span class="comment">// 月：0表示一月，依次类推，11表示12月。</span></span><br><span class="line"><span class="comment">// 日：1到31。</span></span><br><span class="line"><span class="comment">// 小时：0到23。</span></span><br><span class="line"><span class="comment">// 分钟：0到59。</span></span><br><span class="line"><span class="comment">// 秒：0到59</span></span><br><span class="line"><span class="comment">// 毫秒：0到999</span></span><br><span class="line"><span class="comment">// 注意，月份从0开始计算，但是，天数从1开始计算。另外，除了日期的默认值为1，小时、分钟、秒钟和毫秒的默认值都是0。</span></span><br><span class="line"><span class="comment">// 这些参数如果超出了正常范围，会被自动折算。比如，日期设为0，就代表上个月的最后一天；如果月设为15，就折算为下一年的4月。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>日期的运算<br>类型自动转换时，Date实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 表示2019.3.4</span></span><br><span class="line"><span class="keyword">var</span> d2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 表示2019.3.5</span></span><br><span class="line">d2 - d1  <span class="comment">// 86400000</span></span><br><span class="line">d2 + d1  <span class="comment">// "Tue Mar 05 2019 00:00:00 GMT+0800 (China Standard Time)Mon Mar 04 2019 00:00:00 GMT+0800 (China Standard Time)"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>静态方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>.now() 方法返回当前时间距离时间零点（<span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> UTC）的毫秒数，相当于 Unix 时间戳乘以<span class="number">1000</span>。</span><br><span class="line"><span class="built_in">Date</span>.now() <span class="comment">// 1551747545162</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>.parse() 方法用来解析日期字符串，返回该时间距离时间零点（<span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>）的毫秒数。</span><br><span class="line"><span class="comment">// 日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即YYYY-MM-DDTHH:mm:ss.sssZ格式，其中最后的Z表示时区。但是，其他格式也可以被解析</span></span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">'2019-03-05T09:41:00'</span>)  <span class="comment">// 1551750060000</span></span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">'Mon, 05 Mar 2019 09:41:00 GMT'</span>)</span><br><span class="line"><span class="comment">// 如果解析失败，返回NaN。</span></span><br><span class="line"><span class="built_in">Date</span>.parse(<span class="string">'xxx'</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>.UTC() 方法接受年、月、日等变量作为参数，返回该时间距离时间零点（<span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> UTC）的毫秒数。</span><br><span class="line"><span class="comment">// 该方法的参数用法与Date构造函数完全一致，比如月从0开始计算，日期从1开始计算。</span></span><br><span class="line"><span class="comment">// 区别在于Date.UTC方法的参数，会被解释为 UTC 时间（世界标准时间），Date构造函数的参数会被解释为当前时区的时间。</span></span><br><span class="line"><span class="comment">// 格式</span></span><br><span class="line"><span class="built_in">Date</span>.UTC(year, month[, date[, hrs[, min[, sec[, ms]]]]])</span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="built_in">Date</span>.UTC(<span class="number">2019</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">45</span>, <span class="number">0</span>, <span class="number">567</span>)  <span class="comment">// 1551779100567</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实例方法<br>Date的实例对象，有几十个自己的方法，除了valueOf和toString，可以分为以下三类。<br>to类：从Date对象返回一个字符串，表示指定的时间。<br>get类：获取Date对象的日期和时间。<br>set类：设置Date对象的日期和时间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">valueOf() 方法返回实例对象距离时间零点（<span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> UTC）对应的毫秒数，该方法等同于getTime方法。</span><br><span class="line"><span class="comment">// 预期为数值的场合，Date实例会自动调用该方法</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d.valueOf() <span class="comment">// 1551750690389</span></span><br><span class="line">d.getTime() <span class="comment">// 1551750690389</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">toString() 方法返回一个完整的日期字符串。</span><br><span class="line"><span class="comment">// 因为toString是默认的调用方法，所以如果直接读取Date实例，就相当于调用这个方法。</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">d.toString()  <span class="comment">// "Tue Mar 05 2019 00:00:00 GMT+0800 (China Standard Time)"</span></span><br><span class="line"></span><br><span class="line">toUTCString() 方法返回对应的 UTC 时间，也就是比北京时间晚<span class="number">8</span>个小时。</span><br><span class="line"></span><br><span class="line">toISOString() 方法返回对应时间的 ISO8601 写法。UTC 时区的时间。</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">2</span>, <span class="number">5</span>).toISOString()  <span class="comment">// "2019-03-05T02:02:36.471Z"</span></span><br><span class="line"></span><br><span class="line">toJSON()  返回一个符合 <span class="built_in">JSON</span> 格式的 ISO 日期字符串，与toISOString方法的返回结果完全相同</span><br><span class="line"></span><br><span class="line">toDateString()  方法返回日期字符串（不含小时、分和秒）</span><br><span class="line">toTimeString() 方法返回时间字符串（不含年月日）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">toLocaleString([locales[, options]])  完整的本地时间。 locales是一个指定所用语言的字符串，options是一个配置对象</span><br><span class="line">toLocaleDateString()：本地日期（不含小时、分和秒）</span><br><span class="line">toLocaleTimeString()：本地时间（不含年月日）</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString(<span class="string">'en-US'</span>, &#123;</span><br><span class="line">  hour12: <span class="literal">false</span>    <span class="comment">// "10:12:57"</span></span><br><span class="line">&#125;)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这些get*方法返回的都是当前时区的时间，Date对象还提供了这些方法对应的 UTC 版本，用来返回 UTC 时间。 如getUTCDate()</span></span><br><span class="line">getTime()：返回实例距离<span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>的毫秒数，等同于valueOf方法。</span><br><span class="line">getDate()：返回实例对象对应每个月的几号（从<span class="number">1</span>开始）。</span><br><span class="line">getDay()：返回星期几，星期日为<span class="number">0</span>，星期一为<span class="number">1</span>，以此类推。</span><br><span class="line">getFullYear()：返回四位的年份。</span><br><span class="line">getMonth()：返回月份（<span class="number">0</span>表示<span class="number">1</span>月，<span class="number">11</span>表示<span class="number">12</span>月）。</span><br><span class="line">getHours()：返回小时（<span class="number">0</span><span class="number">-23</span>）。</span><br><span class="line">getMilliseconds()：返回毫秒（<span class="number">0</span><span class="number">-999</span>）。</span><br><span class="line">getMinutes()：返回分钟（<span class="number">0</span><span class="number">-59</span>）。</span><br><span class="line">getSeconds()：返回秒（<span class="number">0</span><span class="number">-59</span>）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些方法基本是跟get*方法一一对应的，但是没有setDay方法，因为星期几是计算出来的，而不是设置的。另外，需要注意的是，凡是涉及到设置月份，都是从0开始算的，即0是1月，11是12月。</span></span><br><span class="line"><span class="comment">// set*方法的参数都会自动折算。以setDate为例，如果参数超过当月的最大天数，则向下一个月顺延，如果参数是负数，表示从上个月的最后一天开始减去的天数。</span></span><br><span class="line"><span class="comment">// set*系列方法除了setTime()，都有对应的 UTC 版本，即设置 UTC 时区的时间。</span></span><br><span class="line">setDate(date)：设置实例对象对应的每个月的几号（<span class="number">1</span><span class="number">-31</span>），返回改变后毫秒时间戳。</span><br><span class="line">setFullYear(year [, month, date])：设置四位年份。</span><br><span class="line">setHours(hour [, min, sec, ms])：设置小时（<span class="number">0</span><span class="number">-23</span>）。</span><br><span class="line">setMilliseconds()：设置毫秒（<span class="number">0</span><span class="number">-999</span>）。</span><br><span class="line">setMinutes(min [, sec, ms])：设置分钟（<span class="number">0</span><span class="number">-59</span>）。</span><br><span class="line">setMonth(month [, date])：设置月份（<span class="number">0</span><span class="number">-11</span>）。</span><br><span class="line">setSeconds(sec [, ms])：设置秒（<span class="number">0</span><span class="number">-59</span>）。</span><br><span class="line">setTime(milliseconds)：设置毫秒时间戳</span><br><span class="line"></span><br><span class="line"><span class="comment">// set类方法和get类方法，可以结合使用，得到相对时间。</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// 将日期向后推10天</span></span><br><span class="line">d.setDate(d.getDate() + <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="RegExp-对象"><a href="#RegExp-对象" class="headerlink" title="RegExp 对象"></a>RegExp 对象</h4><p>RegExp对象提供正则表示式的功能。JavaScript 的正则表达式体系是参照 Perl 5 建立的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建正则表达式有两种方法。</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>; <span class="comment">// 字面量，以斜杠表示开始和结束。在引擎编译代码时，就会新建正则表达式。效率较高，比较便利和直观</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'xyz'</span>, <span class="string">'i'</span>);  <span class="comment">// RegExp构造函数。在运行时新建正则表达式</span></span><br><span class="line"><span class="comment">// 实例属性修饰符相关: ignoreCase; global; multiline</span></span><br><span class="line"><span class="comment">// 实例属性修饰符无关: lastIndex 下一次开始搜索的位置。可读写，只在进行连续搜索时有意义; source返回正则表达式的字符串形式（不包括反斜杠），该属性只读</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法 RegExp.prototype.test() 和 RegExp.prototype.exec()</span></span><br><span class="line">test()  返回一个布尔值，表示当前模式是否能匹配参数字符串</span><br><span class="line">/cat/.test(<span class="string">'cats and dogs'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">exec()  返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回<span class="literal">null</span></span><br><span class="line">/x/.exec(<span class="string">'_x_x'</span>)  <span class="comment">// ["x"]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串的实例方法，有4种与正则表达式有关，String.prototype.match()等。</span></span><br><span class="line">match()：字符串的match方法与正则对象的exec方法非常类似：匹配成功返回一个数组，匹配失败返回<span class="literal">null</span>。如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会一次性返回所有匹配成功的结果。</span><br><span class="line"><span class="string">'_x_x'</span>.match(<span class="regexp">/x/</span>)   <span class="comment">// ["x"] </span></span><br><span class="line"></span><br><span class="line">search()：返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回<span class="number">-1</span></span><br><span class="line"><span class="string">'_x_x'</span>.search(<span class="regexp">/x/</span>)  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">replace(search, replacement)：替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。正则表达式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。</span><br><span class="line"><span class="string">'aaa'</span>.replace(<span class="string">'a'</span>, <span class="string">'b'</span>) <span class="comment">// "baa"</span></span><br><span class="line"><span class="string">'aaa'</span>.replace(<span class="regexp">/a/g</span>, <span class="string">'b'</span>) <span class="comment">// "bbb"</span></span><br><span class="line"><span class="comment">// replace方法的一个应用，就是消除字符串首尾两端的空格。</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'  #id div.class  '</span>;</span><br><span class="line">str.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>)   <span class="comment">// "#id div.class"</span></span><br><span class="line"></span><br><span class="line">split(separator, [limit])：按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。</span><br><span class="line"><span class="comment">// 正则分隔，去除多余的空格，并指定返回数组的最大成员</span></span><br><span class="line"><span class="string">'a,  b,c, d'</span>.split(<span class="regexp">/, */</span>, <span class="number">2</span>)  [ <span class="string">'a'</span>, <span class="string">'b'</span> ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预定义模式，某些常见模式的简写方式</span></span><br><span class="line">\d 匹配<span class="number">0</span><span class="number">-9</span>之间的任一数字，相当于[<span class="number">0</span><span class="number">-9</span>]。</span><br><span class="line">\D 匹配所有<span class="number">0</span><span class="number">-9</span>以外的字符，相当于[^<span class="number">0</span><span class="number">-9</span>]。</span><br><span class="line">\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0<span class="number">-9</span>_]。</span><br><span class="line">\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0<span class="number">-9</span>_]。</span><br><span class="line">\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。</span><br><span class="line">\S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。</span><br><span class="line">\b 匹配词的边界。</span><br><span class="line">\B 匹配非词边界，即在词的内部。</span><br><span class="line">如，/\bworld/.test(<span class="string">'helloworld'</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 量词符，用来设定某个模式出现的次数。</span></span><br><span class="line">? 问号，<span class="number">0</span>次或<span class="number">1</span>次，等同于&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">* 星号，<span class="number">0</span>次或多次，等同于&#123;<span class="number">0</span>,&#125;</span><br><span class="line">+ 加号，<span class="number">1</span>次或多次，等同于&#123;<span class="number">1</span>,&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h4><p>JSON 格式（JavaScript Object Notation）是一种用于数据交换的文本格式，2001年由 Douglas Crockford 提出，目的是取代繁琐笨重的 XML 格式。JSON 格式书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。</p>
<p>JSON 对值的类型和格式有严格的规定。注意，null、空数组和空对象都是合法的 JSON 值。<br>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。<br>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。<br>字符串必须使用双引号表示，不能使用单引号。<br>对象的键名必须放在双引号里面。<br>数组或对象最后一个成员的后面，不能加逗号。</p>
<p>JSON对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：JSON.stringify()和JSON.parse()。</p>
<ul>
<li><p>JSON.stringify() 方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于原始类型的字符串，转换结果会带双引号。因为将来还原的时候，内层双引号可以让引擎知道，这是一个字符串，而不是其他类型的值。</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'abc'</span>) <span class="comment">// ""abc""</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify([<span class="number">1</span>, <span class="string">"false"</span>, <span class="literal">false</span>])  <span class="comment">// "[1,"false",false]"</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">name</span>: <span class="string">"张三"</span> &#125;)  <span class="comment">// "&#123;"name":"张三"&#125;"</span></span><br><span class="line"><span class="comment">// 如果对象的属性是undefined、函数或 XML 对象，该属性会被JSON.stringify过滤。</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="literal">undefined</span>, <span class="attr">b</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;&#125;;</span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj) <span class="comment">// "&#123;&#125;"</span></span><br><span class="line"><span class="comment">// 如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;];</span><br><span class="line"><span class="built_in">JSON</span>.stringify(arr) <span class="comment">// "[null,null]"</span></span><br><span class="line"><span class="comment">// 正则对象会被转成空对象。</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="regexp">/foo/</span>) <span class="comment">// "&#123;&#125;"</span></span><br><span class="line"><span class="comment">// JSON.stringify方法会忽略对象enumerable为false的属性。</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">  <span class="string">'bar'</span>: &#123;</span><br><span class="line">    value: <span class="number">2</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj); <span class="comment">// "&#123;&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">'prop1'</span>: <span class="string">'value1'</span>,</span><br><span class="line">  <span class="string">'prop2'</span>: <span class="string">'value2'</span>,</span><br><span class="line">  <span class="string">'prop3'</span>: <span class="string">'value3'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> selectedProperties = [<span class="string">'prop1'</span>, <span class="string">'prop2'</span>];</span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj, selectedProperties)  <span class="comment">// "&#123;"prop1":"value1","prop2":"value2"&#125;"</span></span><br><span class="line"><span class="comment">// 这个类似白名单的数组，只对对象的属性有效，对数组无效。</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify([<span class="string">'a'</span>, <span class="string">'b'</span>], [<span class="string">'0'</span>])  <span class="comment">// "["a","b"]"</span></span><br><span class="line"><span class="comment">// 第二个参数还可以是一个函数，用来更改JSON.stringify的返回值。如果处理函数返回undefined或没有返回值，则该属性会被忽略。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">"number"</span>) &#123;</span><br><span class="line">    value = <span class="number">2</span> * value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;, f)  <span class="comment">// '&#123;"a": 2,"b": 4&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">p1</span>: <span class="number">1</span>, <span class="attr">p2</span>: <span class="number">2</span> &#125;, <span class="literal">null</span>, <span class="number">2</span>);   <span class="comment">// "&#123;  "p1": 1,  "p2": 2  &#125;"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON.stringify发现参数对象有toJSON方法，就直接使用这个方法的返回值作为参数，而忽略原对象的其他参数。</span></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">'三'</span>,</span><br><span class="line">  lastName: <span class="string">'张'</span>,</span><br><span class="line">  get fullName()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.lastName + <span class="keyword">this</span>.firstName;</span><br><span class="line">  &#125;,</span><br><span class="line">  toJSON: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="keyword">this</span>.lastName + <span class="keyword">this</span>.firstName</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">JSON</span>.stringify(user)  <span class="comment">// "&#123;"name":"张三"&#125;"   若没有 //toJSON方法，则为 "&#123;"firstName":"三","lastName":"张","fullName":"张三"&#125;"</span></span><br><span class="line"><span class="comment">// Date对象就有一个自己的toJSON方法。</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2015-03-05'</span>);</span><br><span class="line">date.toJSON() <span class="comment">// "2015-03-05T00:00:00.000Z"</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(date) <span class="comment">// "2015-03-05T00:00:00.000Z"</span></span><br><span class="line"><span class="comment">// toJSON方法的一个应用是，将正则对象自动转为字符串。因为JSON.stringify默认不能转换正则对象，但是设置了toJSON方法以后，就可以转换正则对象了。</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">reg</span>: <span class="regexp">/foo/</span>&#125;;</span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj) <span class="comment">// "&#123;"reg":&#123;&#125;&#125;"   不设置 toJSON 方法时</span></span><br><span class="line"><span class="built_in">RegExp</span>.prototype.toJSON = <span class="built_in">RegExp</span>.prototype.toString;  </span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="regexp">/foo/</span>)  <span class="comment">// ""/foo/""   设置 toJSON 方法时</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JSON.parse()  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法用于将 JSON 字符串转换成对应的值</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;&#125;'</span>) <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"name": "张三"&#125;'</span>);  <span class="comment">// &#123;name: "张三"&#125;</span></span><br><span class="line"><span class="comment">// 如果传入的字符串不是有效的 JSON 格式，JSON.parse方法将报错。</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">"'String'"</span>)  <span class="comment">// Uncaught SyntaxError: Unexpected token ' in JSON   </span></span><br><span class="line"><span class="comment">// 为了处理解析错误，可以将JSON.parse方法放在try...catch代码块中。</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">JSON</span>.parse(<span class="string">"'String'"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'parsing error'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON.parse方法可以接受一个处理函数，作为第二个参数，用法与JSON.stringify方法类似。如，</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key === <span class="string">'a'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a": 1, "b": 2&#125;'</span>, f)  <span class="comment">// &#123;a: 11, b: 2&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><h4 id="实例对象与-new-命令"><a href="#实例对象与-new-命令" class="headerlink" title="实例对象与 new 命令"></a>实例对象与 new 命令</h4><p>JavaScript 语言具有很强的面向对象编程能力，本章介绍 JavaScript 面向对象编程的基础知识。</p>
<h5 id="对象是什么"><a href="#对象是什么" class="headerlink" title="对象是什么"></a>对象是什么</h5><p>面向对象编程（Object Oriented Programming，OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</p>
<p>对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。</p>
<p>对象是单个实物的抽象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。<br>对象是一个容器，封装了属性（property）和方法（method）。属性是对象的状态，方法是对象的行为（完成某种任务）。</p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>面向对象编程的第一步，就是要生成对象。对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。</p>
<p>典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。</p>
<p>JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数就是一个普通的函数，但是有自己的特征和用法。</span></span><br><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = <span class="number">10000</span>;  <span class="comment">// 构造函数内部的this，代表了新生成的实例对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 上面代码中，Vehicle就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。</span></span><br></pre></td></tr></table></figure></p>
<p>构造函数的特点有两个: 函数体内部使用了this关键字，代表了所要生成的对象实例; 生成对象的时候，必须使用new命令。</p>
<h5 id="new-命令"><a href="#new-命令" class="headerlink" title="new 命令"></a>new 命令</h5><p>new命令的作用，就是执行构造函数，返回一个实例对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用new命令时，根据需要，构造函数也可以接受参数。</span></span><br><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = p; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle(<span class="number">1000</span>);</span><br><span class="line">v.price <span class="comment">// 10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果忘了使用new命令,构造函数就变成了普通函数，并不会生成实例对象。this这时代表全局对象，将造成一些意想不到的结果。</span></span><br><span class="line"><span class="keyword">var</span> v = Vehicle();</span><br><span class="line">v <span class="comment">// undefined</span></span><br><span class="line">price <span class="comment">// 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了保证构造函数必须与new命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上use strict。</span></span><br><span class="line"><span class="comment">// 由于严格模式中，函数内部的this不能指向全局对象，默认等于undefined，JavaScript 不允许对undefined添加属性,导致不加new调用会报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fubar</span>(<span class="params">foo, bar</span>)</span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="keyword">this</span>._foo = foo;</span><br><span class="line">  <span class="keyword">this</span>._bar = bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fubar()  <span class="comment">// Uncaught TypeError: Cannot set property '_foo' of undefined at Fubar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个解决办法，构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fubar</span>(<span class="params">foo, bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Fubar)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Fubar(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._foo = foo;</span><br><span class="line">  <span class="keyword">this</span>._bar = bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fubar(<span class="number">1</span>, <span class="number">2</span>)._foo <span class="comment">// 1</span></span><br><span class="line">(<span class="keyword">new</span> Fubar(<span class="number">1</span>, <span class="number">2</span>))._foo <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<h5 id="new-命令的原理"><a href="#new-命令的原理" class="headerlink" title="new 命令的原理"></a>new 命令的原理</h5><p>使用new命令时，它后面的函数依次执行下面的步骤。创建一个空对象，作为将要返回的对象实例。将这个空对象的原型，指向构造函数的prototype属性。将这个空对象赋值给函数内部的this关键字。开始执行构造函数内部的代码。</p>
<p>也就是说，构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。</span></span><br><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> Vehicle()) === <span class="number">1000</span>  <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 上面代码中，构造函数Vehicle的return语句返回一个数值。这时，new命令就会忽略这个return语句，返回“构造”后的this对象。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，如果return语句返回的是一个跟this无关的新对象，new命令会返回这个新对象，而不是this对象。这一点需要特别引起注意。</span></span><br><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">price</span>: <span class="number">2000</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> Vehicle()).price  <span class="comment">// 2000</span></span><br><span class="line"><span class="comment">// 上面代码中，构造函数Vehicle的return语句，返回的是一个新对象。new命令会返回这个对象，而不是this对象。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一方面，如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'this is a message'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> getMessage();</span><br><span class="line">msg <span class="comment">// getMessage &#123;&#125;</span></span><br><span class="line"><span class="comment">// 上面代码中，getMessage是一个普通函数，返回一个字符串。对它使用new命令，会得到一个空对象。这是因为new命令总是返回一个对象，要么是实例对象，要么是return语句指定的对象。本例中，return语句返回的是字符串，所以new命令就忽略了该语句。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// new命令简化的内部流程，可以用下面的代码表示。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params"><span class="regexp">/* 构造函数 */</span> constructor, <span class="regexp">/* 构造函数参数 */</span> params</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将 arguments 对象转为数组</span></span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 取出构造函数</span></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">constructor</span> = args.shift();</span><br><span class="line">  // 创建一个空对象，继承构造函数的 prototype 属性</span><br><span class="line">  var context = Object.create(<span class="keyword">constructor</span>.prototype);</span><br><span class="line">  // 执行构造函数</span><br><span class="line">  var result = <span class="keyword">constructor</span>.apply(context, args);</span><br><span class="line">  // 如果返回结果是对象，就直接返回，否则返回 context 对象</span><br><span class="line">  return (typeof result === 'object' &amp;&amp; result != null) ? result : context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例</span><br><span class="line">var actor = _new(Person, '张三', 28);</span><br></pre></td></tr></table></figure></p>
<h5 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h5><p>函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// false</span></span><br><span class="line"><span class="keyword">new</span> f() <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这个属性，可以判断函数调用的时候，是否使用new命令。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'请使用 new 命令调用！'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// Uncaught Error: 请使用 new 命令调用！</span></span><br></pre></td></tr></table></figure></p>
<h5 id="Object-create-创建实例对象"><a href="#Object-create-创建实例对象" class="headerlink" title="Object.create() 创建实例对象"></a>Object.create() 创建实例对象</h5><p>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  age: <span class="number">38</span>,</span><br><span class="line">  greeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person1);</span><br><span class="line"></span><br><span class="line">person2.name <span class="comment">// 张三</span></span><br><span class="line">person2.greeting() <span class="comment">// Hi! I'm 张三.</span></span><br><span class="line"><span class="comment">// 上面代码中，对象person1是person2的模板，后者继承了前者的属性和方法。</span></span><br></pre></td></tr></table></figure></p>
<h4 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h4><p>在JavaScript 中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行。</p>
<ul>
<li><p>核心: this总是返回一个对象，this就是属性或方法“当前”所在的对象，即函数运行时所在的对象（环境）。</p>
</li>
<li><p>实质<br>JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>:  <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的代码将一个对象赋值给变量obj。JavaScript 引擎会先在内存里面，生成一个对象&#123; foo: 5 &#125;，然后把这个对象的内存地址赋值给变量obj。也就是说，变量obj是一个地址（reference）。后面如果要读取obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的foo属性，实际上是以下面的形式保存的。foo属性的值保存在属性描述对象的value属性里面。</span></span><br><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: <span class="number">5</span></span><br><span class="line">    [[writable]]: <span class="literal">true</span></span><br><span class="line">    [[enumerable]]: <span class="literal">true</span></span><br><span class="line">    [[configurable]]: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，属性的值也可能是一个函数。</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="comment">// 这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给foo属性的value属性</span></span><br><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: 函数的地址</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于函数是一个单独的值，函数可以在不同的运行环境（上下文）执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">f</span>: f, <span class="attr">x</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); &#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1  单独执行 </span></span><br><span class="line">obj.f() <span class="comment">// 2   obj 环境执行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用场合<br>this主要有以下几个使用场合。全局环境、构造函数、对象的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局环境。全局环境使用this，它指的就是顶层对象window。</span></span><br><span class="line"><span class="keyword">this</span> === <span class="built_in">window</span> <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象window。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数。构造函数中的this，指的是实例对象。</span></span><br><span class="line"><span class="keyword">var</span> Obj = <span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.p = p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Obj(<span class="string">'Hello World!'</span>);</span><br><span class="line">o.p <span class="comment">// "Hello World!"</span></span><br><span class="line"><span class="comment">// 上面代码定义了一个构造函数Obj。由于this指向实例对象，所以在构造函数内部定义this.p，就相当于定义实例对象有一个p属性。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的方法。如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。</span></span><br><span class="line"><span class="comment">// 下面代码中，obj.foo方法执行时，它内部的this指向obj。</span></span><br><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo() <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，下面这几种用法，都会改变this的指向。obj.foo就是一个值。这个值真正调用的时候，运行环境已经不是obj了，而是全局环境，所以this不再指向obj。</span></span><br><span class="line"><span class="comment">// 情况一</span></span><br><span class="line">(obj.foo = obj.foo)() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line">(<span class="literal">false</span> || obj.foo)() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line">(<span class="number">1</span>, obj.foo)() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 可以这样理解，JavaScript 引擎内部，obj和obj.foo储存在两个内存地址，称为地址一和地址二。obj.foo()这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，this指向obj。但是，上面三种情况，都是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此this指向全局环境。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果this所在的方法不在对象的第一层，这时this只是指向当前一层的对象，而不会继承更上面的层。</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  p: <span class="string">'Hello'</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.b.m() <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 上面代码中，a.b.m方法在a对象的第二层，该方法内部的this不是指向a，而是指向a.b，因为实际执行的是下面的代码。</span></span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  p: <span class="string">'Hello'</span>,</span><br><span class="line">  b: b</span><br><span class="line">&#125;;</span><br><span class="line">(a.b).m() <span class="comment">// 等同于 b.m()</span></span><br><span class="line"><span class="comment">// 如果要达到预期效果，只有写成下面这样。</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  b: &#123;</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.p);</span><br><span class="line">    &#125;,</span><br><span class="line">    p: <span class="string">'Hello'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这时将嵌套对象内部的方法赋值给一个变量，this依然会指向全局对象。</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  b: &#123;</span><br><span class="line">    m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.p);</span><br><span class="line">    &#125;,</span><br><span class="line">    p: <span class="string">'Hello'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> hello = a.b.m;</span><br><span class="line">hello() <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 上面代码中，m是多层对象内部的一个方法。为求简便，将其赋值给hello变量，结果调用时，this指向了顶层对象。为了避免这个问题，可以只将m所在的对象赋值给hello，这样调用时，this的指向就不会变。</span></span><br><span class="line"><span class="keyword">var</span> hello = a.b;</span><br><span class="line">hello.m() <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用注意点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免多层 this。由于this的指向是不确定的，所以切勿在函数中包含多层的this。</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  f1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// Object</span></span><br><span class="line">    <span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// Window</span></span><br><span class="line">    &#125;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.f1()</span><br><span class="line"><span class="comment">// 上面代码包含两层this，结果运行后，第一层指向对象o，第二层指向全局对象，因为实际执行的是下面的代码。</span></span><br><span class="line"><span class="keyword">var</span> temp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  f1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">var</span> f2 = temp();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个解决方法是在第二层改用一个指向外层this的变量。</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  f1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// Object</span></span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(that);  <span class="comment">// Object</span></span><br><span class="line">    &#125;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码定义了变量that，固定指向外层的this，然后在内层使用that，就不会发生this指向的改变。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的this指向顶层对象，就会报错。</span></span><br><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">counter.inc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="keyword">this</span>.count++</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = counter.inc;</span><br><span class="line">f()  <span class="comment">// Uncaught TypeError: Cannot read property 'count' of undefined at counter.inc</span></span><br><span class="line"><span class="comment">// 上面代码中，inc方法通过'use strict'声明采用严格模式，这时内部的this一旦指向顶层对象，就会报错。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此外，还要避免数组处理方法中的 this。数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。避免回调函数中的 this。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定 this 的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript 提供了call、apply、bind这三个方法，来切换/固定this的指向。</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.call(thisValue, arg1, arg2, ...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line">f() === <span class="built_in">window</span> <span class="comment">// true</span></span><br><span class="line">f.call(obj) === obj <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 上面代码中，全局环境运行函数f时，this指向全局环境（浏览器为window对象）；call方法可以改变this的指向，指定this指向对象obj，然后在对象obj的作用域中运行函数f。</span></span><br><span class="line"><span class="comment">// call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。</span></span><br><span class="line"><span class="comment">// 如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line">f.call(<span class="number">5</span>)  <span class="comment">// Number &#123;[[PrimitiveValue]]: 5&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply(thisValue, [arg1, arg2, ...])</span><br><span class="line"><span class="comment">// apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y);</span><br><span class="line">&#125;</span><br><span class="line">f.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br><span class="line">f.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">1</span>]) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 上面代码中，f函数本来接受两个参数，使用apply方法以后，就变成可以接受一个数组作为参数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用这一点，可以做一些有趣的应用。</span></span><br><span class="line"><span class="comment">// 找出数组最大元素。JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">9</span>];</span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, a) <span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 将数组的空元素变为undefined</span></span><br><span class="line"><span class="built_in">Array</span>.apply(<span class="literal">null</span>, [<span class="string">'a'</span>, ,<span class="string">'b'</span>]) <span class="comment">// [ 'a', undefined, 'b' ]  数组的forEach方法会跳过空元素，但是不会跳过undefined。</span></span><br><span class="line"><span class="comment">// 转换类似数组的对象。利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;) <span class="comment">// [1, undefined]   生效前提是被处理的对象必须有length属性，以及相对应的数字键。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind()</span><br><span class="line"><span class="comment">// bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d.getTime() <span class="comment">// 1551934555040</span></span><br><span class="line"><span class="keyword">var</span> print = d.getTime;</span><br><span class="line">print() <span class="comment">// Uncaught TypeError: this is not a Date object.</span></span><br><span class="line"><span class="comment">// 上面代码中，我们将d.getTime方法赋给变量print，然后调用print就报错了。这是因为getTime方法内部的this，绑定Date对象的实例，赋给变量print以后，内部的this已经不指向Date对象的实例了。</span></span><br><span class="line"><span class="comment">// bind方法可以解决这个问题。</span></span><br><span class="line"><span class="keyword">var</span> print = d.getTime.bind(d);  <span class="comment">// bind方法将getTime方法内部的this绑定到d对象，这时就可以安全地将这个方法赋值给其他变量了。</span></span><br><span class="line">print() <span class="comment">// 1551934555040   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bind方法的参数就是所要绑定this的对象，下面是一个更清晰的例子。</span></span><br><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  count: <span class="number">0</span>,</span><br><span class="line">  inc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = counter.inc.bind(counter);  <span class="comment">// counter.inc方法被赋值给变量func。这时必须用bind方法将inc内部的this，绑定到counter，否则就会出错。</span></span><br><span class="line">func();</span><br><span class="line">counter.count <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// this绑定到其他对象也是可以的。</span></span><br><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  count: <span class="number">0</span>,</span><br><span class="line">  inc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  count: <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = counter.inc.bind(obj);  <span class="comment">// bind方法将inc方法内部的this，绑定到obj对象。结果调用func函数以后，递增的就是obj内部的count属性。</span></span><br><span class="line">func();</span><br><span class="line">obj.count <span class="comment">// 101  </span></span><br><span class="line"><span class="comment">// bind还可以接受更多的参数，将这些参数绑定原函数的参数。</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="keyword">this</span>.m + y * <span class="keyword">this</span>.n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">m</span>: <span class="number">2</span>, <span class="attr">n</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> newAdd = add.bind(obj, <span class="number">5</span>);  <span class="comment">//bind方法除绑定this对象，还将add函数的第一个参数x绑定成5，返回一个新函数newAdd，新函数只要再接受一个参数y就能运行了</span></span><br><span class="line">newAdd(<span class="number">5</span>) <span class="comment">// 20</span></span><br><span class="line"><span class="comment">// 如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向顶层对象（浏览器为window）。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> plus2 = add.bind(<span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line">plus2(<span class="number">8</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 上面代码中，函数add内部并没有this，使用bind方法的主要目的是绑定参数x，以后每次运行新函数plus5，就只需要提供另一个参数y就够了。而且因为add内部没有this，所以bind的第一个参数是null，不过这里如果是其他对象，也没有影响。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 某些数组方法可以接受一个函数当作参数。这些函数内部的this指向，很可能会出错。</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  times: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  print: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.times.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.print()  <span class="comment">// 张三 张三 张三</span></span><br><span class="line"><span class="comment">// 上面代码中，obj.print内部this.times的this是指向obj的，这个没有问题。但是，forEach方法的回调函数内部的this.name却是指向全局对象，导致没有办法取到值。通过bind方法绑定this可以解决这个问题。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="对象的继承"><a href="#对象的继承" class="headerlink" title="对象的继承"></a>对象的继承</h4><p>大部分面向对象的编程语言，都是通过“类”（class）实现对象的继承。传统上，JavaScript 语言的继承不通过 class，而是通过“原型对象”（prototype）实现，本章介绍 JavaScript 的原型链继承。</p>
<h5 id="原型对象概述"><a href="#原型对象概述" class="headerlink" title="原型对象概述"></a>原型对象概述</h5><ul>
<li>构造函数的缺点<br>JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span> (<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">'大毛'</span>, <span class="string">'白色'</span>);</span><br><span class="line"></span><br><span class="line">cat1.name <span class="comment">// '大毛'</span></span><br><span class="line">cat1.color <span class="comment">// '白色'</span></span><br><span class="line"><span class="comment">// 上面代码中，Cat函数是一个构造函数，函数内部定义了name属性和color属性，所有实例对象（上例是cat1）都会生成这两个属性，即这两个属性会定义在实例对象上面。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。</span></span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">'二毛'</span>, <span class="string">'黑色'</span>);</span><br><span class="line">cat1.meow === cat2.meow   <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 上面代码中，cat1和cat2是同一个构造函数的两个实例，它们都具有meow方法。由于meow方法是生成在每个实例对象上面，所以两个实例就生成了两次。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>也就是说，每新建一个实例，就会新建一个meow方法。这既没有必要，又浪费系统资源，因为所有meow方法都是同样的行为，完全应该共享。</p>
<p>这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。</p>
<ul>
<li>prototype 属性的作用<br>JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。</li>
</ul>
<p>每个函数都有一个prototype(原型)属性，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。<br>对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码中，构造函数Animal的prototype属性，就是实例对象cat1和cat2的原型对象。原型对象上添加一个color属性，结果，实例对象都共享了该属性。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.color = <span class="string">'white'</span>;</span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Animal(<span class="string">'大毛'</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Animal(<span class="string">'二毛'</span>);</span><br><span class="line">cat1.color <span class="comment">// 'white'</span></span><br><span class="line">cat2.color <span class="comment">// 'white'</span></span><br><span class="line"><span class="comment">// 原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。</span></span><br><span class="line">Animal.prototype.color = <span class="string">'yellow'</span>;</span><br><span class="line">cat1.color <span class="comment">// "yellow"</span></span><br><span class="line">cat2.color <span class="comment">// "yellow"</span></span><br><span class="line"><span class="comment">// 这是因为实例对象其实没有color属性，都是读取原型对象的color属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。</span></span><br></pre></td></tr></table></figure></p>
<p>总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。</p>
<ul>
<li>原型链<br>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</li>
</ul>
<p>如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性。也就是说，所有对象都继承了Object.prototype的属性。这就是所有对象都有valueOf和toString方法的原因，因为这是从Object.prototype继承的。</p>
<p>那么，Object.prototype对象有没有它的原型呢？回答是Object.prototype的原型是null。null没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是null。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)  <span class="comment">// null</span></span><br><span class="line"><span class="comment">// Object.getPrototypeOf方法返回参数对象的原型</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>constructor 属性<br>prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">P.prototype.constructor === P <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> P();</span><br><span class="line">p.constructor === P <span class="comment">// true</span></span><br><span class="line">p.constructor === P.prototype.constructor <span class="comment">// true</span></span><br><span class="line">p.hasOwnProperty(<span class="string">'constructor'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 上面代码中，p是构造函数P的实例对象，但是p自身没有constructor属性，该属性其实是读取原型链上面的P.prototype.constructor属性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line">f.constructor === F <span class="comment">// true</span></span><br><span class="line">f.constructor === <span class="built_in">RegExp</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 上面代码中，constructor属性确定了实例对象f的构造函数是F，而不是RegExp。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一方面，有了constructor属性，就可以从一个实例对象新建另一个实例。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Constr</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Constr();</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> x.constructor();</span><br><span class="line">y <span class="keyword">instanceof</span> Constr <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 上面代码中，x是构造函数Constr的实例，可以从x.constructor间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.constructor === Person <span class="comment">// true</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.constructor === Person <span class="comment">// false</span></span><br><span class="line">Person.prototype.constructor === <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 上面代码中，构造函数Person的原型对象改掉了，但是没有修改constructor属性，导致这个属性不再指向Person。由于Person的新原型是一个普通对象，而普通对象的constructor属性指向Object构造函数，导致Person.prototype.constructor变成了Object。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以，修改原型对象时，一般要同时修改constructor属性的指向。</span></span><br><span class="line"><span class="comment">// 坏的写法</span></span><br><span class="line">C.prototype = &#123;</span><br><span class="line">  method1: <span class="function"><span class="keyword">function</span> (<span class="params">...</span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line">C.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: C,</span><br><span class="line">  method1: function (...) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 更好的写法</span></span><br><span class="line">C.prototype.method1 = <span class="function"><span class="keyword">function</span> (<span class="params">...</span>) </span>&#123; ... &#125;;</span><br><span class="line"><span class="comment">// 上面代码中，要么将constructor属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证instanceof运算符不会失真。</span></span><br><span class="line"><span class="comment">// 如果不能确定constructor属性是什么函数，还有一个办法：通过name属性，从实例得到构造函数的名称。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo();</span><br><span class="line">f.constructor.name <span class="comment">// "Foo"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h5><p>instanceof运算符返回一个布尔值，表示对象是否为某个构造函数的实例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle();</span><br><span class="line">v <span class="keyword">instanceof</span> Vehicle <span class="comment">// true</span></span><br><span class="line"><span class="comment">// instanceof运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。因此，上面的写法和下面是等同的。</span></span><br><span class="line">Vehicle.prototype.isPrototypeOf(v)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有一种特殊情况，就是左边对象的原型链上，只有null对象。这时，instanceof判断会失真。</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">typeof</span> obj <span class="comment">// "object"</span></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// instanceof运算符的一个用处，是判断值的类型。</span></span><br><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> y = &#123;&#125;;</span><br><span class="line">x <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line">y <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，instanceof运算符只能用于对象，不适用原始类型的值。</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line">s <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false   字符串不是String对象的实例（因为字符串不是对象），所以返回false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此外，对于undefined和null，instanceOf运算符总是返回false。</span></span><br><span class="line"><span class="literal">undefined</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用instanceof运算符，还可以巧妙地解决，调用构造函数时，忘了加new命令的问题。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fubar</span> (<span class="params">foo, bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Fubar) &#123;</span><br><span class="line">    <span class="keyword">this</span>._foo = foo;</span><br><span class="line">    <span class="keyword">this</span>._bar = bar;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Fubar(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码使用instanceof运算符，在函数体内部判断this关键字是否为构造函数Fubar的实例。如果不是，就表明忘了加new命令。</span></span><br></pre></td></tr></table></figure></p>
<h5 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h5><p>让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步是在子类的构造函数中，调用父类的构造函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  Super.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.prop = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码中，Sub是子类的构造函数，this是子类的实例。在实例上调用父类的构造函数Super，就会让子类实例具有父类实例的属性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。</span></span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype);</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.method = <span class="string">'...'</span>;</span><br><span class="line"><span class="comment">// 上面代码中，Sub.prototype是子类的原型，要将它赋值为Object.create(Super.prototype)，而不是直接等于Super.prototype。否则后面两行对Sub.prototype的操作，会连父类的原型Super.prototype一起修改掉。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外一种写法是Sub.prototype等于一个父类实例。</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line"><span class="comment">// 上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 举例来说，下面是一个Shape构造函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Shape.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x += x;</span><br><span class="line">  <span class="keyword">this</span>.y += y;</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'Shape moved.'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 我们需要让Rectangle构造函数继承Shape。</span></span><br><span class="line"><span class="comment">// 第一步，子类继承父类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Shape.call(<span class="keyword">this</span>); <span class="comment">// 调用父类构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.base = Shape;</span><br><span class="line">  <span class="keyword">this</span>.base();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二步，子类继承父类的原型</span></span><br><span class="line">Rectangle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line">Rectangle.prototype.constructor = Rectangle;</span><br><span class="line"><span class="comment">// 采用这样的写法以后，instanceof运算符会对子类和父类的构造函数，都返回true。</span></span><br><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle();</span><br><span class="line">rect <span class="keyword">instanceof</span> Rectangle  <span class="comment">// true</span></span><br><span class="line">rect <span class="keyword">instanceof</span> Shape  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码中，子类是整体继承父类。有时只需要单个方法的继承，这时可以采用下面的写法。</span></span><br><span class="line">ClassB.prototype.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ClassA.prototype.print.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码中，子类B的print方法先调用父类A的print方法，再部署自己的代码。这就等于继承了父类A的print方法。</span></span><br></pre></td></tr></table></figure></p>
<h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.hello = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.world = <span class="string">'world'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">S</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  M1.call(<span class="keyword">this</span>);</span><br><span class="line">  M2.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 M1</span></span><br><span class="line">S.prototype = <span class="built_in">Object</span>.create(M1.prototype);</span><br><span class="line"><span class="comment">// 继承链上加入 M2</span></span><br><span class="line"><span class="built_in">Object</span>.assign(S.prototype, M2.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定构造函数</span></span><br><span class="line">S.prototype.constructor = S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> S();</span><br><span class="line">s.hello <span class="comment">// 'hello'</span></span><br><span class="line">s.world <span class="comment">// 'world'</span></span><br><span class="line"><span class="comment">// 上面代码中，子类S同时继承了父类M1和M2。这种模式又称为 Mixin（混入）。</span></span><br></pre></td></tr></table></figure></p>
<h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>随着网站逐渐变成“互联网应用程序”，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者必须使用软件工程的方法，管理网页的业务逻辑。</p>
<p>JavaScript 模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>
<p>但是，JavaScript 不是一种模块化编程语言，ES6 才开始支持“类”和“模块”。下面介绍传统的做法，如何利用对象实现模块的效果。</p>
<ul>
<li>基本的实现方法<br>模块是实现特定功能的一组属性和方法的封装。</li>
</ul>
<p>简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">　_count : <span class="number">0</span>,</span><br><span class="line">　m1 : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;,</span><br><span class="line">　m2 : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  　<span class="comment">//...</span></span><br><span class="line">　&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 上面的函数m1和m2，都封装在module1对象里。使用的时候，就是调用这个对象的属性。</span></span><br><span class="line">module1.m1();</span><br><span class="line"><span class="comment">// 但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。</span></span><br><span class="line">module1._count = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>封装私有变量：构造函数的写法<br>我们可以利用构造函数，封装私有变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringBuilder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> buffer = [];</span><br><span class="line">  <span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">     buffer.push(str);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buffer.join(<span class="string">''</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码中，buffer是模块的私有变量。一旦生成实例对象，外部是无法直接访问buffer的。但是，这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则，即实例对象的数据，不应该保存在实例对象以外。同时，非常耗费内存。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringBuilder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._buffer = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBuilder.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: StringBuilder,</span><br><span class="line">  add: function (str) &#123;</span><br><span class="line">    <span class="keyword">this</span>._buffer.push(str);</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._buffer.join(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>封装私有变量：立即执行函数的写法<br>使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用下面的写法，外部代码无法读取内部的_count变量。</span></span><br><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　<span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">　<span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　  <span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">var</span> m2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　m1 : m1,</span><br><span class="line">　　m2 : m2</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 上面的module1就是 JavaScript 模块的基本写法。下面，再对这种写法进行加工。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>模块的放大模式<br>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。</span></span><br><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">mod</span>)</span>&#123;</span><br><span class="line">　mod.m3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(module1);</span><br><span class="line"><span class="comment">// 在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用"宽放大模式"（Loose augmentation）。</span></span><br><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">mod</span>) </span>&#123;</span><br><span class="line">  mod.m3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(<span class="built_in">window</span>.module1 || &#123;&#125;);</span><br><span class="line"><span class="comment">// 与"放大模式"相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输入全局变量<br>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</span></span><br><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">$, YAHOO</span>) </span>&#123;</span><br><span class="line">　<span class="comment">//...</span></span><br><span class="line">&#125;)(jQuery, YAHOO);</span><br><span class="line"><span class="comment">// 上面的module1模块需要使用jQuery库和 YUI 库，就把这两个库（其实是两个模块）当作参数输入module1。这样保证了模块的独立性，还使得模块之间的依赖关系变得明显。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即执行函数还可以起到命名空间的作用。</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$, window, document</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleEvents</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dieCarouselDie</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//attach to the global scope</span></span><br><span class="line">  <span class="built_in">window</span>.finalCarousel = &#123;</span><br><span class="line">    init : initialize,</span><br><span class="line">    destroy : dieCarouselDie</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)( jQuery, <span class="built_in">window</span>, <span class="built_in">document</span> );</span><br><span class="line"><span class="comment">// 上面代码中，finalCarousel对象输出到全局，对外暴露init和destroy接口，内部方法go、handleEvents、initialize、dieCarouselDie都是外部无法调用的。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Object-对象的相关方法"><a href="#Object-对象的相关方法" class="headerlink" title="Object 对象的相关方法"></a>Object 对象的相关方法</h4><ul>
<li><p>Object.getPrototypeOf() 返回参数对象的原型。这是获取原型对象的标准方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码中，实例对象f的原型是F.prototype。</span></span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(f) === F.prototype <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 下面是几种特殊对象的原型。</span></span><br><span class="line"><span class="comment">// 函数的原型是 Function.prototype</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(f) === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 空对象的原型是 Object.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(&#123;&#125;) === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Object.prototype 的原型是 null</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype) === <span class="literal">null</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.setPrototypeOf()  为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码中，Object.setPrototypeOf方法将对象a的原型，设置为对象b，因此a可以共享b的属性。</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(a, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === b <span class="comment">// true</span></span><br><span class="line">a.x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new命令可以使用Object.setPrototypeOf方法模拟。</span></span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.foo = <span class="string">'bar'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="built_in">Object</span>.setPrototypeOf(&#123;&#125;, F.prototype);</span><br><span class="line">F.call(f);</span><br><span class="line"><span class="comment">// 上面代码中，new命令新建实例对象，其实可以分成两步。第一步，将一个空对象的原型设为构造函数的prototype属性（上例是F.prototype）；第二步，将构造函数内部的this绑定这个空对象，然后执行构造函数，使得定义在this上面的方法和属性（上例是this.foo），都转移到这个空对象上。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.create()<br>生成实例对象的常用方法是，使用new命令让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？</p>
</li>
</ul>
<p>JavaScript 提供了Object.create方法，用来满足这种需求。该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型对象</span></span><br><span class="line"><span class="comment">// 下面代码中，Object.create方法以A对象为原型，生成了B对象。B继承了A的所有属性和方法。</span></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  print: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实例对象</span></span><br><span class="line"><span class="keyword">var</span> B = <span class="built_in">Object</span>.create(A);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(B) === A <span class="comment">// true</span></span><br><span class="line">B.print() <span class="comment">// hello</span></span><br><span class="line">B.print === A.print <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上，Object.create方法可以用下面的代码代替。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.create !== <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码表明，Object.create方法的实质是新建一个空的构造函数F，然后让F.prototype属性指向参数对象obj，最后返回一个F的实例，从而实现让该实例继承obj的属性。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面三种方式生成的新对象是等价的。</span></span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.create(&#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想要生成一个不继承任何属性（比如没有toString和valueOf方法）的对象，可以将Object.create的参数设为null。</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">obj.valueOf()  <span class="comment">// Uncaught TypeError: obj.valueOf is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Object.create方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。</span></span><br><span class="line"><span class="built_in">Object</span>.create() <span class="comment">// TypeError: Object prototype may only be an Object or null</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="number">123</span>) <span class="comment">// TypeError: Object prototype may only be an Object or null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.create方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(obj1);</span><br><span class="line">obj1.p = <span class="number">2</span>;</span><br><span class="line">obj2.p <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了对象的原型，Object.create方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性。</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;</span><br><span class="line">  p1: &#123;</span><br><span class="line">    value: <span class="number">123</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;);</span><br><span class="line">obj.p1 = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.create方法生成的对象，继承了它的原型对象的构造函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</span><br><span class="line"></span><br><span class="line">b.constructor === A <span class="comment">// true</span></span><br><span class="line">b <span class="keyword">instanceof</span> A <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 上面代码中，b对象的原型是a对象，因此继承了a对象的构造函数A。</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>Object.prototype.isPrototypeOf()   用来判断该对象是否为参数对象的原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码中，o1和o2都是o3的原型。这表明只要实例对象处在参数对象的原型链上，isPrototypeOf方法都返回true。</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(o1);</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(o2);</span><br><span class="line"></span><br><span class="line">o2.isPrototypeOf(o3) <span class="comment">// true</span></span><br><span class="line">o1.isPrototypeOf(o3) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于Object.prototype处于原型链的最顶端，所以对各种实例都返回true，只有直接继承自null的对象除外。</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf([]) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(<span class="regexp">/xyz/</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(<span class="built_in">Object</span>.create(<span class="literal">null</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.prototype.<strong>proto</strong>     实例对象的<strong>proto</strong>属性（前后各两个下划线），返回该对象的原型，即构造函数的prototype属性。该属性可读写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码通过__proto__属性，将p对象设为obj对象的原型。</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123;&#125;;</span><br><span class="line">obj.__proto__ = p;</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj) === p <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __proto__属性指向当前对象的原型对象，即构造函数的prototype属性。</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line">obj.__proto__ === obj.constructor.prototype <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 上面代码首先新建了一个对象obj，它的__proto__属性，指向构造函数（Object或obj.constructor）的prototype属性。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据语言标准，__proto__属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用Object.getPrototypeOf()和Object.setPrototypeOf()，进行原型对象的读写操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链可以用__proto__很直观地表示。</span></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">  name: <span class="string">'李四'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proto = &#123;</span><br><span class="line">  print: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">A.__proto__ = proto;</span><br><span class="line">B.__proto__ = proto;</span><br><span class="line"></span><br><span class="line">A.print() <span class="comment">// 张三</span></span><br><span class="line">B.print() <span class="comment">// 李四</span></span><br><span class="line">A.print === B.print <span class="comment">// true</span></span><br><span class="line">A.print === proto.print <span class="comment">// true</span></span><br><span class="line">B.print === proto.print <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 上面代码中，A对象和B对象的原型都是proto对象，它们都共享proto对象的print方法。也就是说，A和B的print方法，都是在调用proto对象的print方法。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取原型对象方法的比较</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取实例对象obj的原型对象，有三种方法。</span></span><br><span class="line">obj.__proto__</span><br><span class="line">obj.constructor.prototype</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj)  <span class="comment">// 推荐</span></span><br><span class="line"><span class="comment">// 前两种都不是很可靠。__proto__属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype在手动改变原型对象时，可能会失效。</span></span><br><span class="line"><span class="keyword">var</span> P = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> P();</span><br><span class="line"><span class="keyword">var</span> C = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">C.prototype = p;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> C();</span><br><span class="line"></span><br><span class="line">c.constructor.prototype === p <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 上面代码中，构造函数C的原型对象被改成了p，但是实例对象的c.constructor.prototype却没有指向p。所以，在改变原型对象时，一般要同时设置constructor属性。</span></span><br><span class="line">C.prototype = p;</span><br><span class="line">C.prototype.constructor = C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> C();</span><br><span class="line">c.constructor.prototype === p <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.getOwnPropertyNames()   返回一个数组，成员是参数对象本身的所有属性(含不可遍历)的键名，不包含继承的属性键名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(<span class="built_in">Date</span>)   <span class="comment">// ["length", "name", "prototype", "now", "parse", "UTC"]</span></span><br><span class="line"><span class="built_in">Object</span>.keys(<span class="built_in">Date</span>) <span class="comment">// [] 只获取那些可以遍历的属性   这表明，Date对象所有自身的属性，都是不可以遍历的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.prototype.hasOwnProperty()  对象实例的hasOwnProperty方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hasOwnProperty方法是 JavaScript 之中唯一一个处理对象属性时，不会遍历原型链的方法。</span></span><br><span class="line"><span class="built_in">Date</span>.hasOwnProperty(<span class="string">'length'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Date</span>.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 上面代码表明，Date.length（构造函数Date可以接受的参数个数）是Date自身的属性，Date.toString是继承的属性。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>in 运算符   返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in运算符常用于检查一个属性是否存在。</span></span><br><span class="line"><span class="string">'length'</span> <span class="keyword">in</span> <span class="built_in">Date</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'toString'</span> <span class="keyword">in</span> <span class="built_in">Date</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>for…in 循环<br>获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用for…in循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码中，对象o2的p2属性是自身的，p1属性是继承的。这两个属性都会被for...in循环遍历。</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">p1</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(o1, &#123;</span><br><span class="line">  p2: &#123; <span class="attr">value</span>: <span class="string">"abc"</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o2) &#123;</span><br><span class="line">  <span class="built_in">console</span>.info(p);  <span class="comment">// p2  p1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了在for...in循环中获得对象自身的属性，可以采用hasOwnProperty方法判断一下。</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> name <span class="keyword">in</span> object ) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( object.hasOwnProperty(name) ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得对象的所有属性（包括自身和继承的，可枚举和不可枚举）。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritedPropertyNames</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> props = &#123;&#125;;</span><br><span class="line">  <span class="keyword">while</span>(obj) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.getOwnPropertyNames(obj).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">      props[p] = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    obj = <span class="built_in">Object</span>.getPrototypeOf(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyNames(props);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码依次获取obj对象的每一级原型对象“自身”的属性，从而获取obj对象的“所有”属性，不管是否可遍历。</span></span><br><span class="line">inheritedPropertyNames(<span class="built_in">Date</span>)   <span class="comment">// ["length", "name", "prototype", "now", "parse", "UTC", "arguments", "caller", ...]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象的拷贝<br>如果要拷贝一个对象，需要确保拷贝后的对象，与原对象具有同样的原型，且与原对象具有同样的实例属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象拷贝函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyObject</span>(<span class="params">orig</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> copy = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(orig));</span><br><span class="line">  copyOwnPropertiesFrom(copy, orig);</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyOwnPropertiesFrom</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span></span><br><span class="line">    .getOwnPropertyNames(source)</span><br><span class="line">    .forEach(<span class="function"><span class="keyword">function</span> (<span class="params">propKey</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, propKey);</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(target, propKey, desc);</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种更简单的写法，是利用 ES2017 才引入标准的Object.getOwnPropertyDescriptors方法。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyObject</span>(<span class="params">orig</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.create(</span><br><span class="line">    <span class="built_in">Object</span>.getPrototypeOf(orig),</span><br><span class="line">    <span class="built_in">Object</span>.getOwnPropertyDescriptors(orig)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>正常的运行模式外，JavaScript 还有第二种运行模式：严格模式（strict mode），这种模式采用更加严格的 JavaScript 语法。</p>
<h5 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h5><p>早期的 JS 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法。严格模式是从 ES5 进入标准的，主要目的有以下几个。<br>明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。<br>增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。<br>提高编译器效率，增加运行速度。<br>为未来新版本的 JavaScript 语法做好铺垫。<br>总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向。</p>
<h5 id="启用方法"><a href="#启用方法" class="headerlink" title="启用方法"></a>启用方法</h5><p>进入严格模式的标志，是一行字符串。老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。<br>‘use strict’;</p>
<p>严格模式可以用于整个脚本(放在脚本文件的第一行，严格地说，只要前面不是产生实际运行结果的语句，可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面)，也可以只用于单个函数(放在函数体的第一行)。</p>
<p>有时，需要把不同的脚本合并在一个文件里面。如果一个脚本是严格模式，另一个脚本不是，它们的合并就可能出错。严格模式的脚本在前，则合并后的脚本都是严格模式；如果正常模式的脚本在前，则合并后的脚本都是正常模式。这两种情况下，合并后的结果都是不正确的。这时可以考虑把整个脚本文件放在一个立即执行的匿名函数之中。</p>
<h5 id="显式报错"><a href="#显式报错" class="headerlink" title="显式报错"></a>显式报错</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只读属性不可写</span></span><br><span class="line"><span class="comment">// 严格模式下，设置字符串的length属性，会报错。因为length是只读属性，严格模式下不可写。正常模式下，改变length属性是无效的，但不会报错。</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="string">'abc'</span>.length = <span class="number">5</span>;  <span class="comment">// Uncaught TypeError: Cannot assign to read only property 'length' of string 'abc'</span></span><br><span class="line"><span class="comment">// 严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错。</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'a'</span>, &#123;</span><br><span class="line">  value: <span class="number">37</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line">obj.a = <span class="number">123</span>;  <span class="comment">// Uncaught TypeError: Cannot add property a, object is not extensible</span></span><br><span class="line"><span class="keyword">delete</span> obj.a  <span class="comment">// Uncaught TypeError: Cannot delete property 'a' of #&lt;Object&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只设置了取值器的属性不可写</span></span><br><span class="line"><span class="comment">// 严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  get v() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.v = <span class="number">2</span>;  <span class="comment">// Uncaught TypeError: Cannot set property v of #&lt;Object&gt; which has only a getter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止扩展的对象不可扩展</span></span><br><span class="line"><span class="comment">// 严格模式下，对禁止扩展的对象添加新属性，会报错。</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line">obj.v = <span class="number">1</span>;  <span class="comment">// // Uncaught TypeError: Cannot add property v, object is not extensible</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eval、arguments 不可用作标识名</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">eval</span> = <span class="number">17</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arguments</span>(<span class="params"></span>) </span>&#123; &#125; <span class="comment">// Uncaught SyntaxError: Unexpected eval or arguments in strict mode</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数不能有重名的参数</span></span><br><span class="line"><span class="comment">// 正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a, b</span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止八进制的前缀0表示法</span></span><br><span class="line"><span class="comment">// 正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0100</span>; <span class="comment">// Uncaught SyntaxError: Octal literals are not allowed in strict mode.</span></span><br></pre></td></tr></table></figure>
<h5 id="增强的安全措施"><a href="#增强的安全措施" class="headerlink" title="增强的安全措施"></a>增强的安全措施</h5><p>严格模式增强了安全保护，从语法上防止了一些不小心会出现的错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量显式声明</span></span><br><span class="line"><span class="comment">// 正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式下，变量都必须先声明，然后再使用。</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line">v = <span class="number">1</span>; <span class="comment">// Uncaught ReferenceError: v is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止 this 关键字指向全局对象</span></span><br><span class="line"><span class="comment">// 正常模式下，函数内部的this可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。</span></span><br><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="literal">undefined</span>);  <span class="comment">// 严格模式的函数体内部this是undefined</span></span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// true   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加new，这时this不再指向全局对象，而是报错。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">f();<span class="comment">// 报错，this 未定义</span></span><br><span class="line"><span class="comment">// 严格模式下，函数直接调用时（不使用new调用），函数内部的this表示undefined（未定义），因此可以用call、apply和bind方法，将任意值绑定在this上面。正常模式下，this指向全局对象，如果绑定的值是非对象，将被自动转为对象再绑定上去，而null和undefined这两个无法转成对象的值，将被忽略。</span></span><br><span class="line"><span class="comment">// 正常模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">fun() <span class="comment">// window</span></span><br><span class="line">fun.call(<span class="number">2</span>) <span class="comment">// Number &#123;2&#125;</span></span><br><span class="line">fun.call(<span class="literal">true</span>) <span class="comment">// Boolean &#123;true&#125;</span></span><br><span class="line">fun.call(<span class="literal">null</span>) <span class="comment">// window</span></span><br><span class="line">fun.call(<span class="literal">undefined</span>) <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">fun() <span class="comment">//undefined</span></span><br><span class="line">fun.call(<span class="number">2</span>) <span class="comment">// 2</span></span><br><span class="line">fun.call(<span class="literal">true</span>) <span class="comment">// true</span></span><br><span class="line">fun.call(<span class="literal">null</span>) <span class="comment">// null</span></span><br><span class="line">fun.call(<span class="literal">undefined</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止使用 fn.callee、fn.caller</span></span><br><span class="line"><span class="comment">// 禁止使用 arguments.callee、arguments.caller</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止删除变量</span></span><br><span class="line"><span class="comment">// 严格模式下无法删除变量，如果使用delete命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的configurable属性设置为true，才能被delete命令删除。</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">delete</span> x; <span class="comment">// 语法错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>, &#123;</span><br><span class="line">  x: &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">delete</span> obj.x; <span class="comment">// 删除成功</span></span><br></pre></td></tr></table></figure></p>
<h5 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h5><p>JavaScript 语言的一个特点，就是允许“动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。</p>
<p>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，必须在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。</p>
<p>具体来说，涉及以下几个方面: </p>
<ul>
<li>禁止使用 with 语句</li>
<li>创设 eval 作用域。<br>正常模式下，eval语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，eval所生成的变量只能用于eval内部。</li>
<li>arguments 不再追踪参数的变化。</li>
</ul>
<h3 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h3><h4 id="异步操作概述"><a href="#异步操作概述" class="headerlink" title="异步操作概述"></a>异步操作概述</h4><h5 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h5><p>JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。但不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。</p>
<p>原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>
<p>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。</p>
<p>JavaScript 语言的设计者意识到，CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。</p>
<h5 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h5><p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p>
<p>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p>
<p>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p>
<h5 id="任务队列和事件循环"><a href="#任务队列和事件循环" class="headerlink" title="任务队列和事件循环"></a>任务队列和事件循环</h5><p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p>
<p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p>
<p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p>
<p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。事件循环是一个程序结构，用于等待和发送消息和事件。</p>
<h5 id="异步操作的模式"><a href="#异步操作的模式" class="headerlink" title="异步操作的模式"></a>异步操作的模式</h5><ul>
<li><p>回调函数<br>回调函数是异步操作最基本的方法。回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是两个函数f1和f2，编程的意图是f2必须等到f1执行完成，才能执行。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line">f2();</span><br><span class="line"><span class="comment">// 上面代码的问题在于，如果f1是异步操作，f2会立即执行，不会等到f1结束再执行。</span></span><br><span class="line"><span class="comment">// 这时，可以考虑改写f1，把f2写成f1的回调函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(f2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件监听<br>异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的 jQuery 的写法）。</span></span><br><span class="line">f1.on(<span class="string">'done'</span>, f2);</span><br><span class="line"><span class="comment">// 上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    f1.trigger(<span class="string">'done'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码中，f1.trigger('done')表示，执行完成后，立即触发done事件，从而开始执行f2。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>发布/订阅<br>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称“观察者模式”（observer pattern）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，f2向信号中心jQuery订阅done信号。</span></span><br><span class="line">jQuery.subscribe(<span class="string">'done'</span>, f2);</span><br><span class="line"><span class="comment">// 然后，f1进行如下改写。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    jQuery.publish(<span class="string">'done'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码中，jQuery.publish('done')的意思是，f1执行完成后，向信号中心jQuery发布done信号，从而引发f2的执行。</span></span><br><span class="line"><span class="comment">// f2完成执行后，可以取消订阅（unsubscribe）。</span></span><br><span class="line">jQuery.unsubscribe(<span class="string">'done'</span>, f2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
<h5 id="异步操作的流程控制"><a href="#异步操作的流程控制" class="headerlink" title="异步操作的流程控制"></a>异步操作的流程控制</h5><p>如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。</p>
<ul>
<li><p>串行执行<br>我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码中，函数series就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行final函数。items数组保存每一个异步任务的参数，results数组保存每一个异步任务的运行结果。</span></span><br><span class="line"><span class="keyword">var</span> items = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ];</span><br><span class="line"><span class="keyword">var</span> results = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">arg, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'参数为 '</span> + arg +<span class="string">' , 1秒后返回结果'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; callback(arg * <span class="number">2</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">final</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'完成: '</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">series</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(item) &#123;</span><br><span class="line">    <span class="keyword">async</span>( item, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      results.push(result);</span><br><span class="line">      <span class="keyword">return</span> series(items.shift());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> final(results[results.length - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">series(items.shift());</span><br><span class="line"><span class="comment">// 上面的写法需要六秒，才能完成整个脚本。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>并行执行<br>流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行final函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码中，forEach方法会同时发起六个异步任务，等到它们全部完成以后，才会执行final函数。</span></span><br><span class="line"><span class="keyword">var</span> items = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ];</span><br><span class="line"><span class="keyword">var</span> results = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">arg, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'参数为 '</span> + arg +<span class="string">' , 1秒后返回结果'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; callback(arg * <span class="number">2</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">final</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'完成: '</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">async</span>(item, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    results.push(result);</span><br><span class="line">    <span class="keyword">if</span>(results.length === items.length) &#123;</span><br><span class="line">      final(results[results.length - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>并行与串行的结合<br>所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行n个异步任务，这样就避免了过分占用系统资源。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码中，最多只能同时运行两个异步任务。变量running记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于0，就表示所有任务都执行完了，这时就执行final函数。</span></span><br><span class="line"><span class="keyword">var</span> items = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ];</span><br><span class="line"><span class="keyword">var</span> results = [];</span><br><span class="line"><span class="keyword">var</span> running = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> limit = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">arg, callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'参数为 '</span> + arg +<span class="string">' , 1秒后返回结果'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; callback(arg * <span class="number">2</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">final</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'完成: '</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">launcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(running &lt; limit &amp;&amp; items.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = items.shift();</span><br><span class="line">    <span class="keyword">async</span>(item, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      results.push(result);</span><br><span class="line">      running--;</span><br><span class="line">      <span class="keyword">if</span>(items.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        launcher();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(running == <span class="number">0</span>) &#123;</span><br><span class="line">        final(results);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    running++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">launcher();</span><br><span class="line"><span class="comment">// 这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节limit变量，达到效率和资源的最佳平衡。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由setTimeout()和setInterval()这两个函数来完成。它们向任务队列添加定时任务。</p>
<ul>
<li>setTimeout()<br>setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。<br>var timerId = setTimeout(func, delay);  第二个参数如果省略，则默认为0。还允许更多的参数。它们将依次传入推迟执行的函数（回调函数）</li>
</ul>
<p>注意，如果回调函数是对象的方法，那么setTimeout使得方法内部的this关键字指向全局环境，而不是定义时所在的那个对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码输出的是1，而不是2。因为当obj.y在1000毫秒后运行时，this所指向的已经不是obj了，而是全局环境。</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">2</span>,</span><br><span class="line">  y: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setTimeout(obj.y, <span class="number">1000</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 为了防止出现这个问题，一种解决方法是将obj.y放入一个函数中。这使得obj.y在obj的作用域执行，而不是在全局作用域内执行，所以能够显示正确的值。</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; obj.y(); &#125;, <span class="number">1000</span>);  <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 另一种解决方法是，使用bind方法，将obj.y这个方法绑定在obj上面。</span></span><br><span class="line">setTimeout(obj.y.bind(obj), <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>setInterval()<br>setInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</li>
</ul>
<p>setInterval指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，setInterval指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。</p>
<p>为了确保两次执行之间有固定的间隔，可以不用setInterval，而是每次执行结束后，使用setTimeout指定下一次执行的具体时间。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码可以确保，下一次执行总是在本次执行结束之后的2000毫秒开始。</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> timer = setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  timer = setTimeout(f, <span class="number">2000</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>clearTimeout()，clearInterval()<br>setTimeout和setInterval函数，都返回一个整数值，表示计数器编号。将该整数传入clearTimeout和clearInterval函数，就可以取消对应的定时器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码中，回调函数f不会再执行了，因为定时器被取消了。</span></span><br><span class="line"><span class="keyword">var</span> id1 = setTimeout(f, <span class="number">1000</span>);</span><br><span class="line">clearTimeout(id1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消当前所有的setTimeout定时器。</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 每轮事件循环检查一次</span></span><br><span class="line">  <span class="keyword">var</span> gid = setInterval(clearAllTimeouts, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">clearAllTimeouts</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (id !== gid) &#123;</span><br><span class="line">        clearTimeout(id);</span><br><span class="line">      &#125;</span><br><span class="line">      id--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 上面代码中，先调用setTimeout，得到一个计算器编号，然后把编号比它小的计数器全部取消。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>debounce 防抖  要连续操作结束后再执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>; <span class="comment">// 声明计时器</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'textarea'</span>).on(<span class="string">'keydown'</span>, debounce(ajaxAction, <span class="number">2500</span>));</span><br><span class="line"><span class="comment">// 上面代码中，只要在2500毫秒之内，用户再次击键，就会取消上一次的定时器，然后再新建一个定时器。这样就保证了回调函数之间的调用间隔，至少是2500毫秒。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>throttle 节流  确保一段时间内只执行一次</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> time = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((time + wait - <span class="built_in">Date</span>.now()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      fn();</span><br><span class="line">      time = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行机制<br>setTimeout和setInterval的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；否则，就继续等待。</p>
</li>
<li><p>setTimeout(f, 0)<br>等到当前脚本的同步任务，全部处理完以后，才会执行setTimeout指定的回调函数f。也就是说，setTimeout(f, 0)会在下一轮事件循环一开始就执行。尽可能早地执行f，但是并不能保证立刻就执行f。</p>
</li>
</ul>
<p>实际上，setTimeout(f, 0)不会真的在0毫秒之后运行，不同的浏览器有不同的实现。以 Edge 浏览器为例，会等到4毫秒之后运行。如果电脑正在使用电池供电，会等到16毫秒之后运行；如果网页不在当前 Tab 页，会推迟到1000毫秒（1秒）之后运行。这样是为了节省系统资源。</p>
<h4 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h4><p>Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口，让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。</p>
<p>Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的。</p>
<ul>
<li><p>Promise 对象的状态<br>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。异步操作未完成（pending）、异步操作成功（fulfilled）、异步操作失败（rejected）。fulfilled和rejected合在一起称为resolved（已定型）。这三种的状态的变化途径只有两种。从“未完成”到“成功” 和 从“未完成”到“失败”。一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。</p>
</li>
<li><p>Promise 构造函数<br>JavaScript 提供原生的Promise构造函数，用来生成 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 异步操作失败 */</span></span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>微任务<br>Promise 的回调函数属于异步任务，会在同步任务之后执行。</p>
</li>
</ul>
<p>但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面代码会先输出2，再输出1。因为console.log(2)是同步任务，而then的回调函数属于异步任务，一定晚于同步任务执行。</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="built_in">console</span>.log);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面代码的输出结果是321。这说明then的回调函数的执行时间，早于setTimeout(fn, 0)。因为then是本轮事件循环执行，setTimeout(fn, 0)在下一轮事件循环开始时执行。</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="built_in">console</span>.log);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 3  2  1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><h4 id="DOM-概述"><a href="#DOM-概述" class="headerlink" title="DOM 概述"></a>DOM 概述</h4><ul>
<li>DOM<br>DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。</li>
</ul>
<p>浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。</p>
<ul>
<li>节点<br>DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。</li>
</ul>
<p>节点的类型有七种:<br>Document：整个文档树的顶层节点<br>DocumentType：doctype标签（比如 !DOCTYPE html）<br>Element：网页的各种HTML标签（比如 body&gt;、a等）<br>Attribute：网页元素的属性（比如class=”right”）<br>Text：标签之间或标签包含的文本<br>Comment：注释<br>DocumentFragment：文档的片段</p>
<p>浏览器提供一个原生的节点对象Node，上面这七种节点都继承了Node，因此具有一些共同的属性和方法。</p>
<ul>
<li>节点树<br>一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，倒过来就像一棵树。</li>
</ul>
<p>浏览器原生提供document节点，代表整个文档。文档的第一层只有一个节点，就是 HTML 网页的第一个标签 html，它构成了树结构的根节点（root node），其他 HTML 标签节点都是它的下级节点。除了根节点，其他节点都有三种层级关系。父节点关系（parentNode）、子节点关系（childNodes）、同级节点关系（sibling）。</p>
<h4 id="Node-接口"><a href="#Node-接口" class="headerlink" title="Node 接口"></a>Node 接口</h4><p>所有 DOM 节点对象都继承了 Node 接口，拥有一些共同的属性和方法。这是 DOM 操作的基础。</p>
<ul>
<li><p>nodeType  返回一个整数值，表示节点的类型<br>不同节点的nodeType属性值和对应的常量如下。<br>文档节点（document）：9，对应常量Node.DOCUMENT_NODE<br>元素节点（element）：1，对应常量Node.ELEMENT_NODE<br>属性节点（attr）：2，对应常量Node.ATTRIBUTE_NODE<br>文本节点（text）：3，对应常量Node.TEXT_NODE<br>文档片断节点（DocumentFragment）：11，对应常量Node.DOCUMENT_FRAGMENT_NODE<br>文档类型节点（DocumentType）：10，对应常量Node.DOCUMENT_TYPE_NODE<br>注释节点（Comment）：8，对应常量Node.COMMENT_NODE</p>
</li>
<li><p>nodeName  返回节点的名称<br>不同节点的nodeName属性值如下。<br>文档节点（document）：#document<br>元素节点（element）：大写的标签名<br>属性节点（attr）：属性的名称<br>文本节点（text）：#text<br>文档片断节点（DocumentFragment）：#document-fragment<br>文档类型节点（DocumentType）：文档的类型<br>注释节点（Comment）：#comment</p>
</li>
<li><p>nodeValue  返回一个字符串，表示当前节点本身的文本值，可读写<br>只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值，因此这三类节点的nodeValue可以返回结果，其他类型的节点一律返回null。同样的，也只有这三类节点可以设置nodeValue属性的值，其他类型的节点设置无效。</p>
</li>
<li><p>baseURI  属性返回一个字符串，表示当前网页的绝对路径。<br>浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。该属性的值一般由当前网址的 URL（即window.location属性）决定，但是可以使用 HTML 的 base标签，改变该属性的值。</p>
</li>
<li><p>nextSibling 返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null</p>
</li>
<li><p>previousSibling  返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null</p>
</li>
<li><p>parentNode  返回当前节点的父节点。<br>对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）</p>
</li>
<li><p>childNodes  返回一个类似数组的对象（NodeList集合），成员包括当前节点的所有子节点</p>
</li>
<li><p>firstChild 返回当前节点的第一个子节点，如果当前节点没有子节点，则返回null。</p>
</li>
<li><p>lastChild </p>
</li>
<li><p>appendChild() 方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。</p>
</li>
<li><p>hasChildNodes()<br>注意，子节点包括所有类型的节点，并不仅仅是元素节点。哪怕节点只包含一个空格，hasChildNodes方法也会返回true。</p>
</li>
<li><p>insertBefore() 将某个节点插入父节点内部的指定位置。</p>
</li>
<li><p>removeChild()  接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</p>
</li>
<li><p>replaceChild() 将一个新的节点，替换当前节点的某一个子节点。</p>
</li>
</ul>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="EventTarget-接口"><a href="#EventTarget-接口" class="headerlink" title="EventTarget 接口"></a>EventTarget 接口</h4><p>DOM 的事件操作（监听和触发），都定义在EventTarget接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，XMLHttpRequest、AudioNode、AudioContext）也部署了这个接口。</p>
<ul>
<li>target.addEventListener(type, listener[, useCapture]);<br>type：事件名称，大小写敏感。<br>listener：监听函数。事件发生时，会调用该监听函数。<br>useCapture：布尔值，表示监听函数是否在捕获阶段（capture）触发，默认为false（监听函数只在冒泡阶段被触发）。该参数可选。</li>
</ul>
<p>第三个参数除了布尔值useCapture，还可以是一个属性配置对象。该对象有以下属性。<br>capture：布尔值，表示该事件是否在捕获阶段触发监听函数。<br>once：布尔值，表示监听函数是否只触发一次，然后就自动移除。<br>passive：布尔值，表示监听函数不会调用事件的preventDefault方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.getElementById(<span class="string">'para'</span>);</span><br><span class="line">para.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.nodeName)  <span class="comment">// 监听函数内部的this，指向当前事件所在的那个对象 para。</span></span><br><span class="line">&#125;, &#123;<span class="attr">once</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>target.removeEventListener(type, listener[, useCapture]); 移除addEventListener方法添加的事件监听函数<br>removeEventListener方法的参数，与addEventListener方法完全一致。它的第一个参数“事件类型”，大小写敏感。</li>
</ul>
<p>注意，removeEventListener方法移除的监听函数，必须是addEventListener方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">'click'</span>, listener, <span class="literal">false</span>);</span><br><span class="line">div.removeEventListener(<span class="string">'click'</span>, listener, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>target.dispatchEvent(event) 在当前节点上触发指定事件，从而触发监听函数的执行<br>该方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault()，则返回值为false，否则为true。dispatchEvent方法的参数是一个Event对象的实例。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">para.addEventListener(<span class="string">'click'</span>, hello, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">'click'</span>);</span><br><span class="line">para.dispatchEvent(event);</span><br><span class="line"><span class="comment">// 上面代码在当前节点触发了click事件。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h4><h5 id="监听函数"><a href="#监听函数" class="headerlink" title="监听函数"></a>监听函数</h5><ul>
<li><p>HTML 的 on- 属性<br>HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素的事件监听属性，都是on加上事件名，比如onload就是on + load，表示load事件的监听代码。</span></span><br><span class="line">&lt;p onload=<span class="string">"doSomething()"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 注意，这些属性的值是将会执行的代码，而不是一个函数。一旦指定的事件发生，on-属性的值是原样传入 JavaScript 引擎执行。</span></span><br><span class="line"><span class="comment">// 因此如果要执行函数，不要忘记加上一对圆括号。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这个方法指定的监听代码，只会在冒泡阶段触发。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺点: 同一个事件只能定义一个监听函数，也就是说，如果定义两次onclick属性，后一次定义会覆盖前一次。因此，也不推荐使用。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>元素节点的事件属性<br>元素节点对象的事件属性，同样可以指定监听函数。使用这个方法指定的监听函数，也是只会在冒泡阶段触发。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = doSomething;</span><br><span class="line"></span><br><span class="line">div.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'触发事件'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意，这种方法与 HTML 的on-属性的差异是，它的值是函数名（doSomething），而不像后者，必须给出完整的监听代码（doSomething()）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺点: 违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>EventTarget.addEventListener()<br>所有 DOM 节点实例都有addEventListener方法，用来为该节点定义事件的监听函数。</p>
</li>
</ul>
<p>优点: 同一个事件可以添加多个监听函数。能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。除了 DOM 节点，其他对象（比如window、XMLHttpRequest等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。</p>
<p>以上三种this 的指向，监听函数内部的this指向触发事件的那个元素节点。</p>
<h4 id="Event-对象"><a href="#Event-对象" class="headerlink" title="Event 对象"></a>Event 对象</h4><p>事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个Event对象，所有的事件都是这个对象的实例，或者说继承了Event.prototype对象。</p>
<p>Event对象本身就是一个构造函数，可以用来生成新的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">event = <span class="keyword">new</span> Event(type, options);</span><br><span class="line"><span class="comment">// Event构造函数接受两个参数。第一个参数type是字符串，表示事件的名称；第二个参数options是一个对象，表示事件对象的配置。该对象主要有下面两个属性。</span></span><br><span class="line"><span class="comment">// bubbles：布尔值，可选，默认为false，表示事件对象是否冒泡。若不显示地设置为true，生成的事件就只能在“捕获阶段”触发监听函数。</span></span><br><span class="line"><span class="comment">// cancelable：布尔值，可选，默认为false，表示事件是否可以被取消，即能否用Event.preventDefault()取消这个事件。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ev = <span class="keyword">new</span> Event(</span><br><span class="line">  <span class="string">'look'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">'bubbles'</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'cancelable'</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">document</span>.dispatchEvent(ev);</span><br></pre></td></tr></table></figure>
<h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p>鼠标事件指与鼠标相关的事件，继承了MouseEvent接口。具体的事件主要有以下一些。<br>click：按下鼠标（通常是按下主按钮）时触发。<br>dblclick：在同一个元素上双击鼠标时触发。<br>mousedown：按下鼠标键时触发。<br>mouseup：释放按下的鼠标键时触发。<br>mousemove：当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。<br>mouseenter：鼠标进入一个节点时触发，进入子节点不会触发这个事件。<br>mouseover：鼠标进入一个节点时触发，进入子节点会再一次触发这个事件。<br>mouseout：鼠标离开一个节点时触发，离开父节点也会触发这个事件。<br>mouseleave：鼠标离开一个节点时触发，离开父节点不会触发这个事件。<br>contextmenu：按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文菜单键”时触发。<br>wheel：滚动鼠标的滚轮时触发，该事件继承的是WheelEvent接口。</p>
<p>click事件指的是，用户在同一个位置先完成mousedown动作，再完成mouseup动作。因此，触发顺序是，mousedown首先触发，mouseup接着触发，click最后触发。<br>dblclick事件则会在mousedown、mouseup、click之后触发。<br>mouseover事件和mouseenter事件，都是鼠标进入一个节点时触发。区别是，mouseenter事件只触发一次，而只要鼠标在节点内部移动，mouseover事件会在子节点上触发多次。<br>mouseout事件和mouseleave事件，都是鼠标离开一个节点时触发。区别是，在父元素内部离开一个子元素时，mouseleave事件不会触发，而mouseout事件会触发。</p>
<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><h4 id="浏览器环境概述"><a href="#浏览器环境概述" class="headerlink" title="浏览器环境概述"></a>浏览器环境概述</h4><ul>
<li>script 元素的defer 属性<br>为了解决脚本文件下载阻塞网页渲染的问题，一个方法是对 script元素加入defer属性。它的作用是延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。</li>
</ul>
<p>有了defer属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在DOMContentLoaded事件触发前执行（即刚刚读取完 html标签），而且可以保证执行顺序就是它们在页面上出现的顺序。</p>
<ul>
<li>script 元素的async 属性<br>async属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。</li>
</ul>
<p>async属性可以保证脚本下载的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。另外，使用async属性的脚本文件里面的代码，不应该使用document.write方法。</p>
<p>一般来说，如果脚本之间没有依赖关系，就使用async属性，如果脚本之间有依赖关系，就使用defer属性。如果同时使用async和defer属性，后者不起作用，浏览器行为由async属性决定。</p>
<ul>
<li><p>渲染引擎<br>渲染引擎的主要作用是，将网页代码渲染为用户视觉可以感知的平面文档。不同的浏览器有不同的渲染引擎。<br>Firefox：Gecko 引擎<br>Safari：WebKit 引擎<br>Chrome：Blink 引擎<br>IE: Trident 引擎<br>Edge: EdgeHTML 引擎</p>
</li>
<li><p>重流和重绘<br>渲染树转换为网页布局，称为“布局流”（flow）；布局显示到页面的这个过程，称为“绘制”（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。</p>
</li>
</ul>
<p>页面生成以后，脚本操作和样式表操作，都会触发“重流”（reflow）和“重绘”（repaint）。用户的互动也会触发重流和重绘，比如设置了鼠标悬停（a:hover）效果、页面滚动、在输入框中输入文本、改变窗口大小等等。</p>
<p>重流和重绘并不一定一起发生，重流必然导致重绘，重绘不一定需要重流。比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。</p>
<h4 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h4><p>AJAX（Asynchronous JavaScript and XML)。AJAX 通过原生的XMLHttpRequest对象发出 HTTP 请求，得到服务器返回的数据后，再进行处理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'/endpoint'</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 通信成功时，通信状态值为4</span></span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || (xhr.status === <span class="number">304</span>))&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(xhr.statusText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(xhr.statusText);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>XMLHttpRequest.readyState 返回一个整数，表示实例对象的当前状态。该属性只读。它可能返回以下值。<br>0，表示 XMLHttpRequest 实例已经生成，但是实例的open()方法还没有被调用。<br>1，表示open()方法已经调用，但是实例的send()方法还没有调用，仍然可以使用实例的setRequestHeader()方法，设定 HTTP 请求的头信息。<br>2，表示实例的send()方法已经调用，并且服务器返回的头信息和状态码已经收到。<br>3，表示正在接收服务器传来的数据体（body 部分）。这时，如果实例的responseType属性等于text或者空字符串，responseText属性就会包含已经收到的部分信息。<br>4，表示服务器返回的数据已经完全接收，或者本次接收已经失败。</p>
</li>
<li><p>XMLHttpRequest.withCredentials<br>属性是一个布尔值，表示跨域请求时，用户信息（比如 Cookie 和认证的 HTTP 头信息）是否会包含在请求之中，默认为false，即向example.com发出跨域请求时，不会发送example.com设置在本机上的 Cookie（如果有的话）。</p>
</li>
</ul>
<p>如果需要跨域 AJAX 请求发送 Cookie，需要withCredentials属性设为true。注意，同源的请求不需要设置这个属性。</p>
<p>为了让这个属性生效，服务器必须显式返回Access-Control-Allow-Credentials: true 这个头信息。</p>
<p>withCredentials属性打开的话，跨域请求不仅会发送 Cookie，还会设置远程主机指定的 Cookie。反之也成立，如果withCredentials属性没有打开，那么跨域的 AJAX 请求即使明确要求浏览器设置 Cookie，浏览器也会忽略。</p>
<p>注意，脚本总是遵守同源政策，无法从document.cookie或者 HTTP 回应的头信息之中，读取跨域的 Cookie，withCredentials属性不影响这一点。</p>
<ul>
<li><p>XMLHttpRequest.upload<br>XMLHttpRequest 不仅可以发送请求，还可以发送文件，这就是 AJAX 文件上传。发送文件以后，通过XMLHttpRequest.upload属性可以得到一个对象，通过观察这个对象，可以得知上传的进展。主要方法就是监听这个对象的各种事件：loadstart、loadend、load、abort、error、progress、timeout。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;progress min=<span class="string">"0"</span> max=<span class="string">"100"</span> value=<span class="string">"0"</span>&gt;<span class="number">0</span>% complete&lt;<span class="regexp">/progress&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function upload(blobOrFile) &#123;</span></span><br><span class="line"><span class="regexp">  var xhr = new XMLHttpRequest();</span></span><br><span class="line"><span class="regexp">  xhr.open('POST', '/</span>server<span class="string">', true);</span></span><br><span class="line"><span class="string">  xhr.onload = function (e) &#123;&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  var progressBar = document.querySelector('</span>progress<span class="string">');</span></span><br><span class="line"><span class="string">  xhr.upload.onprogress = function (e) &#123;</span></span><br><span class="line"><span class="string">    if (e.lengthComputable) &#123;</span></span><br><span class="line"><span class="string">      progressBar.value = (e.loaded / e.total) * 100;</span></span><br><span class="line"><span class="string">      // 兼容不支持 &lt;progress&gt; 元素的老式浏览器</span></span><br><span class="line"><span class="string">      progressBar.textContent = progressBar.value;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  xhr.send(blobOrFile);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">upload(new Blob(['</span>hello world<span class="string">'], &#123;type: '</span>text/plain<span class="string">'&#125;));</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>XMLHttpRequest.open() 方法用于指定 HTTP 请求的参数，或者说初始化 XMLHttpRequest 实例对象。<br>它一共可以接受五个参数。<br>method：表示 HTTP 动词方法，比如GET、POST、PUT、DELETE、HEAD等。<br>url: 表示请求发送目标 URL。<br>async: 布尔值，表示请求是否为异步，默认为true。如果设为false，则send()方法只有等到收到服务器返回了结果，才会进行下一步操作。该参数可选。由于同步 AJAX 请求会造成浏览器失去响应，许多浏览器已经禁止在主线程使用，只允许 Worker 里面使用。所以，这个参数轻易不应该设为false。<br>user：表示用于认证的用户名，默认为空字符串。该参数可选。<br>password：表示用于认证的密码，默认为空字符串。该参数可选</p>
</li>
</ul>
<p>注意，如果对使用过open()方法的 AJAX 请求，再次使用这个方法，等同于调用abort()，即终止请求。</p>
<ul>
<li>XMLHttpRequest.send() 方法用于实际发出 HTTP 请求。<br>它的参数是可选的，如果不带参数，就表示 HTTP 请求只有一个 URL，没有数据体，典型例子就是 GET 请求；如果带有参数，就表示除了头信息，还带有包含具体数据的信息体，典型例子就是 POST 请求。send方法的参数就是发送的数据。多种格式的数据，都可以作为它的参数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是 GET 请求的例子。</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GET'</span>,</span><br><span class="line">  <span class="string">'http://www.example.com/?id='</span> + <span class="built_in">encodeURIComponent</span>(id),</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是发送 POST 请求的例子。</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">'email='</span></span><br><span class="line">  + <span class="built_in">encodeURIComponent</span>(email)</span><br><span class="line">  + <span class="string">'&amp;password='</span></span><br><span class="line">  + <span class="built_in">encodeURIComponent</span>(password);</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">'http://www.example.com'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">xhr.send(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是发送表单数据的例子。FormData对象可以用于构造表单数据。</span></span><br><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">formData.append(<span class="string">'username'</span>, <span class="string">'张三'</span>);</span><br><span class="line">formData.append(<span class="string">'email'</span>, <span class="string">'zhangsan@example.com'</span>);</span><br><span class="line">formData.append(<span class="string">'birthDate'</span>, <span class="number">2019</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">'/register'</span>);</span><br><span class="line">xhr.send(formData);</span><br><span class="line"><span class="comment">// 上面代码中，FormData对象构造了表单数据，然后使用send()方法发送。它的效果与发送下面的表单数据是一样的。</span></span><br><span class="line">&lt;form id=<span class="string">'registration'</span> name=<span class="string">'registration'</span> action=<span class="string">'/register'</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">'text'</span> name=<span class="string">'username'</span> value=<span class="string">'张三'</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">'email'</span> name=<span class="string">'email'</span> value=<span class="string">'zhangsan@example.com'</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">'number'</span> name=<span class="string">'birthDate'</span> value=<span class="string">'1940'</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">'submit'</span> onclick=<span class="string">'return sendForm(this.form);'</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意，所有 XMLHttpRequest 的监听事件，都必须在send()方法调用之前设定。</p>
<ul>
<li>XMLHttpRequest.setRequestHeader() 方法用于设置浏览器发送的 HTTP 请求的头信息。<br>该方法必须在open()之后、send()之前调用。如果该方法多次调用，设定同一个字段，则每一次调用的值会被合并成一个单一的值发送。</li>
</ul>
<p>该方法接受两个参数。第一个参数是字符串，表示头信息的字段名，第二个参数是字段值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Length'</span>, <span class="built_in">JSON</span>.stringify(data).length);</span><br><span class="line">xhr.send(<span class="built_in">JSON</span>.stringify(data));</span><br></pre></td></tr></table></figure></p>
<ul>
<li>XMLHttpRequest.overrideMimeType() 方法用来指定 MIME 类型，覆盖服务器返回的真正的 MIME 类型，从而让浏览器进行不一样的处理。<br>举例来说，服务器返回的数据类型是text/xml，由于种种原因浏览器解析不成功报错，这时就拿不到数据了。为了拿到原始数据，我们可以把 MIME 类型改成text/plain，这样浏览器就不会去自动解析，从而我们就可以拿到原始文本了。</li>
</ul>
<p>修改服务器返回的数据类型，不是正常情况下应该采取的方法。如果希望服务器返回指定的数据类型，可以用responseType属性告诉服务器。只有在服务器无法返回某种数据类型时，才使用overrideMimeType()方法。</p>
<ul>
<li><p>XMLHttpRequest.getResponseHeader()  方法返回 HTTP 头信息指定字段的值<br>如果还没有收到服务器回应或者指定字段不存在，返回null。该方法的参数不区分大小写。如果有多个字段同名，它们的值会被连接为一个字符串，每个字段之间使用“逗号+空格”分隔。</p>
</li>
<li><p>XMLHttpRequest.getAllResponseHeaders() 方法返回一个字符串，表示服务器发来的所有 HTTP 头信息。<br>格式为字符串，每个头信息之间使用CRLF分隔（回车+换行），如果没有收到服务器回应，该属性为null。如果发生网络错误，该属性为空字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'foo.txt'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> lastModified = xhr.getResponseHeader(<span class="string">"Last-Modified"</span>);</span><br><span class="line">    <span class="keyword">var</span> headers = xhr.getAllResponseHeaders();</span><br><span class="line">     <span class="built_in">console</span>.log(headers)</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>XMLHttpRequest.abort() 方法用来终止已经发出的 HTTP 请求。<br>调用这个方法以后，readyState属性变为4，status属性变为0</p>
</li>
</ul>
<h4 id="同源限制"><a href="#同源限制" class="headerlink" title="同源限制"></a>同源限制</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><ul>
<li>含义<br>浏览器安全的基石是“同源政策”（same-origin policy）。</li>
</ul>
<p>1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。最初，它的含义是指，A 网页设置的 Cookie，B 网页不能打开，除非这两个网页“同源”。所谓“同源”指的是“三个相同”。协议相同、域名相同、端口相同。</p>
<p>举例来说，<a href="http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。" target="_blank" rel="noopener">http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。</a></p>
<ul>
<li><p>目的<br>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。同源政策是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p>
</li>
<li><p>限制范围<br>随着互联网的发展，同源政策越来越严格。目前，如果非同源，共有三种行为受到限制。<br>（1） 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。<br>（2） 无法接触非同源网页的 DOM。<br>（3） 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。</p>
</li>
</ul>
<h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。如果两个网页一级域名相同，只是次级域名不同，浏览器允许通过设置document.domain共享 Cookie。</p>
<p>举例来说，A 网页的网址是<a href="http://w1.example.com/a.html，B" target="_blank" rel="noopener">http://w1.example.com/a.html，B</a> 网页的网址是<a href="http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享" target="_blank" rel="noopener">http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享</a> Cookie。因为浏览器通过document.domain属性来检查是否同源。</p>
<p>注意，A 和 B 两个网页都需要设置document.domain属性，才能达到同源的目的。因为设置document.domain的同时，会把端口重置为null，因此如果只设置一个网页的document.domain，会导致两个网址的端口不同，还是达不到同源的目的。</p>
<p>注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexedDB 无法通过这种方法，规避同源政策，而要使用 PostMessage API。</p>
<p>另外，服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，比如.example.com。 Set-Cookie: key=value; domain=.example.com; path=/ 。这样的话，二级域名和三级域名不用做任何设置，都可以读取这个 Cookie。</p>
<h5 id="iframe-和多窗口通信"><a href="#iframe-和多窗口通信" class="headerlink" title="iframe 和多窗口通信"></a>iframe 和多窗口通信</h5><p>iframe元素可以在当前网页之中，嵌入其他网页。每个iframe元素形成自己的窗口，即有自己的window对象。iframe窗口之中的脚本，可以获得父窗口和子窗口。但是，只有在同源的情况下，父窗口和子窗口才能通信；如果跨域，就无法拿到对方的 DOM。</p>
<p>这种情况不仅适用于iframe窗口，还适用于window.open方法打开的窗口，只要跨域，父窗口与子窗口之间就无法通信。</p>
<p>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到 DOM。</p>
<p>对于完全不同源的网站，目前有两种方法，可以解决跨域窗口的通信问题。片段识别符（fragment identifier）和 跨文档通信API（Cross-document messaging）。</p>
<ul>
<li><p>片段识别符<br>片段标识符（fragment identifier）指的是，URL 的#号后面的部分，比如<a href="http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。" target="_blank" rel="noopener">http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。</a></p>
</li>
<li><p>window.postMessage()<br>跨文档通信 API（Cross-document messaging）为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。举例来说，父窗口aaa.com向子窗口bbb.com发消息，调用postMessage方法就可以了。</p>
</li>
</ul>
<p>postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即“协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父窗口打开一个子窗口</span></span><br><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open(<span class="string">'http://bbb.com'</span>, <span class="string">'title'</span>);</span><br><span class="line"><span class="comment">// 父窗口向子窗口发消息</span></span><br><span class="line">popup.postMessage(<span class="string">'Hello World!'</span>, <span class="string">'http://bbb.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子窗口向父窗口发消息</span></span><br><span class="line"><span class="built_in">window</span>.opener.postMessage(<span class="string">'Nice to see you'</span>, <span class="string">'http://aaa.com'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父窗口和子窗口都可以通过message事件，监听对方的消息。</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// event.source：发送消息的窗口</span></span><br><span class="line"><span class="comment">// event.origin: 消息发向的网址</span></span><br><span class="line"><span class="comment">// event.data: 消息内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// event.origin属性可以过滤不是发给本窗口的消息。</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, receiveMessage);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.origin !== <span class="string">'http://aaa.com'</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (event.data === <span class="string">'Hello World'</span>) &#123;</span><br><span class="line">    event.source.postMessage(<span class="string">'Hello'</span>, event.origin);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。</p>
<h5 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h5><p>同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p>
<ul>
<li>JSONP<br>JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务端改造非常小。</li>
</ul>
<p>它的基本思想是，网页通过添加一个 script元素，向服务器请求 JSON 数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，网页动态插入&lt;script&gt;元素，由它向跨源网址发出请求。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">  script.setAttribute(<span class="string">"type"</span>,<span class="string">"text/javascript"</span>);</span><br><span class="line">  script.src = src;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  addScriptTag(<span class="string">'http://example.com/ip?callback=foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Your public IP address is: '</span> + data.ip);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 上面代码通过动态添加&lt;script&gt;元素，向服务器example.com发出请求。该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于 JSONP 是必需的。服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</span></span><br><span class="line">foo(&#123;</span><br><span class="line">  <span class="string">"ip"</span>: <span class="string">"8.8.8.8"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用JSON.parse的步骤。</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>WebSocket<br>WebSocket 是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</li>
</ul>
<p>浏览器发出的 WebSocket 请求的头信息有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。正是因为有了Origin这个字段，所以 WebSocket 才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出相应回应。</p>
<ul>
<li>CORS<br>CORS 跨源资源分享，是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。相比 JSONP 只能发GET请求，CORS 允许任何类型的请求。</li>
</ul>
<h4 id="CORS-通信"><a href="#CORS-通信" class="headerlink" title="CORS 通信"></a>CORS 通信</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>CORS（Cross-origin resource sharing）跨域资源共享，是一个 W3C 标准。它允许浏览器向跨域的服务器，发出XMLHttpRequest请求，从而克服了 AJAX 只能同源使用的限制。</p>
<p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能。</p>
<p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与普通的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨域，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感知。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨域通信。</p>
<h5 id="两种请求"><a href="#两种请求" class="headerlink" title="两种请求"></a>两种请求</h5><p>CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两大条件，就属于简单请求。<br>（1）请求方法是以下三种方法之一 HEAD、GET、POST<br>（2）HTTP 的头信息不超出以下几种字段。Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type(只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain)</p>
<p>凡是不同时满足上面两个条件，就属于非简单请求。一句话，简单请求就是简单的 HTTP 方法与简单的 HTTP 头信息的结合。</p>
<p>这样划分的原因是，表单在历史上一直可以跨域发出请求。简单请求就是表单请求，浏览器沿袭了传统的处理方式，不把行为复杂化，否则开发者可能转而使用表单，规避 CORS 的限制。对于非简单请求，浏览器会采用新的处理方式。</p>
<ul>
<li>简单请求<br>对于简单请求，浏览器直接发出 CORS 请求，自动在头信息之中，添加一个Origin字段。Origin字段用来说明，本次请求来自哪个域（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</li>
</ul>
<p>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是200。</p>
<p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure></p>
<p>CORS 请求默认不包含 Cookie 信息（以及 HTTP 认证信息等），这是为了降低 CSRF 攻击的风险。但是某些场合，服务器可能需要拿到 Cookie，这时需要服务器显式指定Access-Control-Allow-Credentials字段，告诉浏览器可以发送 Cookie。同时，必须在 AJAX 请求中打开withCredentials属性。否则，即使服务器要求发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。</p>
<p>需要注意的是，如果服务器要求浏览器发送 Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨域）原网页代码中的document.cookie也无法读取服务器域名下的 Cookie。</p>
<ul>
<li>非简单请求<br>非简单请求是那种对服务器提出特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</li>
</ul>
<p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为“预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，这样可以防止服务器收到大量DELETE和PUT请求，这些传统的表单不可能跨域发出的请求。</p>
<p>“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，“预检”请求的头信息包括两个特殊字段。Access-Control-Request-Method 和 Access-Control-Request-Headers。</p>
<p>服务器收到“预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。在服务器的回应中，关键的是Access-Control-Allow-Origin字段，表示<a href="http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。" target="_blank" rel="noopener">http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</a></p>
<p>如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段，或者明确表示请求不符合条件。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</p>
<p>服务器回应的其他 CORS 相关字段如下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Max-Age: <span class="number">1728000</span>  <span class="comment">//单位为秒 即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求</span></span><br></pre></td></tr></table></figure></p>
<p>一旦服务器通过了“预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段，每次回应都必定包含的。</p>
<h4 id="Location-对象-和-URL-对象"><a href="#Location-对象-和-URL-对象" class="headerlink" title="Location 对象 和 URL 对象"></a>Location 对象 和 URL 对象</h4><h5 id="Location-对象"><a href="#Location-对象" class="headerlink" title="Location 对象"></a>Location 对象</h5><p>Location对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过window.location和document.location属性，可以拿到这个对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前网址为 http://user:passwd@www.example.com:4097/path/a.html?x=111#part1</span></span><br><span class="line"><span class="built_in">document</span>.location.href  整个 URL  <span class="comment">// "http://user:passwd@www.example.com:4097/path/a.html?x=111#part1"</span></span><br><span class="line"><span class="built_in">document</span>.location.protocol   当前 URL 的协议，包括冒号（:）  <span class="comment">// "http:"</span></span><br><span class="line"><span class="built_in">document</span>.location.host  主机，包括冒号（:）和端口（默认的<span class="number">80</span>端口和<span class="number">443</span>端口会省略）  <span class="comment">// "www.example.com:4097"</span></span><br><span class="line"><span class="built_in">document</span>.location.hostname  主机名，不包括端口   <span class="comment">// "www.example.com"</span></span><br><span class="line"><span class="built_in">document</span>.location.port  端口号   <span class="comment">// "4097"</span></span><br><span class="line"><span class="built_in">document</span>.location.pathname   URL 的路径部分，从根路径/开始   <span class="comment">// "/path/a.html"</span></span><br><span class="line"><span class="built_in">document</span>.location.search  查询字符串部分，从问号?开始。   <span class="comment">// "?x=111"</span></span><br><span class="line">document.location.hash  片段字符串部分，从#开始。   // "#part1"</span><br><span class="line"><span class="built_in">document</span>.location.username  域名前面的用户名   <span class="comment">// "user"</span></span><br><span class="line"><span class="built_in">document</span>.location.password  域名前面的密码   <span class="comment">// "passwd"</span></span><br><span class="line"><span class="built_in">document</span>.location.origin  URL 的协议、主机名和端口   只读，其他属性都可写 <span class="comment">// "http://user:passwd@www.example.com:4097"</span></span><br></pre></td></tr></table></figure></p>
<p>location.origin 只有改属性是只读的，其他属性都可写。<br>Location.href属性是浏览器唯一允许跨域写入的属性，即非同源的窗口可以改写另一个窗口（比如子窗口与父窗口）的Location.href属性，导致后者的网址跳转。<br>直接改写location，相当于写入href属性。</p>
<h5 id="URL-的编码和解码"><a href="#URL-的编码和解码" class="headerlink" title="URL 的编码和解码"></a>URL 的编码和解码</h5><p>网页的 URL 只能包含合法的字符。合法字符分成两类。<br>URL 元字符：分号（;），逗号（,），斜杠（/），问号（?），冒号（:），at（@），&amp;，等号（=），加号（+），美元符号（$），井号（#）<br>语义字符：a-z，A-Z，0-9，连词号（-），下划线（_），点（.），感叹号（!），波浪线（~），星号（*），单引号（’），圆括号（()）<br>除了以上字符，其他字符出现在 URL 之中都必须转义，规则是根据操作系统的默认编码，将每个字节转为百分号（%）加上两个大写的十六进制字母。</p>
<p>JavaScript 提供四个 URL 的编码/解码方法。</p>
<ul>
<li>encodeURI()<br>用于转码整个 URL。它的参数是一个字符串，代表整个 URL。它会将元字符和语义字符之外的字符，都进行转义。</li>
<li>encodeURIComponent()<br>用于转码 URL 的组成部分，会转码除了语义字符之外的所有字符，即元字符也会被转码。所以，它不能用于转码整个 URL。它接受一个参数，就是 URL 的片段。</li>
<li>decodeURI()<br>用于整个 URL 的解码。它是encodeURI()方法的逆运算。它接受一个参数，就是转码后的 URL。</li>
<li>decodeURIComponent()<br>用于URL 片段的解码。它是encodeURIComponent()方法的逆运算。它接受一个参数，就是转码后的 URL 片段。</li>
</ul>
<h4 id="ArrayBuffer-对象-和-Blob-对象"><a href="#ArrayBuffer-对象-和-Blob-对象" class="headerlink" title="ArrayBuffer 对象 和 Blob 对象"></a>ArrayBuffer 对象 和 Blob 对象</h4><ul>
<li>ArrayBuffer 对象<br>ArrayBuffer 对象表示一段二进制数据，用来模拟内存里面的数据。通过这个对象，JavaScript 可以读写二进制数据。这个对象可以看作内存数据的表达。</li>
</ul>
<p>浏览器原生提供ArrayBuffer()构造函数，用来生成实例。它接受一个整数作为参数，表示这段二进制数据占用多少个字节。</p>
<p>var buffer = new ArrayBuffer(8);  实例对象buffer占用8个字节。</p>
<p>ArrayBuffer 对象有实例方法slice()，用来复制一部分内存</p>
<ul>
<li>Blob 对象<br>Blob (Binary Large Object)二进制大型对象，表示一个二进制文件的数据内容，比如一个图片文件的内容就可以通过 Blob 对象读写。它通常用来读写文件。它与 ArrayBuffer 的区别在于，它用于操作二进制文件，而 ArrayBuffer 用于操作内存。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器原生提供Blob()构造函数，用来生成实例对象。</span></span><br><span class="line"><span class="keyword">new</span> Blob(array [, options])</span><br><span class="line"><span class="comment">// Blob构造函数接受两个参数。第一个参数是数组，成员是字符串或二进制对象，表示新生成的Blob实例对象的内容；第二个参数是可选的，是一个配置对象，目前只有一个属性type，它的值是一个字符串，表示数据的 MIME 类型，默认是空字符串。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Blob具有两个实例属性size和type，分别返回数据的大小和类型。</span></span><br><span class="line"><span class="keyword">var</span> htmlFragment = [<span class="string">'&lt;a id="a"&gt;&lt;b id="b"&gt;hey!&lt;/b&gt;&lt;/a&gt;'</span>];</span><br><span class="line"><span class="keyword">var</span> myBlob = <span class="keyword">new</span> Blob(htmlFragment, &#123;<span class="attr">type</span> : <span class="string">'text/html'</span>&#125;);</span><br><span class="line">myBlob.size <span class="comment">// 32</span></span><br><span class="line">myBlob.type <span class="comment">// "text/html"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Blob具有一个实例方法slice，用来拷贝原来的数据，返回的也是一个Blob实例。</span></span><br><span class="line">myBlob.slice(start，end, contentType)</span><br><span class="line"><span class="comment">// 三个可选参数。起始的字节位置（默认为0）、结束的字节位置（默认为size属性的值，该位置本身将不包含在拷贝的数据之中）、新实例的数据类型（默认为空字符串）。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载文件</span></span><br><span class="line"><span class="comment">// AJAX 请求时，如果指定responseType属性为blob，下载下来的就是一个 Blob 对象。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBlob</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">'GET'</span>, url);</span><br><span class="line">  xhr.responseType = <span class="string">'blob'</span>;</span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(xhr.response);</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码中，xhr.response拿到的就是一个 Blob 对象。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 URL </span></span><br><span class="line"><span class="comment">// 浏览器允许使用URL.createObjectURL()方法，针对 Blob 对象生成一个临时 URL，以便于某些 API 使用。这个 URL 以blob://开头，表明对应一个 Blob 对象，协议头后面是一个识别符，用来唯一对应内存里面的 Blob 对象。这一点与data://URL（URL 包含实际数据）和file://URL（本地文件系统里面的文件）都不一样。</span></span><br><span class="line"><span class="comment">// 浏览器处理 Blob URL 就跟普通的 URL 一样，如果 Blob 对象不存在，返回404状态码；如果跨域请求，返回403状态码。Blob URL 只对 GET 请求有效，如果请求成功，返回200状态码。由于 Blob URL 就是普通 URL，因此可以下载。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="comment">// 取得 Blob 对象以后，可以通过FileReader对象，读取 Blob 对象的内容，即文件内容。</span></span><br><span class="line"><span class="comment">// FileReader 对象提供四个方法，处理 Blob 对象。Blob 对象作为参数传入这些方法，然后以指定的格式返回。</span></span><br><span class="line">FileReader.readAsText()：返回文本，需要指定文本编码，默认为 UTF<span class="number">-8</span>。</span><br><span class="line">FileReader.readAsArrayBuffer()：返回 <span class="built_in">ArrayBuffer</span> 对象。</span><br><span class="line">FileReader.readAsDataURL()：返回 Data URL。</span><br><span class="line">FileReader.readAsBinaryString()：返回原始的二进制字符串</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是FileReader.readAsArrayBuffer()方法的例子，用于读取二进制文件。</span></span><br><span class="line">&lt;input type=<span class="string">"file"</span> onchange=<span class="string">"typefile(this.files[0])"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typefile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 文件开头的四个字节，生成一个 Blob 对象</span></span><br><span class="line">  <span class="keyword">var</span> slice = file.slice(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">  <span class="comment">// 读取这四个字节</span></span><br><span class="line">  reader.readAsArrayBuffer(slice);</span><br><span class="line">  reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = reader.result;</span><br><span class="line">    <span class="comment">// 将这四个字节的内容，视作一个32位整数</span></span><br><span class="line">    <span class="keyword">var</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer);</span><br><span class="line">    <span class="keyword">var</span> magic = view.getUint32(<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 根据文件的前四个字节，判断它的类型</span></span><br><span class="line">    <span class="keyword">switch</span>(magic) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x89504E47</span>: file.verified_type = <span class="string">'image/png'</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x47494638</span>: file.verified_type = <span class="string">'image/gif'</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x25504446</span>: file.verified_type = <span class="string">'application/pdf'</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x504b0304</span>: file.verified_type = <span class="string">'application/zip'</span>; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(file.name, file.verified_type);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="FormData-对象"><a href="#FormData-对象" class="headerlink" title="FormData 对象"></a>FormData 对象</h4><p>表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成过程，构造和编辑表单键值对，然后通过XMLHttpRequest.send()方法发送。浏览器原生提供了 FormData 对象来完成这项工作。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FormData 首先是一个构造函数，用来生成实例。参数是一个表单元素，这个参数是可选的。如果省略参数，就表示一个空的表单，否则就会处理表单元素里面的键值对。</span></span><br><span class="line"><span class="keyword">var</span> formdata = <span class="keyword">new</span> FormData(form);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">var</span> myForm = <span class="built_in">document</span>.getElementById(<span class="string">'myForm'</span>);</span><br><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData(myForm);</span><br><span class="line"><span class="comment">// 设置、获取某个控件的值</span></span><br><span class="line">formData.set(<span class="string">'username'</span>, <span class="string">'张三'</span>);</span><br><span class="line">formData.get(<span class="string">'username'</span>) <span class="comment">// "张三"</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>实例方法<br>FormData 提供以下实例方法。<br>FormData.get(key)：获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。<br>FormData.getAll(key)：返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。<br>FormData.set(key, value)：设置指定键名的键值，参数为键名。如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。如果第二个参数是文件，还可以使用第三个参数，表示文件名。<br>FormData.delete(key)：删除一个键值对，参数为键名。<br>FormData.append(key, value)：添加一个键值对。如果键名重复，则会生成两个相同键名的键值对。如果第二个参数是文件，还可以使用第三个参数，表示文件名。<br>FormData.has(key)：返回一个布尔值，表示是否具有该键名的键值对。<br>FormData.keys()：返回一个遍历器对象，用于for…of循环遍历所有的键名。<br>FormData.values()：返回一个遍历器对象，用于for…of循环遍历所有的键值。<br>FormData.entries()：返回一个遍历器对象，用于for…of循环遍历所有的键值对。如果直接用for…of循环遍历 FormData 实例，默认就会调用这个方法。</p>
</li>
<li><p>文件上传<br>用户上传文件，也是通过表单。具体来说，就是通过文件输入框选择本地文件，提交表单的时候，浏览器就会把这个文件发送到服务器。</p>
</li>
</ul>
<p>此外，还需要将表单 form 元素的method属性设为POST，enctype属性设为multipart/form-data。其中，enctype属性决定了 HTTP 头信息的Content-Type字段的值，默认情况下这个字段的值是application/x-www-form-urlencoded，但是文件上传的时候要改成multipart/form-data。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"file"</span> id=<span class="string">"file"</span> name=<span class="string">"myFile"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;form method=<span class="string">"post"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">"file"</span>&gt;选择一个文件&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">    &lt;input type="file" id="file" name="myFile" multiple /</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;input type="submit" id="submit" name="submit_button" value="上传" /</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>form&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的 HTML 代码中，file 控件的multiple属性，指定可以一次选择多个文件；如果没有这个属性，则一次只能选择一个文件。</span></span><br><span class="line"><span class="keyword">var</span> fileSelect = <span class="built_in">document</span>.getElementById(<span class="string">'file'</span>);</span><br><span class="line"><span class="keyword">var</span> files = fileSelect.files;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后，新建一个 FormData 实例对象，模拟发送到服务器的表单数据，把选中的文件添加到这个对象上面。</span></span><br><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> file = files[i];</span><br><span class="line">  <span class="comment">// 只上传图片文件</span></span><br><span class="line">  <span class="keyword">if</span> (!file.type.match(<span class="string">'image.*'</span>)) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  formData.append(<span class="string">'photos[]'</span>, file, file.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后，使用 Ajax 向服务器上传文件。</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">'handler.php'</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.status !== <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'An error occurred!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send(formData);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了发送 FormData 实例，也可以直接 AJAX 发送文件。</span></span><br><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span>.getElementById(<span class="string">'test-input'</span>).files[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'POST'</span>, <span class="string">'myserver/uploads'</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, file.type);</span><br><span class="line">xhr.send(file);</span><br></pre></td></tr></table></figure></p>
<h4 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h4><p>现有的浏览器数据储存方案，都不适合储存大量数据：Cookie 的大小不超过 4KB，且每次请求都会发送回服务器；LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。所以，需要一种新的解决方案，这就是 IndexedDB 诞生的背景。</p>
<p>IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。</p>
<p>IndexedDB 具有以下特点。<br>（1）键值对储存。 IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以“键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。<br>（2）异步。 IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。<br>（3）支持事务。 IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。<br>（4）同源限制 IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。<br>（5）储存空间大 IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。<br>（6）支持二进制储存。 IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）</p>
<p>IndexedDB 是一个比较复杂的 API，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个 API，就是学习它的各种对象接口。<br>数据库：IDBDatabase 对象<br>对象仓库：IDBObjectStore 对象<br>索引： IDBIndex 对象<br>事务： IDBTransaction 对象<br>操作请求：IDBRequest 对象<br>指针： IDBCursor 对象<br>主键集合：IDBKeyRange 对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开数据库，使用 IndexedDB 的第一步是打开数据库，使用indexedDB.open()方法。</span></span><br><span class="line"><span class="keyword">var</span> request = <span class="built_in">window</span>.indexedDB.open(databaseName, version);</span><br><span class="line"><span class="comment">// 这个方法接受两个参数，第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在，就会新建数据库。第二个参数是整数，表示数据库的版本。如果省略，打开已有数据库时，默认为当前版本；新建数据库时，默认为1。</span></span><br><span class="line"><span class="comment">// indexedDB.open()方法返回一个 IDBRequest 对象。这个对象通过三种事件error、success、upgradeneeded，处理打开数据库的操作结果。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建数据库，与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在upgradeneeded事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件。通常，新建数据库以后，第一件事是新建对象仓库（即新建表）。</span></span><br><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  db = event.target.result;</span><br><span class="line">  <span class="keyword">var</span> objectStore;</span><br><span class="line">  <span class="keyword">if</span> (!db.objectStoreNames.contains(<span class="string">'person'</span>)) &#123;</span><br><span class="line">    objectStore = db.createObjectStore(<span class="string">'person'</span>, &#123; <span class="attr">keyPath</span>: <span class="string">'id'</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建对象仓库以后，下一步可以新建索引。</span></span><br><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  db = event.target.result;</span><br><span class="line">  <span class="keyword">var</span> objectStore = db.createObjectStore(<span class="string">'person'</span>, &#123; <span class="attr">keyPath</span>: <span class="string">'id'</span> &#125;);</span><br><span class="line">  objectStore.createIndex(<span class="string">'name'</span>, <span class="string">'name'</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  objectStore.createIndex(<span class="string">'email'</span>, <span class="string">'email'</span>, &#123; <span class="attr">unique</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增数据，指的是向对象仓库写入数据记录。这需要通过事务完成。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> request = db.transaction([<span class="string">'person'</span>], <span class="string">'readwrite'</span>)</span><br><span class="line">    .objectStore(<span class="string">'person'</span>)</span><br><span class="line">    .add(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'张三'</span>, <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">email</span>: <span class="string">'zhangsan@example.com'</span> &#125;);</span><br><span class="line"></span><br><span class="line">  request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据写入成功'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据写入失败'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add();</span><br><span class="line"><span class="comment">// 上面代码中，写入数据需要新建一个事务。新建时必须指定表格名称和操作模式（“只读”或“读写”）。新建事务以后，通过IDBTransaction.objectStore(name)方法，拿到 IDBObjectStore 对象，再通过表格对象的add()方法，向表格写入一条记录。写入操作是一个异步操作，通过监听连接对象的success事件和error事件，了解是否写入成功。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据，也是通过事务完成。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> transaction = db.transaction([<span class="string">'person'</span>]);</span><br><span class="line">   <span class="keyword">var</span> objectStore = transaction.objectStore(<span class="string">'person'</span>);</span><br><span class="line">   <span class="keyword">var</span> request = objectStore.get(<span class="number">1</span>);  <span class="comment">// objectStore.get()方法用于读取数据，参数是主键的值。</span></span><br><span class="line"></span><br><span class="line">   request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'事务失败'</span>);</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params"> event</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (request.result) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Name: '</span> + request.result.name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Age: '</span> + request.result.age);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Email: '</span> + request.result.email);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'未获得数据记录'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历数据，表格的所有记录，要使用指针对象 IDBCursor。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> objectStore = db.transaction(<span class="string">'person'</span>).objectStore(<span class="string">'person'</span>);</span><br><span class="line"></span><br><span class="line">   objectStore.openCursor().onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> cursor = event.target.result;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'Id: '</span> + cursor.key);</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'Name: '</span> + cursor.value.name);</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'Age: '</span> + cursor.value.age);</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'Email: '</span> + cursor.value.email);</span><br><span class="line">       cursor.continue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'没有更多数据了！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新数据,要使用IDBObject.put()方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> request = db.transaction([<span class="string">'person'</span>], <span class="string">'readwrite'</span>)</span><br><span class="line">    .objectStore(<span class="string">'person'</span>)</span><br><span class="line">    .put(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'李四'</span>, <span class="attr">age</span>: <span class="number">35</span>, <span class="attr">email</span>: <span class="string">'lisi@example.com'</span> &#125;);</span><br><span class="line"></span><br><span class="line">  request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据更新成功'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据更新失败'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">update();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据，IDBObjectStore.delete()方法用于删除记录。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> request = db.transaction([<span class="string">'person'</span>], <span class="string">'readwrite'</span>)</span><br><span class="line">    .objectStore(<span class="string">'person'</span>)</span><br><span class="line">    .delete(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据删除成功'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">remove();</span><br></pre></td></tr></table></figure></p>
<h4 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h4><p>JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。</p>
<p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务可以交由 Worker 线程执行，主线程（通常负责 UI 交互）能够保持流畅，不会被阻塞或拖慢。</p>
<p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<p>Web Worker 有以下几个使用注意点。<br>（1）同源限制。分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。<br>（2）DOM 限制。Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以使用navigator对象和location对象。<br>（3）全局对象限制。Worker 的全局对象WorkerGlobalScope，不同于网页的全局对象Window，很多接口拿不到。比如，理论上 Worker 线程不能使用console.log，因为标准里面没有提到 Worker 的全局对象存在console接口，只定义了Navigator接口和Location接口。不过，浏览器实际上支持 Worker 线程使用console.log，保险的做法还是不使用这个方法。<br>（4）通信联系。Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。<br>（5）脚本限制。Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。<br>（6）文件限制。Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器原生提供Worker()构造函数，用来供主线程生成 Worker 线程。</span></span><br><span class="line"><span class="keyword">var</span> myWorker = <span class="keyword">new</span> Worker(jsUrl, options);</span><br><span class="line"><span class="comment">// Worker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"><span class="keyword">var</span> myWorker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>, &#123; <span class="attr">name</span> : <span class="string">'myWorker'</span> &#125;);</span><br><span class="line"><span class="comment">// Worker 线程</span></span><br><span class="line">self.name <span class="comment">// myWorker</span></span><br><span class="line"></span><br><span class="line">Worker()构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下。</span><br><span class="line">Worker.onerror：指定 error 事件的监听函数。</span><br><span class="line">Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。</span><br><span class="line">Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</span><br><span class="line">Worker.postMessage()：向 Worker 线程发送消息。</span><br><span class="line">Worker.terminate()：立即终止 Worker 线程</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    
    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;margin: 50px auto 0;">------------- Article Ends <i class="fa fa-paw"></i> Thanks For Reading -------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JS/" rel="tag"># JS</a>
          
            <a href="/tags/基础/" rel="tag"># 基础</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/19/JS/一行能装逼的JS代码/" rel="next" title="一行能装逼的JS代码">
                <i class="fa fa-chevron-left"></i> 一行能装逼的JS代码
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/26/Vue/你问我答-vue/" rel="prev" title="你问我答 vue">
                你问我答 vue <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Supremeyh">
            
              <p class="site-author-name" itemprop="name">Supremeyh</p>
              <p class="site-description motion-element" itemprop="description">Amicus Plato,Amicus Aristotle,Sed Magis Amicus VERITAS.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/Supremeyh_" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com/" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/supremeyh" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://hexo.io/zh-cn/" title="Hexo" target="_blank">Hexo</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://theme-next.iissnan.com/getting-started.html" title="NexT" target="_blank">NexT</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6、ES7、ES8、ES9、ES10新特性一览"><span class="nav-number">2.</span> <span class="nav-text">ES6、ES7、ES8、ES9、ES10新特性一览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本语法"><span class="nav-number">3.</span> <span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">4.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#七种数据类型"><span class="nav-number">4.1.</span> <span class="nav-text">七种数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#typeof-运算符"><span class="nav-number">4.2.</span> <span class="nav-text">typeof 运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#null-undefined-和布尔值"><span class="nav-number">4.3.</span> <span class="nav-text">null, undefined 和布尔值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数值"><span class="nav-number">4.4.</span> <span class="nav-text">数值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串"><span class="nav-number">4.5.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象"><span class="nav-number">4.6.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对象的引用"><span class="nav-number">4.6.1.</span> <span class="nav-text">对象的引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#属性的操作"><span class="nav-number">4.6.2.</span> <span class="nav-text">属性的操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组"><span class="nav-number">4.7.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数"><span class="nav-number">4.8.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#函数的声明"><span class="nav-number">4.8.1.</span> <span class="nav-text">函数的声明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算符"><span class="nav-number">5.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#算术运算符"><span class="nav-number">5.1.</span> <span class="nav-text">算术运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#布尔运算符"><span class="nav-number">5.2.</span> <span class="nav-text">布尔运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二进制位运算符"><span class="nav-number">5.3.</span> <span class="nav-text">二进制位运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void-运算符"><span class="nav-number">5.4.</span> <span class="nav-text">void 运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#逗号运算符"><span class="nav-number">5.5.</span> <span class="nav-text">逗号运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运算顺序"><span class="nav-number">5.6.</span> <span class="nav-text">运算顺序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型的转换"><span class="nav-number">6.</span> <span class="nav-text">数据类型的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#强制转换"><span class="nav-number">6.1.</span> <span class="nav-text">强制转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自动转换"><span class="nav-number">6.2.</span> <span class="nav-text">自动转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误处理机制"><span class="nav-number">7.</span> <span class="nav-text">错误处理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Error-实例对象"><span class="nav-number">7.1.</span> <span class="nav-text">Error 实例对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原生错误类型"><span class="nav-number">7.2.</span> <span class="nav-text">原生错误类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编程风格"><span class="nav-number">8.</span> <span class="nav-text">编程风格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-对象与控制台"><span class="nav-number">9.</span> <span class="nav-text">console 对象与控制台</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#console-对象的静态方法"><span class="nav-number">9.1.</span> <span class="nav-text">console 对象的静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#控制台命令行-API"><span class="nav-number">9.2.</span> <span class="nav-text">控制台命令行 API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#debugger-语句"><span class="nav-number">9.3.</span> <span class="nav-text">debugger 语句</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标准库"><span class="nav-number">10.</span> <span class="nav-text">标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-对象"><span class="nav-number">10.1.</span> <span class="nav-text">Object 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Object-工具方法"><span class="nav-number">10.1.1.</span> <span class="nav-text">Object() 工具方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#new-Object-构造函数"><span class="nav-number">10.1.2.</span> <span class="nav-text">new Object() 构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Object-的静态方法"><span class="nav-number">10.1.3.</span> <span class="nav-text">Object 的静态方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Object-的实例方法"><span class="nav-number">10.1.4.</span> <span class="nav-text">Object 的实例方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性描述对象"><span class="nav-number">10.2.</span> <span class="nav-text">属性描述对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-对象"><span class="nav-number">10.3.</span> <span class="nav-text">Array 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#构造函数-new-Array"><span class="nav-number">10.3.1.</span> <span class="nav-text">构造函数 new Array()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#静态方法"><span class="nav-number">10.3.2.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实例方法"><span class="nav-number">10.3.3.</span> <span class="nav-text">实例方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#包装对象"><span class="nav-number">10.4.</span> <span class="nav-text">包装对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Number-对象"><span class="nav-number">10.5.</span> <span class="nav-text">Number 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-对象"><span class="nav-number">10.6.</span> <span class="nav-text">String 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Math-对象"><span class="nav-number">10.7.</span> <span class="nav-text">Math 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Date-对象"><span class="nav-number">10.8.</span> <span class="nav-text">Date 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RegExp-对象"><span class="nav-number">10.9.</span> <span class="nav-text">RegExp 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON-对象"><span class="nav-number">10.10.</span> <span class="nav-text">JSON 对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象编程"><span class="nav-number">11.</span> <span class="nav-text">面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实例对象与-new-命令"><span class="nav-number">11.1.</span> <span class="nav-text">实例对象与 new 命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对象是什么"><span class="nav-number">11.1.1.</span> <span class="nav-text">对象是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#构造函数"><span class="nav-number">11.1.2.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#new-命令"><span class="nav-number">11.1.3.</span> <span class="nav-text">new 命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#new-命令的原理"><span class="nav-number">11.1.4.</span> <span class="nav-text">new 命令的原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#new-target"><span class="nav-number">11.1.5.</span> <span class="nav-text">new.target</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Object-create-创建实例对象"><span class="nav-number">11.1.6.</span> <span class="nav-text">Object.create() 创建实例对象</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this-关键字"><span class="nav-number">11.2.</span> <span class="nav-text">this 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的继承"><span class="nav-number">11.3.</span> <span class="nav-text">对象的继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#原型对象概述"><span class="nav-number">11.3.1.</span> <span class="nav-text">原型对象概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#instanceof-运算符"><span class="nav-number">11.3.2.</span> <span class="nav-text">instanceof 运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#构造函数的继承"><span class="nav-number">11.3.3.</span> <span class="nav-text">构造函数的继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多重继承"><span class="nav-number">11.3.4.</span> <span class="nav-text">多重继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#模块"><span class="nav-number">11.3.5.</span> <span class="nav-text">模块</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-对象的相关方法"><span class="nav-number">11.4.</span> <span class="nav-text">Object 对象的相关方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#严格模式"><span class="nav-number">11.5.</span> <span class="nav-text">严格模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#设计目的"><span class="nav-number">11.5.1.</span> <span class="nav-text">设计目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#启用方法"><span class="nav-number">11.5.2.</span> <span class="nav-text">启用方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#显式报错"><span class="nav-number">11.5.3.</span> <span class="nav-text">显式报错</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#增强的安全措施"><span class="nav-number">11.5.4.</span> <span class="nav-text">增强的安全措施</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#静态绑定"><span class="nav-number">11.5.5.</span> <span class="nav-text">静态绑定</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步操作"><span class="nav-number">12.</span> <span class="nav-text">异步操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#异步操作概述"><span class="nav-number">12.1.</span> <span class="nav-text">异步操作概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#单线程模型"><span class="nav-number">12.1.1.</span> <span class="nav-text">单线程模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#同步任务和异步任务"><span class="nav-number">12.1.2.</span> <span class="nav-text">同步任务和异步任务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#任务队列和事件循环"><span class="nav-number">12.1.3.</span> <span class="nav-text">任务队列和事件循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#异步操作的模式"><span class="nav-number">12.1.4.</span> <span class="nav-text">异步操作的模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#异步操作的流程控制"><span class="nav-number">12.1.5.</span> <span class="nav-text">异步操作的流程控制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定时器"><span class="nav-number">12.2.</span> <span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-对象"><span class="nav-number">12.3.</span> <span class="nav-text">Promise 对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM"><span class="nav-number">13.</span> <span class="nav-text">DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DOM-概述"><span class="nav-number">13.1.</span> <span class="nav-text">DOM 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-接口"><span class="nav-number">13.2.</span> <span class="nav-text">Node 接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件"><span class="nav-number">14.</span> <span class="nav-text">事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#EventTarget-接口"><span class="nav-number">14.1.</span> <span class="nav-text">EventTarget 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件模型"><span class="nav-number">14.2.</span> <span class="nav-text">事件模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#监听函数"><span class="nav-number">14.2.1.</span> <span class="nav-text">监听函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Event-对象"><span class="nav-number">14.3.</span> <span class="nav-text">Event 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#鼠标事件"><span class="nav-number">14.4.</span> <span class="nav-text">鼠标事件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BOM"><span class="nav-number">15.</span> <span class="nav-text">BOM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#浏览器环境概述"><span class="nav-number">15.1.</span> <span class="nav-text">浏览器环境概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XMLHttpRequest-对象"><span class="nav-number">15.2.</span> <span class="nav-text">XMLHttpRequest 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同源限制"><span class="nav-number">15.3.</span> <span class="nav-text">同源限制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#概述-1"><span class="nav-number">15.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Cookie"><span class="nav-number">15.3.2.</span> <span class="nav-text">Cookie</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#iframe-和多窗口通信"><span class="nav-number">15.3.3.</span> <span class="nav-text">iframe 和多窗口通信</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AJAX"><span class="nav-number">15.3.4.</span> <span class="nav-text">AJAX</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CORS-通信"><span class="nav-number">15.4.</span> <span class="nav-text">CORS 通信</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#简介"><span class="nav-number">15.4.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#两种请求"><span class="nav-number">15.4.2.</span> <span class="nav-text">两种请求</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Location-对象-和-URL-对象"><span class="nav-number">15.5.</span> <span class="nav-text">Location 对象 和 URL 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Location-对象"><span class="nav-number">15.5.1.</span> <span class="nav-text">Location 对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#URL-的编码和解码"><span class="nav-number">15.5.2.</span> <span class="nav-text">URL 的编码和解码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayBuffer-对象-和-Blob-对象"><span class="nav-number">15.6.</span> <span class="nav-text">ArrayBuffer 对象 和 Blob 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FormData-对象"><span class="nav-number">15.7.</span> <span class="nav-text">FormData 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IndexedDB"><span class="nav-number">15.8.</span> <span class="nav-text">IndexedDB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Web-Worker"><span class="nav-number">15.9.</span> <span class="nav-text">Web Worker</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Supremeyh</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <!-- 页面点击出现小红心 -->
  
    <script type="text/javascript" src="/js/src/clicklove.js"></script>
  

  <!-- 页面点击爆炸效果 -->
  

</body>
</html>

