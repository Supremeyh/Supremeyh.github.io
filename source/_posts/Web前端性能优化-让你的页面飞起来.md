---
title: Web前端性能优化 - 让你的页面飞起来
comments: true
date: 2019-06-24 20:30:00
categories: 性能
tags: ['web', '性能优化']
---

> 从构建、浏览器渲染、缓存、PWA、服务端优化等多方面，梳理前端性能优化的技术点、综合分析技术的原理，根据不同的业务场景选择合适的性能优化点进行应用，最终为你的网站带来显著的速度提升和整体性能提升。


资源合并压缩、图片格式及加载方式的优化
CSS和JS的装载与执行
重绘与回流
浏览器存储
PWA，缓存
SSR服务端渲染
构建层减少资源请求的大小和数量
优化浏览器渲染提升动画体验
显著提升网站二次访问体验
首屏渲染性能优化
![总览](/images/performance-optimization.webp)

## 基础
web 前端本质上是一种 GUI 软件，采用 BS 架构，经历开发到发布到 CDN 或 webserver , 通过 浏览器 http 请求返回资源。

### 资源合并与压缩
关键: 减少 http 请求数量、减少请求资源大小

#### http 清求的过程
深入理解 http  请求过程，是 前端性能优化的核心。

用户在浏览器输入 url -> DNS解析(浏览器未过期缓存、操作系统、hosts文件、首选DNS服务器等) -> 与服务器建立连接，发起TCP的3次握手 --> 发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源 --> 浏览器对页面进行渲染呈现给用户

* http 是什么
通俗来讲，他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接。

* 三次握手
![TCP三次握手](/images/tcp-shakehands.jpeg)
客户端的请求到达服务器，首先就是建立TCP连接。

第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

* 为什么要三次握手
防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。解决网络中存在延迟的重复分组的问题，同时防止服务器端的一直等待而浪费资源

* TCP四次挥手
当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。

第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；
第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

* 为什么要四次分手
TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。

* 为什么HTTP协议要基于TCP来实现
TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。

#### 内容优化
(1)减少HTTP请求数:这条策略是最重要最有效的
(2)减少DNS查找
(3)避免重定向
(4)使用Ajax缓存
(5)延迟加载组件,预加载组件
(6)减少DOM元素数量:页面中存在大量DOM元素,会导致javascript遍历DOM的效率变慢。
(7)最小化iframe的数量：iframes 提供了一个简单的方式把一个网站的内容嵌入到另一个网站中。但其创建速度比其他包括js和css的DOM元素的创建慢了1-2个数量级。
(8)避免404：HTTP请求时间消耗是很大的，因此使用HTTP请求来获得一个没有用处的响应（例如404没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。

#### html压缩
压缩在文本文件中有意义，但在 html 中不显示的字符，如 空格、制表符、换行符，注释。

可以使用在线网站、nodejs提供的 html-minifier、后端模板引擎渲染压缩
#### css 优化
无效代码删除, CSS 代码语义合并
(1)将CSS代码放在HTML页面的顶部
(2)避免使用CSS表达式
(3)使用 link 来代替@import
(4)避免使用Filters
#### js 优化
(1)将JavaScript脚本放在页面的底部。
(2)将JavaScript和CSS作为外部文件来引用：在实际应用中使用外部文件可以提高页面速度，因为JavaScript和CSS文件都能在浏览器中产生缓存。
(3)缩小JavaScript，无效字符删除、剔除注释、代码语义合并，可以使用 uglifyjs 压缩。
(4)删除重复的脚本
(5)最小化DOM的访问：使用JavaScript访问DOM元素比较慢。
(6)开发智能的事件处理程序
(7)javascript代码注意：谨慎使用with,避免使用eval Function函数,减少作用域链查找。

#### 图像优化
(1)优化图片大小
(2)通过CSS Sprites优化图片
(3)不要在HTML中使用缩放图片
(4)favicon.ico要小而且可缓存

#### Cookie优化
(1)减小Cookie大小
(2)针对Web组件使用域名无关的Cookie

#### 服务器优化
(1)使用内容分发网络（CDN）：把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。
(2)GZIP压缩
(3)设置ETag：ETags（Entity tags，实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制。
(4)提前刷新缓冲区
(5)对Ajax请求使用GET方法
(6)避免空的图像src

#### 文件合并
使用 keep-alive，公共库合并、不同页面的合并。减少丢包和网络请求延迟。但要适当使用，避免 首屏渲染问题

#### 开启 gzip



### 构建层面
在线网站或结合 webpack、fis3 等构建工具，自动化地进行资源的打包和压缩

### 图片层面
深入不同格式图片的编解码过程结合业务场景选择合适的图片格式：png、svg、webp

## 进阶
### 缓存
缓存相关的浏览器和服务端能力

### 浏览器渲染
Html、JavaScript 和 CSS 在浏览器端的加载机制、重绘与回流渲染树的生成

### 浏览器存储
LocalStorage、Cookie、IndexedDB、sessionStorage PWA、 Service Worker

## 服务器
### SSR
基于Node.js结合Vue-SSR和PWA实战，讲解Vue-SSR和PWA的原理实现，核心解决Vue框架的首屏渲染问题





