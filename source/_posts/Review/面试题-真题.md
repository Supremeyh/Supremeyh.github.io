---
title: 面试题 真题
comments: true
date: 2019-08-03 16:48:51
categories: Review
tags: ['Review', 'JS']
---

### RL
1. 什么是盒模型，盒模型都由什么组成
页面渲染时，dom 元素所采用的 布局模型。可通过box-sizing进行设置。
包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。
IE模型，box-sizing 为 border-box，width/height = content + padding + border
标准模型，box-sizing 为 content-box，width/height = content

2. 原生 js 如何 添加和移除 dom 元素
element.appendChild(aChild);
parentNode.insertBefore(newNode, referenceNode)

node.removeChild(child)

3. CSS Hack，有哪些形式
针对不同的浏览器去写不同的CSS样式，从而让各浏览器能达到一致的渲染效果

有3种表现形式，选择器前缀法、css属性前缀法、IE条件注释法
```css
/* 选择器前缀法 */
/* 
*html *前缀只对IE6生效
*+html *+前缀只对IE7生效
@media screen\9{...}只对IE6/7生效
@media \0screen {body { background: red; }}只对IE8有效
@media \0screen\,screen\9{body { background: blue; }}只对IE6/7/8有效
@media screen\0 {body { background: green; }} 只对IE8/9/10有效
@media screen and (min-width:0\0) {body { background: gray; }} 只对IE9/10有效
@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }} 只对IE10有效 
*/


/* css属性前缀法 */
/* 
“-″减号是IE6专有的hack
“\9″ IE6/IE7/IE8/IE9/IE10都生效
“\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack
“\9\0″ 只对IE9/IE10生效，是IE9/10的hack 
*/

.hack {
background-color:red; /* All browsers */
	background-color:blue !important;/* All browsers but IE6 */
	*background-color:black; /* IE6, IE7 */
	+background-color:yellow;/* IE6, IE7*/
	background-color:gray\9; /* IE6, IE7, IE8, IE9, IE10 */
	background-color:purple\0; /* IE8, IE9, IE10 */
	background-color:orange\9\0;/*IE9, IE10*/
	_background-color:green; /* Only works in IE6 */
	*+background-color:pink; /*  WARNING: Only works in IE7 ? Is it right? */
}


/* IE条件注释法 */
<!--[if gte IE 6]>
  这段文字只在IE6及以上浏览器显示
<![endif]-->
```

4. 事件委托
概念：利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件

原理：事件流分为捕获、目标、冒泡3个阶段。事件开始时由嵌套层次最深的节点开始接收，然后逐级向其父级节点传播。

优点：减少与dom的交互次数，提高代码性能。动态生成DOM元素时，可通过事件代理给新增的元素添加事件函数。

适用：适合用事件委托的事件 click，mousedown，mouseup，keydown，keyup，keypress。

局限性：事件必须冒泡，如focus、blur本身就没用冒泡的特性。mouseover和mouseout虽然也有事件冒泡，但要经常计算它们的位置，处理起来不太容易。

5. ajax 原理、使用、缺点
一种创建交互式网页应用的开发技术，通过 XMLHttpRequest 对象，在不刷新整个页面的情况下，使用异步方式与服务器发通信，获得数据，然后用 js 来操作DOM而更新页面。
缺点是破坏浏览器的机制，如 back、history功能；存在 SQL 注入的安全问题。
```js
function Ustbwuyi() {
    var xhr; 
    //非IE浏览器创建 xhr 对象
    if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
    } else if (window.ActiveXObject) { //IE浏览器创建 xhr 对象
        xhr = new ActiveXObject();
    }
    xhr.open("POST", url, false);  // 同步 false, 异步 true
    // xhr.open("GET", url);

    xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");  // post请求一定要设置请求头的格式内容

    xhr.onreadystatechange = function () {
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {
               console.log(xhr.responseText)
            }
        }
    } 
    xhr.send(data);
    // xhr.send();
}
```

6. 返回一组数中最小的K个
```js
// 方法一 sort
let largest = (arr, n) => arr.sort((a,b) => a < b).slice(0, n);

// 方法二 快速排序
//交换数组元素的值
function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

function partation(arr, start, end) {
    var pivot = arr[end]; // 设置哨兵
    var i = start; // 交换的次数+1 哨兵要在数组插入的位置
    for (var j = start; j < end; j++) {
        if (arr[j] < pivot) {
            swap(arr, i, j);
            i++;
        }
    }
    swap(arr, i, end);
    return i;
}

function getLeastNumbers(input, k) {
    var result = [];
    if (input.length < 0 || k > input.length || k <= 0) {
        return false;
    }
    var start = 0;
    var end = input.length - 1;
    var p = partation(input, start, end);
    while (p !== (k - 1)) {
        if (p > (k - 1)) {
            end = p - 1;
            p = partation(input, start, end);
        } else {
            start = p + 1;
            partation(input, start, end);
        }
    }
    for (var i = 0; i < k; i++) {
        result.push(input[i]);
    }
    return result;
}
```

### HQHT
1. 设置元素浮动 改元素的display
都为 block

2. JS延迟加载的几种方式
defer 页面加载和解析完毕之后，按照原本的顺序执行，同时会在 DOMContentLoaded 之前执行
async 脚本下载结束之后立刻执行，同时会在load 事件之前执行
动态创建DOM
jQuery的getScript()方法
setTimeout
放到页面底部让js最后引入

3. DOMContentLoaded 和 load 区别
HTML文档被加载和解析完成，此时会触发DOMContentLoaded事件
页面上所有的资源被加载以后才会触发load事件
因此，页面的load事件会在DOMContentLoaded被触发之后才触发

4. link 与 @import 的区别
link功能较多，可以定义 rss、定义 rel 等作用，@import只能用于加载 css
当解析到link时，页面会同步加载所引的 css， @import所引用的 css 会等到页面加载完才被加载
link可以使用 js 动态引入，@import不行
@import需要 IE5 以上才能使用


### FZKJ  2019.8.7
1. offsetWidth
clientWidth，可视区宽度   clientWidth = width+padding-scrollbar
offsetWidth，实际宽度  offsetWidth = width+padding+border+(竖直方向滚动条)
scrollWidth，实际内容宽度  scrollWidth = width+padding+(超出显示范围的滚动宽度),  无滚动时等于 clientWidth

2. 头部底部固定，中间自适应铺满屏幕剩余高度，中间盒子里左盒子固定右盒子自适应宽度
```html
<div class="head">顶部</div>
<div class="content">
    <div class="one">左盒子 高度自适应 固定宽度200px</div>
    <div class="two">右盒子 高度自适应 宽度自适应铺满屏幕剩余高度</div>
</div>
<div class="foot">底部</div>
```
方法一、absolute 绝对定位
head、foot 绝对定位，且分别top、bottom为0，宽度100%自适应父容器
content 绝对定位，top值为head的高度，bottom值为foot的高度
one 左浮动，宽度固定； two 左边距为one宽度

方法二：利用boxsizing改变盒子模型
先为 html 设定box-sizing为border-box，加上上下padding值。布局模块均采用position:relative定位。
头部采用负向margin向上平移（因为有了html padding）

方法三、 flex

3. ES6中常用的新特性
1、块级作用域 const和let
2、模板字符串
3、箭头函数。 不需要 function 关键字创建函数；省略 return 关键字；没有自己的this，this指向固定，就是定义(生效)时所在的对象，而不是使用时所在的对象。
4、参数处理。参数默认/Spread/Rest。  迭代器中是一个 Spread 操作符；被用于函数传参时，是一个 Rest 操作符
5、元编程。 代理Proxy/反射Reflex
6、原有字面量加强  二进制和八进制字面量。 二进制使用 0b 或者 0B；数字前面添加 0o 或者0O 即可将其转换为八进制值
7、对象属性加强
8、对象和数组解构赋值。 如 const { name, age } = student
9、新增数据类型 Map/Set/Symbol
10、for...of 迭代
11、ES6中的类 Class。 extends/super/重写构造器
12、Module（模块）
13、Promise
14、尾递归优化


### MGY  2019.8.8
1. module.exports 和 exports 区别
module.exports 初始值为一个空对象 {}，如果module.exports初始时已经具备一些属性和方法，那么exports收集来的信息将被忽略
exports 是指向的 module.exports 的引用, 即 exports = module.exports
module.exports才是真正的接口，exports只不过是它的一个辅助工具。require() 返回的是 module.exports 而不是 exports
可以 exports.name= {}, 不能 exoprts = {}


2. 模块化
AMD 异步模块定义。RequireJS预先加载，依赖前置。 浏览器第一，异步加载模块。
CMD 通用模块定义。SeaJS 按需加载，依赖就近。   AMD和CMD最大的区别是对依赖模块的执行时机处理不同，不是加载的时机或者方式不同(都是异步加载模块)。
UMD 先判断是否支持AMD，再检验CommonJS环境，否则认为当前环境为浏览器环境
CommonJS。  Node服务器端模块的规范，同步加载模块。 require/module.exports/exports。当引用同一个模块时，不会再次加载，而是获取缓存；可重新赋值。
ES6模块，动态只读引用。原始值发生变化，import加载的值也会发生变化；不允许修改引入变量的值。


3. 前端构建工具
构建工具是一个把源代码转换成可执行代码的过程。包括下载依赖、代码转换、文件优化、代码分割、模块合并压缩、自动刷新、代码校验、单元测试、自动发布。
自动化构建是编写或使一大部分任务自动执行的一个动作，而这些任务则是软件开发者的日常。

4. webpack
webpack: 打包模块化js的工具。在webpack里，一切文件都是模块，通过 Loader 加载转换文件，通过 plugin 注入钩子，扩展 webpack，最后输出由多个模块组成的文件。
优点：专注于模块化，开箱即用一步到位；通过plugin拓展，完整好用又不失灵活；使用场景不局限于web开发；社区庞大活跃；良好的开发体验
缺点: 只能用于模块化开发

打包原理: 首先 minifest.js 会定义一个 webpackJsonp 方法，待其他打包后的文件（也可称为 chunk）调用。当调用 chunk 时，会先将该 chunk 中所有的 moreModules， 也就是每一个依赖的文件也可称为 module （如 test.js）存起来。之后通过 executeModules 判断这个文件是不是入口文件，决定是否执行第一次 __webpack_require__ 。而 __webpack_require__ 的作用，就是根据这个 module 所 require 的东西，不断递归调用 __webpack_require__，__webpack_require__函数返回值后供 require 使用。当然，模块是不会重复加载的，因为 installedModules 记录着 module 调用后的 exports 的值，只要命中缓存，就返回对应的值而不会再次调用 module。webpack 打包后的文件，就是通过一个个函数隔离 module 的作用域，以达到不互相污染的目的。
```js
// manifest.js
(function(modules) {
  window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
    var moduleId, result;
    for (moduleId in moreModules) {
      if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
        modules[moduleId] = moreModules[moduleId];
      }
    }
    if (executeModules) {
      for (i = 0; i < executeModules.length; i++) {
        result = __webpack_require__(executeModules[i]);
      }
    }
    return result;
  };

  var installedModules = {};

  function __webpack_require__(moduleId) {
    if (installedModules[moduleId]) {
      return installedModules[moduleId].exports;
    }
    var module = installedModules[moduleId] = {
      exports: {}
    };
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    return module.exports;
  }
})([]);
```


4. 宏任务、微任务
宏任务: 主代码块(鼠标事件，键盘事件, ajax、script) > setImmediate > MessageChannel > setTimeout / setInterval。
微任务: process.nextTick > Promise > MutationObserver


5. 浏览器中的多线程
JavaScript引擎线程，用于解析JavaScript代码 
GUI渲染线程，（它与javaScript线程是互斥的）
事件线程(onclick,onchange,…)
定时器线程(setTimeout, setInterval)
异步http线程(ajax)，负责数据请求
EventLoop轮询处理线程，事件被触发时该线程会把事件添加到待处理队列的队尾

6. 缓存
缓存分为Nginx、Apache服务端侧（CDN缓存）和客户端侧（浏览器缓存）。
浏览器缓存分为强缓存和协商缓存。强缓存不发请求到服务器，协商缓存会发请求到服务器。

设置缓存
HTML Meta标签控制缓存， 如 meta http-equiv="pragma" content="no-cache"   兼容性一般
HTTP头信息控制缓存
Expires（强），服务器缓存过期绝对时间，可能有误差不同步
Cache-control（强），客户端相对时间。 no-cache 缓存前需和服务器确认； no-store 禁止一切缓存
Last-Modified/If-Modified-Since（协商缓存）
Etag/If-None-Match（协商缓存）


6. vue：虚拟dom的实现


7. canvas
缓存
错误上报
http
https
移动端开发
微信小程序
微信公众号
常见兼容性问题

### ZYKJ 2019.8.10
双向绑定
设计模式
进程、线程  https://blog.csdn.net/mxsgoden/article/details/8821936

