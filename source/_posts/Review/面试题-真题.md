---
title: 面试题 真题
comments: true
date: 2019-08-03 16:48:51
categories: Review
tags: ['Review', 'JS']
---

### RL
1. 什么是盒模型，盒模型都由什么组成
页面渲染时，dom 元素所采用的 布局模型。可通过box-sizing进行设置。
包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。
IE模型，box-sizing 为 border-box，width/height = content + padding + border
标准模型，box-sizing 为 content-box，width/height = content

2. 原生 js 如何 添加和移除 dom 元素
element.appendChild(aChild);
parentNode.insertBefore(newNode, referenceNode)

node.removeChild(child)

3. CSS Hack，有哪些形式
针对不同的浏览器去写不同的CSS样式，从而让各浏览器能达到一致的渲染效果

有3种表现形式，选择器前缀法、css属性前缀法、IE条件注释法
```css
/* 选择器前缀法 */
/* 
*html *前缀只对IE6生效
*+html *+前缀只对IE7生效
@media screen\9{...}只对IE6/7生效
@media \0screen {body { background: red; }}只对IE8有效
@media \0screen\,screen\9{body { background: blue; }}只对IE6/7/8有效
@media screen\0 {body { background: green; }} 只对IE8/9/10有效
@media screen and (min-width:0\0) {body { background: gray; }} 只对IE9/10有效
@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }} 只对IE10有效 
*/


/* css属性前缀法 */
/* 
“-″减号是IE6专有的hack
“\9″ IE6/IE7/IE8/IE9/IE10都生效
“\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack
“\9\0″ 只对IE9/IE10生效，是IE9/10的hack 
*/

.hack {
background-color:red; /* All browsers */
	background-color:blue !important;/* All browsers but IE6 */
	*background-color:black; /* IE6, IE7 */
	+background-color:yellow;/* IE6, IE7*/
	background-color:gray\9; /* IE6, IE7, IE8, IE9, IE10 */
	background-color:purple\0; /* IE8, IE9, IE10 */
	background-color:orange\9\0;/*IE9, IE10*/
	_background-color:green; /* Only works in IE6 */
	*+background-color:pink; /*  WARNING: Only works in IE7 ? Is it right? */
}


/* IE条件注释法 */
<!--[if gte IE 6]>
  这段文字只在IE6及以上浏览器显示
<![endif]-->
```

4. 事件委托
概念：利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件

原理：事件流分为捕获、目标、冒泡3个阶段。事件开始时由嵌套层次最深的节点开始接收，然后逐级向其父级节点传播。

优点：减少与dom的交互次数，提高代码性能。动态生成DOM元素时，可通过事件代理给新增的元素添加事件函数。

适用：适合用事件委托的事件 click，mousedown，mouseup，keydown，keyup，keypress。

局限性：事件必须冒泡，如focus、blur本身就没用冒泡的特性。mouseover和mouseout虽然也有事件冒泡，但要经常计算它们的位置，处理起来不太容易。

5. ajax 原理、使用、缺点
一种创建交互式网页应用的开发技术，通过 XMLHttpRequest 对象，在不刷新整个页面的情况下，使用异步方式与服务器发通信，获得数据，然后用 js 来操作DOM而更新页面。
缺点是破坏浏览器的机制，如 back、history功能；存在 SQL 注入的安全问题。
```js
function Ustbwuyi() {
    var xhr; 
    //非IE浏览器创建 xhr 对象
    if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
    } else if (window.ActiveXObject) { //IE浏览器创建 xhr 对象
        xhr = new ActiveXObject();
    }
    xhr.open("POST", url, false);  // 同步 false, 异步 true
    // xhr.open("GET", url);

    xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");  // post请求一定要设置请求头的格式内容

    xhr.onreadystatechange = function () {
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {
               console.log(xhr.responseText)
            }
        }
    } 
    xhr.send(data);
    // xhr.send();
}
```

6. 返回一组数中最小的K个
```js
// 方法一 sort
let largest = (arr, n) => arr.sort((a,b) => a < b).slice(0, n);

// 方法二 快速排序
//交换数组元素的值
function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

function partation(arr, start, end) {
    var pivot = arr[end]; // 设置哨兵
    var i = start; // 交换的次数+1 哨兵要在数组插入的位置
    for (var j = start; j < end; j++) {
        if (arr[j] < pivot) {
            swap(arr, i, j);
            i++;
        }
    }
    swap(arr, i, end);
    return i;
}

function getLeastNumbers(input, k) {
    var result = [];
    if (input.length < 0 || k > input.length || k <= 0) {
        return false;
    }
    var start = 0;
    var end = input.length - 1;
    var p = partation(input, start, end);
    while (p !== (k - 1)) {
        if (p > (k - 1)) {
            end = p - 1;
            p = partation(input, start, end);
        } else {
            start = p + 1;
            partation(input, start, end);
        }
    }
    for (var i = 0; i < k; i++) {
        result.push(input[i]);
    }
    return result;
}
```

### HQHT
1. 设置元素浮动 改元素的display
都为 block

2. JS延迟加载的几种方式
defer 页面加载和解析完毕之后，按照原本的顺序执行，同时会在 DOMContentLoaded 之前执行
async 脚本下载结束之后立刻执行，同时会在load 事件之前执行
动态创建DOM
jQuery的getScript()方法
setTimeout
放到页面底部让js最后引入

3. DOMContentLoaded 和 load 区别
HTML文档被加载和解析完成，此时会触发DOMContentLoaded事件
页面上所有的资源被加载以后才会触发load事件
因此，页面的load事件会在DOMContentLoaded被触发之后才触发

4. link 与 @import 的区别
link功能较多，可以定义 rss、定义 rel 等作用，@import只能用于加载 css
当解析到link时，页面会同步加载所引的 css， @import所引用的 css 会等到页面加载完才被加载
link可以使用 js 动态引入，@import不行
@import需要 IE5 以上才能使用


### FZKJ  2019.8.7
1. offsetWidth
clientWidth，可视区宽度   clientWidth = width+padding-scrollbar
offsetWidth，实际宽度  offsetWidth = width+padding+border+(竖直方向滚动条)
scrollWidth，实际内容宽度  scrollWidth = width+padding+(超出显示范围的滚动宽度),  无滚动时等于 clientWidth

2. 头部底部固定，中间自适应铺满屏幕剩余高度，中间盒子里左盒子固定右盒子自适应宽度
```html
<div class="head">顶部</div>
<div class="content">
    <div class="one">左盒子 高度自适应 固定宽度200px</div>
    <div class="two">右盒子 高度自适应 宽度自适应铺满屏幕剩余高度</div>
</div>
<div class="foot">底部</div>
```
方法一、absolute 绝对定位
head、foot 绝对定位，且分别top、bottom为0，宽度100%自适应父容器
content 绝对定位，top值为head的高度，bottom值为foot的高度
one 左浮动，宽度固定； two 左边距为one宽度

方法二：利用boxsizing改变盒子模型
先为 html 设定box-sizing为border-box，加上上下padding值。布局模块均采用position:relative定位。
头部采用负向margin向上平移（因为有了html padding）

方法三、 flex

3. ES6中常用的新特性
1、块级作用域 const和let
2、模板字符串
3、箭头函数。 不需要 function 关键字创建函数；省略 return 关键字；没有自己的this，this指向固定，就是定义(生效)时所在的对象，而不是使用时所在的对象。
4、参数处理。参数默认/Spread/Rest。  迭代器中是一个 Spread 操作符；被用于函数传参时，是一个 Rest 操作符
5、元编程。 代理Proxy/反射Reflex
6、原有字面量加强  二进制和八进制字面量。 二进制使用 0b 或者 0B；数字前面添加 0o 或者0O 即可将其转换为八进制值
7、对象属性加强
8、对象和数组解构赋值。 如 const { name, age } = student
9、新增数据类型 Map/Set/Symbol
10、for...of 迭代
11、ES6中的类 Class。 extends/super/重写构造器
12、Module（模块）
13、Promise
14、尾递归优化


### MGY  2019.8.8
1. module.exports 和 exports 区别
module.exports 初始值为一个空对象 {}，如果module.exports初始时已经具备一些属性和方法，那么exports收集来的信息将被忽略
exports 是指向的 module.exports 的引用, 即 exports = module.exports
module.exports才是真正的接口，exports只不过是它的一个辅助工具。require() 返回的是 module.exports 而不是 exports
可以 exports.name= {}, 不能 exoprts = {}


2. 模块化
AMD 异步模块定义。RequireJS预先加载，依赖前置。 浏览器第一，异步加载模块。
CMD 通用模块定义。SeaJS 按需加载，依赖就近。   AMD和CMD最大的区别是对依赖模块的执行时机处理不同，不是加载的时机或者方式不同(都是异步加载模块)。
UMD 先判断是否支持AMD，再检验CommonJS环境，否则认为当前环境为浏览器环境
CommonJS。  Node服务器端模块的规范，同步加载模块。 require/module.exports/exports。当引用同一个模块时，不会再次加载，而是获取缓存；可重新赋值。
ES6模块，动态只读引用。原始值发生变化，import加载的值也会发生变化；不允许修改引入变量的值。


3. 前端构建工具
构建工具是一个把源代码转换成可执行代码的过程。包括下载依赖、代码转换、文件优化、代码分割、模块合并压缩、自动刷新、代码校验、单元测试、自动发布。
自动化构建是编写或使一大部分任务自动执行的一个动作，而这些任务则是软件开发者的日常。

4. webpack
webpack: 打包模块化js的工具。在webpack里，一切文件都是模块，通过 Loader 加载转换文件，通过 plugin 注入钩子，扩展 webpack，最后输出由多个模块组成的文件。
优点：专注于模块化，开箱即用一步到位；通过plugin拓展，完整好用又不失灵活；使用场景不局限于web开发；社区庞大活跃；良好的开发体验
缺点: 只能用于模块化开发

打包原理: 首先 minifest.js 会定义一个 webpackJsonp 方法，待其他打包后的文件（也可称为 chunk）调用。当调用 chunk 时，会先将该 chunk 中所有的 moreModules， 也就是每一个依赖的文件也可称为 module （如 test.js）存起来。之后通过 executeModules 判断这个文件是不是入口文件，决定是否执行第一次 __webpack_require__ 。而 __webpack_require__ 的作用，就是根据这个 module 所 require 的东西，不断递归调用 __webpack_require__，__webpack_require__函数返回值后供 require 使用。当然，模块是不会重复加载的，因为 installedModules 记录着 module 调用后的 exports 的值，只要命中缓存，就返回对应的值而不会再次调用 module。webpack 打包后的文件，就是通过一个个函数隔离 module 的作用域，以达到不互相污染的目的。
```js
// manifest.js
(function(modules) {
  window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
    var moduleId, result;
    for (moduleId in moreModules) {
      if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
        modules[moduleId] = moreModules[moduleId];
      }
    }
    if (executeModules) {
      for (i = 0; i < executeModules.length; i++) {
        result = __webpack_require__(executeModules[i]);
      }
    }
    return result;
  };

  var installedModules = {};

  function __webpack_require__(moduleId) {
    if (installedModules[moduleId]) {
      return installedModules[moduleId].exports;
    }
    var module = installedModules[moduleId] = {
      exports: {}
    };
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    return module.exports;
  }
})([]);
```


4. 宏任务、微任务
宏任务: 主代码块(鼠标事件，键盘事件, ajax、script) > setImmediate > MessageChannel > setTimeout / setInterval。
微任务: process.nextTick > Promise > MutationObserver


5. 浏览器中的多线程
JavaScript引擎线程，用于解析JavaScript代码 
GUI渲染线程，（它与javaScript线程是互斥的）
事件线程(onclick,onchange,…)
定时器线程(setTimeout, setInterval)
异步http线程(ajax)，负责数据请求
EventLoop轮询处理线程，事件被触发时该线程会把事件添加到待处理队列的队尾


6. 缓存
缓存分为Nginx、Apache服务端侧（CDN缓存）和客户端侧（浏览器缓存）。
浏览器缓存分为强缓存和协商缓存。强缓存不发请求到服务器，协商缓存会发请求到服务器。

设置缓存
HTML Meta标签控制缓存， 如 meta http-equiv="pragma" content="no-cache"   兼容性一般
HTTP头信息控制缓存
Expires（强），服务器缓存过期绝对时间，可能有误差不同步
Cache-control（强），客户端相对时间。 no-cache 缓存前需和服务器确认； no-store 禁止一切缓存
Last-Modified/If-Modified-Since（协商缓存）
Etag/If-None-Match（协商缓存）


7. 什么是进程、线程
进程是 操作系统 资源分配和调度 的最小单位，它是程序执行时的一个实例，进程有自己的独立地址空间
线程是 CPU调度和分派 程序执行的最小单位，它是进程的一个实体，线程共享进程中内存

8. 前端权限控制方案
按细粒度可分为路由、视图、请求三个层面的控制。
1、登录权限，用户鉴权。登录后获得一个 token，然后在请求 Headers 中设置 “Authorization”。token 会存进 sessionStorage 里，用户刷新将直接使用本地 token 授权，并重新获取权限数据，如果本地 token 失效，那么后端应该返回 401 状态码，前端跳回登陆界面。
2、获取权限数据，用户权限初始化，后端返回路由和资源权限数据。
2、页面路由，用户登录后只能看到自己有权访问的导航菜单和路由地址，否则将跳转 4xx 提示页。路由钩子beforeEach和addRoutes实现动态路由及菜单。
3、按钮元件，显示隐藏用指令做，v-if或指令仅使用bind回调。
4、接口请求控制，http请求拦截器，拦截越权请求。


* mongodb 和 mysql 区别
(1) MongoDB数据库更适合那些读作业较重的任务模型。MongoDB能充分利用机器的内存资源。如果机器的内存资源丰富的话，MongoDB的查询效率会快很多。
(2) MySQL数据库更适合插入、更新为主的任务模型，其效率相比于MongoDB优势非常明显。
(3) 在带”_id”插入数据的时候，MongoDB的插入效率其实并不高。如果想充分利用MongoDB性能的话，推荐采取不带”_id”的插入方式，然后对相关字段作索引来查询。
(4) MongoDB适合那些对数据库具体数据格式不明确或者数据库数据格式经常变化的需求模型，而且对开发者十分友好，但对运维不友好。
(5) 稳定性方面，MySQL非常稳定的数据库，无论在指定主键还是在不指定主键插入的情况下，其效率都差不了太多。
(6) 事务支持方面，MySQL占绝对优势，MongoDB对事务关系支持薄弱，这也是所有NoSQL数据库共同的缺陷。


8. token、cookie、session
HTTP 应用层的面向对象的协议，有五大特点：1、支持 B/S 模式；2、简单快速；3、灵活；4、无连接，每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接；5、无状态，事务处理没有记忆能力，每个请求都是独立的，不会记录任何信息。

* session和cookie流程
由于http的无状态，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。
1、首先，客户端会发送一个http请求到服务器端。
2、服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头就包含Set-Cookie头部。该头部包含了sessionId。
Set-Cookie: name1=value1; name2=value2[; expires=date][; max-age=time][; domain=domain][; path=path][; HttpOnly][; secure]。
3、在客户端发起的第二次请求，假如服务器给了 Set-Cookie，浏览器会自动在请求头中添加cookie。
4、服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端。
总之, session 有如用户信息档案表, 里面包含了用户的认证信息和登录状态等信息。cookie是实现session的一种方案。cookie存储在客户端，而session存储在服务器端。

* cookie面临的问题
1、csrf 攻击。可验证 HTTP Referer 判断请求的来源地址、token验证、自定义在HTTP头属性。

xss 漏洞：
不用DOM中的内联事件监听器；
将输入的数据进行转义处理；
使用成熟的 Vue/React框架；
Set-Cookie: HttpOnly; 
CSP: 如Content-Security-Policy: default-src 'self' *.trusted.com; 
设置 HTTP Header：X-XSS-Protection: 0 (禁止XSS过滤) / 1; mode=block (当检测到跨站脚本攻击 (XSS)时，浏览器将停止加载页面)。

2、有的客户端不支持cookie。小程序需要手动设置；有些浏览器不能手动设置cookie；对于混合嵌套的开发有问题，如小程序跳转H5页面，不能携带cookie。
3、浏览器对单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。


* session面临的问题
1、负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session。这个问题也可以将session存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。可以通过Nginx 做负载均衡的Session保持、使用Redis存储Session、Django设置Session共享等。
2、每个客户端只需存储自己的session id，但是服务端却需要存储所有用户session id，对服务器也是一个压力。


* token 令牌
由uid+time+sign[+固定参数]。token 的认证方式类似于临时的证书签名, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景。token在客户端一般存放于localStorage，cookie或sessionStorage中。在服务器一般存于数据库中。

jwt（json web token）
由三个部分组成：header.payload.signature。服务端把用户信息加密 token 传给客户端，客户端每次访问都返回token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session id占用存储空间，就很好的解决负载均衡多服务器的问题了。但token的状态和过期时间需要自己手动设置，比如，token中存储用户登录的时间，服务端每次验证这个时间是否过期就可以了。

token认证流程与cookie很相似:
用户登录，成功后服务器返回token给客户端。
客户端收到数据后保存在客户端
客户端再次访问服务器，将token放入headers中
服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码


* token 和 cookie session 区别
1、token可以抵抗csrf，cookie、session不行。
token是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，即使form 发起的 POST 请求并不受到浏览器同源策略的限制，攻击者也无法访问用户的token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。
2、session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie
3、cookie 装有sessionId，存储在客户端，浏览器通常会自动添加。
4、token 无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。
5、token 完全由应用管理，可以避开同源策略; cookie/session不可源于，但其同源只关注域名和path，忽略协议和端口。


9. 短轮询、长轮询、短连接、长连接
短轮询: 客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。请求中有大半是无用，浪费带宽和服务器资源，端程序编写比较容易，适于小型应用。

长轮询: 客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，有消息出现，服务器响应请求，并携带相应的数据。当有新消息、超时或网络故障，浏览器又会创建一个新请求。长轮询相对于短轮询减少了很多不必要的http请求次数，但数据顺序无法得到保证。长轮询是长连接的一种实现。

短连接: 短连接是指通讯双方有数据交互时，就建立一个连接，数据发送完成后，则断开此连接，即每次连接只完成一项业务的发送。http 1.0一般就指短连接。

长连接: 也叫持久连接，建立连接后不立即断开，并在此连接的基础上进行多次消息交互，直至有一方主动断开连接。省去较多的TCP建立和关闭的操作，节约时间。 
长连接的技术主要是用Comet，采用的技术分浏览器来实现，ie上用iframe，其他浏览器用xhr来实现，html5有WebSocket。
HTTP 1.1相对于1.0最重要的新特性就是引入了长连接。http1.0一般就指短连接，http1.0+的keep-alive、HTTP1.1的persisten 和 smtp,pop3,telnet这种就可以认为是长连接。一般的网络游戏应用、频繁交互的场景、即时通信工具都是长连接。

WebSocket: 单个TCP连接上进行全双工通信的协议。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。没有同源限制，客户端可以与任意服务器通信。


10. http1.0、http1.1、http2、https
影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟(浏览器阻塞，如谷歌浏览器对于同一个域名，最大并发连接为6个；DNS 查询；三次握手的建立连接)。

* HTTP1.1版本新特性
1、可扩展性
HTTP1.1增加了OPTIONS方法，它允许客户端获取一个服务器支持的方法列表。
HTTP1.1在请求消息中包含了Upgrade头域，通过该头域，客户端可以让服务器知道它能够支持的其它备用通信协议，服务器可以据此进行协议切换，使用备用协议与客户端进行通信。
2、缓存处理
HTTP1.0 使用expires + Last-Modified/If-Modified-Since来作为缓存判断的标准；
HTTP1.1 引入了更多的缓存控制策略：Cache-Control、Etag/If-None-Match等。
3、错误通知的管理
HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
4、断点续传
HTTP1.1在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
5、Host头处理
HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。
HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
6、长连接
HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，并默认开启Connection: keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点，减少了建立和关闭连接的消耗和延迟。


* http2.0 
1、引入二进制数据帧和流
HTTP1.x的解析基于文本。
HTTP2.0的协议解析采用二进制格式，数据传输分为二进制帧frame片段 每个帧都有顺序标号，一次的请求与被响应视为流stream。
2、多路复用（MultiPlexing）
浏览器在同一连接上一次触发多个请求，并以任何顺序接收请求。
3、header压缩
HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
4、服务端推送（server push）
同SPDY一样，HTTP2.0也具有server push功能。


* https vs http
HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。


* HTPS的工作过程
HTTPS就是使用SSL/TLS协议进行加密传输。
1、客户端向服务器发出加密通信的请求。请求中包含 支持自己支持的加密规则(协议版本、加密算法、哈希算法)。
2、服务器生成一对 公钥A 和 私钥B，并回应请求。回应内容包含 确认的加密规则；以及数字证书(包含公钥A、网址、证书颁发机构)。
3、客户端验证服务器证书。
如果 证书不可信、证书中的域名与实际域名不一致、已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。
如果 证书没有问题，客户端就会从证书中取出服务器的 公钥A。
4、客户端生成一串随机数 私钥C，并用 公钥A 对该 随机数C 非对称加密，形成 私钥R，发送给服务器。
5、服务器收到 私钥R 之后，使用自己的 私钥B 解密得到 私钥C，并以 私钥C 为密钥 对称加密 网页内容传输给客户端。
6、客户端以 私钥C 为密钥，使用之前约定好的解密算法获取网页内容。 

总结: 
对称加密是指加密和解密用一致的密钥，特点是快
非对称加密是指密钥区分公钥和私钥，公钥加密，私钥解密（私钥好比唯一一把钥匙，公钥好比锁，钥匙只有一把，但锁可以有很多，被锁头锁上只有一把私钥才能打开）

HTTPS就是使用SSL/TLS协议进行加密传输，让客户端拿到服务器的公钥，然后客户端随机生成一个对称加密的秘钥，使用公钥加密，传输给服务端，后续的所有信息都通过该对称秘钥进行加密解密，完成整个HTTPS的流程。


非对称加密算法：RSA，DSA/DSS 
对称加密算法：AES，RC4，3DES 
HASH算法：MD5，SHA1，SHA256




canvas

class/ interface
PWA
ssr
tcp/ip/udp
http/ http2
https
Service Worker
快应用
webtrc
vue 插件
mixin
移动端开发
微信小程序 数据存储
微信公众号
常见兼容性问题
promise resolve后的错误可以截获吗
怎么理解 promise

### ZYKJ 2019.8.10
虚拟dom的实现
双向绑定
设计模式


