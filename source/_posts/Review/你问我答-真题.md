---
title: 你问我答 真题
comments: true
date: 2019-08-03 16:48:51
categories: Review
tags: ['Review', 'JS']
---

### 容联
1. 什么是盒模型，盒模型都由什么组成
页面渲染时，dom 元素所采用的 布局模型。可通过box-sizing进行设置。
包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。
IE模型，box-sizing 为 border-box，content = width + padding + border
标准模型，box-sizing 为 content-box，content = width

2. 原生 js 如何 添加和移除 dom 元素
element.appendChild(aChild);
parentNode.insertBefore(newNode, referenceNode)

node.removeChild(child)

3. CSS Hack，有哪些形式
针对不同的浏览器及版本去写不同的CSS样式，从而让各浏览器能达到一致的渲染效果

有3种表现形式，选择器前缀法、css属性前缀法、IE条件注释法
```css
/* 选择器前缀法 */
/* 
*html *前缀只对IE6生效
*+html *+前缀只对IE7生效
@media screen\9{...}只对IE6/7生效
@media \0screen {body { background: red; }}只对IE8有效
@media \0screen\,screen\9{body { background: blue; }}只对IE6/7/8有效
@media screen\0 {body { background: green; }} 只对IE8/9/10有效
@media screen and (min-width:0\0) {body { background: gray; }} 只对IE9/10有效
@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }} 只对IE10有效 
*/


/* css属性前缀法 */
/* 
“-″减号是IE6专有的hack
“\9″ IE6/IE7/IE8/IE9/IE10都生效
“\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack
“\9\0″ 只对IE9/IE10生效，是IE9/10的hack 
*/

.hack {
background-color:red; /* All browsers */
	background-color:blue !important;/* All browsers but IE6 */
	*background-color:black; /* IE6, IE7 */
	+background-color:yellow;/* IE6, IE7*/
	background-color:gray\9; /* IE6, IE7, IE8, IE9, IE10 */
	background-color:purple\0; /* IE8, IE9, IE10 */
	background-color:orange\9\0;/*IE9, IE10*/
	_background-color:green; /* Only works in IE6 */
	*+background-color:pink; /*  WARNING: Only works in IE7 ? Is it right? */
}


/* IE条件注释法 */
<!--[if gte IE 6]>
  这段文字只在IE6及以上浏览器显示
<![endif]-->
```

4. 事件委托
概念：利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件

原理：事件流分为捕获、目标、冒泡3个阶段。事件开始时由嵌套层次最深的节点开始接收，然后逐级向其父级节点传播。

优点：减少与dom的交互次数，提高代码性能。动态生成DOM元素时，可通过事件代理给新增的元素添加事件函数。

适用：适合用事件委托的事件 click，mousedown，mouseup，keydown，keyup，keypress。

局限性：事件必须冒泡，如focus、blur本身就没用冒泡的特性。mouseover和mouseout虽然也有事件冒泡，但要经常计算它们的位置，处理起来不太容易。

5. ajax 原理、使用、缺点
一种创建交互式网页应用的开发技术，通过 XMLHttpRequest 对象，在不刷新整个页面的情况下，使用异步方式与服务器发通信，获得数据，然后用 js 来操作DOM而更新页面。
缺点是破坏浏览器的机制，如 back、history功能；存在 SQL 注入的安全问题。
```js
function ajax() {
    var xhr; 
    //非IE浏览器创建 xhr 对象
    if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
    } else if (window.ActiveXObject) { //IE浏览器创建 xhr 对象
        xhr = new ActiveXObject();
    }
    xhr.open("POST", url, false);  // 同步 false, 异步 true
    // xhr.open("GET", url);

    xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");  // post请求一定要设置请求头的格式内容

    xhr.onreadystatechange = function () {
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {
               console.log(xhr.responseText)
            }
        }
    } 
    xhr.send(data);
    // xhr.send();
}
```

6. 返回一组数中最小的K个
```js
// 方法一 sort
let largest = (arr, n) => arr.sort((a,b) => a < b).slice(0, n);

// 方法二 快速排序
//交换数组元素的值
function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

function partation(arr, start, end) {
    var pivot = arr[end]; // 设置哨兵
    var i = start; // 交换的次数+1 哨兵要在数组插入的位置
    for (var j = start; j < end; j++) {
        if (arr[j] < pivot) {
            swap(arr, i, j);
            i++;
        }
    }
    swap(arr, i, end);
    return i;
}

function getLeastNumbers(input, k) {
    var result = [];
    if (input.length < 0 || k > input.length || k <= 0) {
        return false;
    }
    var start = 0;
    var end = input.length - 1;
    var p = partation(input, start, end);
    while (p !== (k - 1)) {
        if (p > (k - 1)) {
            end = p - 1;
            p = partation(input, start, end);
        } else {
            start = p + 1;
            partation(input, start, end);
        }
    }
    for (var i = 0; i < k; i++) {
        result.push(input[i]);
    }
    return result;
}
```

### 环球恒通
1. 设置元素浮动 改元素的display
都为 block

2. JS延迟加载的几种方式
defer 页面加载和解析完毕之后，按照原本的顺序执行，同时会在 DOMContentLoaded 之前执行
async 脚本下载结束之后立刻执行，同时会在load 事件之前执行
动态创建DOM
jQuery的getScript()方法
setTimeout
放到页面底部让js最后引入

3. DOMContentLoaded 和 load 区别
HTML文档被加载和解析完成，此时会触发DOMContentLoaded事件
页面上所有的资源被加载以后才会触发load事件
因此，页面的load事件会在DOMContentLoaded被触发之后才触发

4. link 与 @import 的区别
link功能较多，可以定义 rss、定义 rel 等作用，@import只能用于加载 css
当解析到link时，页面会同步加载所引的 css， @import所引用的 css 会等到页面加载完才被加载
link可以使用 js 动态引入，@import不行
@import需要 IE5 以上才能使用


### 方直科技  2019.8.7
1. offsetWidth
clientWidth，可视区宽度   clientWidth = width+padding
offsetWidth，实际宽度  offsetWidth = width+padding+border+(竖直方向滚动条)
scrollWidth，实际内容宽度  scrollWidth = width+padding+(超出显示范围的滚动宽度),  无滚动时等于 clientWidth

2. 头部底部固定，中间自适应铺满屏幕剩余高度，中间盒子里左盒子固定右盒子自适应宽度
```html
<div class="head">顶部</div>
<div class="content">
    <div class="one">左盒子 高度自适应 固定宽度200px</div>
    <div class="two">右盒子 高度自适应 宽度自适应铺满屏幕剩余高度</div>
</div>
<div class="foot">底部</div>
```
方法一、absolute 绝对定位
head、foot 绝对定位，且分别top、bottom为0，宽度100%自适应父容器
content 绝对定位，top值为head的高度，bottom值为foot的高度
one 左浮动，宽度固定； two 左边距为one宽度

方法二：利用boxsizing改变盒子模型
先为 html 设定box-sizing为border-box，加上上下padding值。布局模块均采用position:relative定位。
头部采用负向margin向上平移（因为有了html padding）

方法三、 flex

3. ES6中常用的新特性
1、块级作用域 const和let
2、模板字符串
3、箭头函数。 不需要 function 关键字创建函数；省略 return 关键字；没有自己的this，this指向固定，就是定义(生效)时所在的对象，而不是使用时所在的对象。
4、参数处理。参数默认/Rest参数/Spread。  迭代器中是一个 Spread 操作符；被用于函数传参时，是一个 Rest 操作符
5、元编程。 代理Proxy/反射Reflex
6、原有字面量加强  二进制和八进制字面量。 二进制使用 0b 或者 0B；数字前面添加 0o 或者0O 即可将其转换为八进制值
7、对象属性加强
8、对象和数组解构赋值。 如 const { name, age } = student
9、新增数据类型 Map/Set/Symbol
10、for...of 迭代
11、ES6中的类 Class。 extends/super/重写构造器
12、Module（模块）
13、Promise
14、尾递归优化(某个函数的最后一步是调用另一个函数,只保留内层函数的调用记录,节省内存)


### 蘑菇云  2019.8.8
1. module.exports 和 exports 区别
module.exports 初始值为一个空对象 {}，如果module.exports初始时已经具备一些属性和方法，那么exports收集来的信息将被忽略
exports 是指向的 module.exports 的引用, 即 exports = module.exports
module.exports才是真正的接口，exports只不过是它的一个辅助工具。require() 返回的是 module.exports 而不是 exports
可以 exports.name= {}, 不能 exoprts = {}


2. 模块化
AMD 异步模块定义。RequireJS预先加载，依赖前置。 浏览器第一，异步加载模块。
CMD 通用模块定义。SeaJS 按需加载，依赖就近。   AMD和CMD最大的区别是对依赖模块的执行时机处理不同，不是加载的时机或者方式不同(都是异步加载模块)。
UMD 先判断是否支持AMD，再检验CommonJS环境，否则认为当前环境为浏览器环境
CommonJS。  Node服务器端模块的规范，同步加载模块。 require/module.exports/exports。当引用同一个模块时，不会再次加载，而是获取缓存；可重新赋值。
ES6模块，动态只读引用。原始值发生变化，import加载的值也会发生变化；不允许修改引入变量的值。

require commonjs 通过require引入基础数据类型时，属于复制该变量,会被模块缓存，可重新赋值; 引入复杂数据类型时，数据浅拷贝该对象; CommonJS模块默认export的是一个对象，即使导出的是基础数据类型

import ES6 对该变量的动态只读引用。动态在于一个模块中变量的变化会影响到另一个模块；只读在于从某个模块引入一个变量时，不允许修改该变量的值。对于复杂数据类型，可以添加属性和方法，但是不允许指向另一个内存空间。 import 被提升


3. 前端构建工具
构建工具是一个把源代码转换成可执行代码的过程。包括下载依赖、代码转换、文件优化、代码分割、模块合并压缩、自动刷新、代码校验、单元测试、自动发布。
自动化构建是编写或使一大部分任务自动执行的一个动作，而这些任务则是软件开发者的日常。

4. webpack
webpack: 打包模块化js的工具。在webpack里，一切文件都是模块，通过 Loader 加载转换文件，通过 plugin 注入钩子，扩展 webpack，最后输出由多个模块组成的文件。
优点：专注于模块化，开箱即用一步到位；通过plugin拓展，完整好用又不失灵活；使用场景不局限于web开发；社区庞大活跃；良好的开发体验
缺点: 只能用于模块化开发

打包原理: 首先 minifest.js 会定义一个 webpackJsonp 方法，待其他打包后的文件（也可称为 chunk）调用。当调用 chunk 时，会先将该 chunk 中所有的 moreModules， 也就是每一个依赖的文件也可称为 module （如 test.js）存起来。之后通过 executeModules 判断这个文件是不是入口文件，决定是否执行第一次 __webpack_require__ 。而 __webpack_require__ 的作用，就是根据这个 module 所 require 的东西，不断递归调用 __webpack_require__，__webpack_require__函数返回值后供 require 使用。当然，模块是不会重复加载的，因为 installedModules 记录着 module 调用后的 exports 的值，只要命中缓存，就返回对应的值而不会再次调用 module。webpack 打包后的文件，就是通过一个个函数隔离 module 的作用域，以达到不互相污染的目的。
```js
// manifest.js
(function(modules) {
  window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
    var moduleId, result;
    for (moduleId in moreModules) {
      if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
        modules[moduleId] = moreModules[moduleId];
      }
    }
    if (executeModules) {
      for (i = 0; i < executeModules.length; i++) {
        result = __webpack_require__(executeModules[i]);
      }
    }
    return result;
  };

  var installedModules = {};

  function __webpack_require__(moduleId) {
    if (installedModules[moduleId]) {
      return installedModules[moduleId].exports;
    }
    var module = installedModules[moduleId] = {
      exports: {}
    };
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    return module.exports;
  }
})([]);
```

4. 宏任务、微任务
宏任务: 主代码块(鼠标事件，键盘事件, ajax、script) > setImmediate > MessageChannel > setTimeout / setInterval。
微任务: process.nextTick > Promise > MutationObserver


5. 浏览器中的多线程
JavaScript引擎线程，用于解析JavaScript代码 
GUI渲染线程，（它与javaScript线程是互斥的）
事件线程(onclick,onchange,…)
定时器线程(setTimeout, setInterval)
异步http线程(ajax)，负责数据请求
EventLoop轮询处理线程，事件被触发时该线程会把事件添加到待处理队列的队尾


6. 缓存
缓存分为Nginx、Apache服务端侧（CDN缓存）和客户端侧（浏览器缓存）。
浏览器缓存分为强缓存和协商缓存。强缓存不发请求到服务器，协商缓存会发请求到服务器。

设置缓存
HTML Meta标签控制缓存， 如 meta http-equiv="pragma" content="no-cache"   兼容性一般
HTTP头信息控制缓存
Expires（强），服务器缓存过期绝对时间，可能有误差不同步
Cache-control（强），客户端相对时间。 no-cache 缓存前需和服务器确认； no-store 禁止一切缓存
Last-Modified/If-Modified-Since（协商缓存）
Etag/If-None-Match（协商缓存）


7. 什么是进程、线程
进程是 操作系统 资源分配和调度 的最小单位，它是程序执行时的一个实例，进程有自己的独立地址空间
线程是 CPU调度和分派 程序执行的最小单位，它是进程的一个实体，线程共享进程中内存

8. 前端权限控制方案
按细粒度可分为路由、视图、请求三个层面的控制。
1、登录权限，用户鉴权。登录后获得一个 token，然后在请求 Headers 中设置 “Authorization”。token 会存进 sessionStorage 里，用户刷新将直接使用本地 token 授权，并重新获取权限数据，如果本地 token 失效，那么后端应该返回 401 状态码，前端跳回登陆界面。
2、获取权限数据，用户权限初始化，后端返回路由和资源权限数据。
2、页面路由，用户登录后只能看到自己有权访问的导航菜单和路由地址，否则将跳转 4xx 提示页。路由钩子beforeEach和addRoutes实现动态路由及菜单。
3、按钮元件，显示隐藏用指令做，v-if或指令仅使用bind回调。
4、接口请求控制，http请求拦截器，拦截越权请求。


* mongodb 和 mysql 区别
(1) MongoDB数据库更适合那些读作业较重的任务模型。MongoDB能充分利用机器的内存资源。如果机器的内存资源丰富的话，MongoDB的查询效率会快很多。
(2) MySQL数据库更适合插入、更新为主的任务模型，其效率相比于MongoDB优势非常明显。
(3) 在带”_id”插入数据的时候，MongoDB的插入效率其实并不高。如果想充分利用MongoDB性能的话，推荐采取不带”_id”的插入方式，然后对相关字段作索引来查询。
(4) MongoDB适合那些对数据库具体数据格式不明确或者数据库数据格式经常变化的需求模型，而且对开发者十分友好，但对运维不友好。
(5) 稳定性方面，MySQL非常稳定的数据库，无论在指定主键还是在不指定主键插入的情况下，其效率都差不了太多。
(6) 事务支持方面，MySQL占绝对优势，MongoDB对事务关系支持薄弱，这也是所有NoSQL数据库共同的缺陷。


8. token、cookie、session
HTTP 应用层的面向对象的协议，有五大特点：1、支持 B/S 模式；2、简单快速；3、灵活；4、无连接，每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接；5、无状态，事务处理没有记忆能力，每个请求都是独立的，不会记录任何信息。

* session和cookie流程
由于http的无状态，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。
1、首先，客户端会发送一个http请求到服务器端。
2、服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头就包含Set-Cookie头部。该头部包含了sessionId。
Set-Cookie: name1=value1; name2=value2[; expires=date][; max-age=time][; domain=domain][; path=path][; HttpOnly][; secure]。
3、在客户端发起的第二次请求，假如服务器给了 Set-Cookie，浏览器会自动在请求头中添加cookie。
4、服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端。
总之, session 有如用户信息档案表, 里面包含了用户的认证信息和登录状态等信息。cookie是实现session的一种方案。cookie存储在客户端，而session存储在服务器端。

* cookie面临的问题
1、csrf 攻击。可验证 HTTP Referer 判断请求的来源地址、token验证、自定义在HTTP头属性。

xss 漏洞：
不用DOM中的内联事件监听器；
将输入的数据进行转义处理；
使用成熟的 Vue/React框架；
Set-Cookie: HttpOnly; 
CSP: 如Content-Security-Policy: default-src 'self' *.trusted.com; 
设置 HTTP Header：X-XSS-Protection: 0 (禁止XSS过滤) / 1; mode=block (当检测到跨站脚本攻击 (XSS)时，浏览器将停止加载页面)。

2、有的客户端不支持cookie。小程序需要手动设置；有些浏览器不能手动设置cookie；对于混合嵌套的开发有问题，如小程序跳转H5页面，不能携带cookie。
3、浏览器对单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。


* session面临的问题
1、负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session。这个问题也可以将session存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。可以通过Nginx 做负载均衡的Session保持、使用Redis存储Session、Django设置Session共享等。
2、每个客户端只需存储自己的session id，但是服务端却需要存储所有用户session id，对服务器也是一个压力。


* token 令牌
由uid+time+sign[+固定参数]。token 的认证方式类似于临时的证书签名, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景。token在客户端一般存放于localStorage，cookie或sessionStorage中。在服务器一般存于数据库中。

jwt（json web token）
由三个部分组成：header.payload.signature。服务端把用户信息加密 token 传给客户端，客户端每次访问都返回token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session id占用存储空间，就很好的解决负载均衡多服务器的问题了。但token的状态和过期时间需要自己手动设置，比如，token中存储用户登录的时间，服务端每次验证这个时间是否过期就可以了。

token认证流程与cookie很相似:
用户登录，成功后服务器返回token给客户端。
客户端收到数据后保存在客户端
客户端再次访问服务器，将token放入headers中
服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码


* token 和 cookie session 区别
1、token可以抵抗csrf，cookie、session不行。
token是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，即使form 发起的 POST 请求并不受到浏览器同源策略的限制，攻击者也无法访问用户的token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。
2、session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie
3、cookie 装有sessionId，存储在客户端，浏览器通常会自动添加。
4、token 无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。
5、token 完全由应用管理，可以避开同源策略; cookie/session不可跨源，但其同源只关注域名和path，忽略协议和端口。


9. 短轮询、长轮询、短连接、长连接
短轮询: 客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。请求中有大半是无用，浪费带宽和服务器资源，端程序编写比较容易，适于小型应用。

长轮询: 客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，有消息出现，服务器响应请求，并携带相应的数据。当有新消息、超时或网络故障，浏览器又会创建一个新请求。长轮询相对于短轮询减少了很多不必要的http请求次数，但数据顺序无法得到保证。长轮询是长连接的一种实现。

短连接: 短连接是指通讯双方有数据交互时，就建立一个连接，数据发送完成后，则断开此连接，即每次连接只完成一项业务的发送。http 1.0一般就指短连接。

长连接: 也叫持久连接，建立连接后不立即断开，并在此连接的基础上进行多次消息交互，直至有一方主动断开连接。省去较多的TCP建立和关闭的操作，节约时间。 
长连接的技术主要是用Comet，采用的技术分浏览器来实现，ie上用iframe，其他浏览器用xhr来实现，html5有WebSocket。
HTTP 1.1相对于1.0最重要的新特性就是引入了长连接。http1.0一般就指短连接，http1.0+的keep-alive、HTTP1.1的persisten 和 smtp,pop3,telnet这种就可以认为是长连接。一般的网络游戏应用、频繁交互的场景、即时通信工具都是长连接。

WebSocket: 单个TCP连接上进行全双工通信的协议。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。没有同源限制，客户端可以与任意服务器通信。


10. http1.0、http1.1、http2、https
影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟(浏览器阻塞，如谷歌浏览器对于同一个域名，最大并发连接为6个；DNS 查询；三次握手的建立连接)。

* HTTP1.1版本新特性
1、可扩展性
HTTP1.1增加了OPTIONS方法，它允许客户端获取一个服务器支持的方法列表。
HTTP1.1在请求消息中包含了Upgrade头域，通过该头域，客户端可以让服务器知道它能够支持的其它备用通信协议，服务器可以据此进行协议切换，使用备用协议与客户端进行通信。
2、缓存处理
HTTP1.0 使用expires + Last-Modified/If-Modified-Since来作为缓存判断的标准；
HTTP1.1 引入了更多的缓存控制策略：Cache-Control、Etag/If-None-Match等。
3、错误通知的管理
HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
4、断点续传
HTTP1.1在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
5、Host头处理
HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。
HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
6、长连接
HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，并默认开启Connection: keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点，减少了建立和关闭连接的消耗和延迟。


* http2.0 
1、引入二进制数据帧和流
HTTP1.x的解析基于文本。
HTTP2.0的协议解析采用二进制格式，数据传输分为二进制帧frame片段 每个帧都有顺序标号，一次的请求与被响应视为流stream。
2、多路复用（MultiPlexing）
浏览器在同一连接上一次触发多个请求，并以任何顺序接收请求。
3、header压缩
HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
4、服务端推送（server push）
同SPDY一样，HTTP2.0也具有server push功能。


* https vs http
HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。


* HTPS的工作过程
HTTPS就是使用SSL/TLS协议进行加密传输。
1、客户端向服务器发出加密通信的请求。请求中包含 支持自己支持的加密规则(协议版本、加密算法、哈希算法)。
2、服务器生成一对 公钥A 和 私钥B，并回应请求。回应内容包含 确认的加密规则；以及数字证书(包含公钥A、网址、证书颁发机构)。
3、客户端验证服务器证书。
如果 证书不可信、证书中的域名与实际域名不一致、已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。
如果 证书没有问题，客户端就会从证书中取出服务器的 公钥A。
4、客户端生成一串随机数 私钥C，并用 公钥A 对该 随机数C 非对称加密，形成 私钥R，发送给服务器。
5、服务器收到 私钥R 之后，使用自己的 私钥B 解密得到 私钥C，并以 私钥C 为密钥 对称加密 网页内容传输给客户端。
6、客户端以 私钥C 为密钥，使用之前约定好的解密算法获取网页内容。 

总结: 
对称加密是指加密和解密用一致的密钥，特点是快
非对称加密是指密钥区分公钥和私钥，公钥加密，私钥解密（私钥好比唯一一把钥匙，公钥好比锁，钥匙只有一把，但锁可以有很多，被锁头锁上只有一把私钥才能打开）

HTTPS就是使用SSL/TLS协议进行加密传输，让客户端拿到服务器的公钥，然后客户端随机生成一个对称加密的秘钥，使用公钥加密，传输给服务端，后续的所有信息都通过该对称秘钥进行加密解密，完成整个HTTPS的流程。


非对称加密算法：RSA，DSA/DSS 
对称加密算法：AES，RC4，3DES 
HASH算法：MD5，SHA1，SHA256

* 在 https 页面上不允许出现 http 请求，会提示报错
CSP 设置 upgrade-insecure-requests 让浏览器自动升级请求，两种方法
服务器响应头中加入: header("Content-Security-Policy: upgrade-insecure-requests");
页面中加入 meta:  meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests" 


11. TCP 建立连接 3次握手
目的: 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

syn: synchronize sequence number 同步序列编号
seq: sequence number
ack: acknowledgment number
1、客户端发送连接请求报文段: syn=1, seq=x。客户端进入SYN_SEND状态，等待服务器的确认；

2、服务器收到SYN报文段: syn=1,ack=x+1,seq=y。服务器进入SYN_RECV状态；

3、客户端收到服务器的报文: ack=y+1,seq=z。客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。


12. TCP 连接终止 4次挥手
目的: TCP 是全双工模式(数据的发送和接收分流，分别由两根不同的传输线传送时，通信双方都能在同一时刻进行发送和接收)，每个方向都必须单独进行关闭，

1、客户端发送FIN包，请求关闭连接: FIN=1, seq=x。表示客户端没有数据要发送了，但是仍然可以接受数据。客户端进入 FIN_WAIT_1 状态；

2、服务器收到FIN包，接收到关闭请求，但还没有准备好关闭连接: ACK=1，ACKnum=x+1。服务器端进入 CLOSE_WAIT 状态，客户端收到确认包后进入 FIN_WAIT_2 状态，等待服务器端关闭连接。

3、服务器发送FIN包，请求关闭连接: FIN=1，seq=y。服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。

4、客户端收到FIN包，向服务器发送ACK包: ACK=1，ACKnum=y+1。
客户端进入TIME_WAIT状态，等待可能出现的要求重传的 ACK 包；
服务器收到ACK包以后，关闭连接，进入 CLOSED 状态；
客户端等待2MSL(Maximum Segment Lifetime最大段生命周期)后依然没有收到 ACK 回复，则认为服务端已正常关闭，于是，客户端也关闭连接，进入 CLOSED 状态。


为什么TCP建立链接是三次，关闭链接是四次:
服务端的收到客户端SYN报文的连接请求后，它可以把 SYN和ACK（SYN起同步作用，ACK起应答作用）放在一个报文里来发送。
但关闭连接时，当服务端收到客户端的FIN报文时，它仅仅表示客户端没有数据发送给服务端了；但未必服务端所有的数据都全部发送给客户端了。只有等服务端所有的报文都发送完了，才能发送FIN报文，因此ACK和FIN是分开发送的。故需要四步握手。

![TCP三次握手、四次挥手](/images/tcp-shakehands.jpeg)


13. TCP vs UDP 区别
TCP（TransmissionControlProtocol 传输控制协议）是面向连接的、可靠的、使用流量控制和拥塞控制、面向字节流。
UDP（UserDataProtocol 用户数据报协议）是面向无连接的、简单不可靠、头部开销小、高效实时、面向报文。


14. 怎么理解 promise
Promise 是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免出现回调地狱。它是一个容器，里面保存着某个未来才会结束的事件的结果。ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。

Promise对象有以下两个特点: 对象的状态不受外界影响，有三种状态：pending、fulfilled 和 rejected，只有异步操作的结果，可以决定当前是哪一种状态。 一旦状态改变，就不会再变化。

15. 手写实现 promise 
```js
function promise(fn) {
  var state = 'pending', value = null, callbacks = []

  this.then = function(onFulfilled, onRejected) {
    return new Promise(function(resolve, reject) {
      handle({
        onFulfilled: onFulfilled || null,
        onRejected: onRejected || null,
        resolve,
        reject
      })
    })
  }

  function handle(callback) {
    if(state === 'pending') {
      callbacks.push(callback)
      return
    }

    // then中没有传递任何东西
    // if(!callback.onFulfilled) {
    //   callback.resolve(value)
    //   return
    // }

    // var ret = callback.onFulfilled(value)
    // callback.resolve(ret)

    var ret, cb
    cb = state === 'fulfilled' ? callback.onFulfilled : callback.onRejected
    if(cb === null) {
      cb = state === 'fulfilled' ? callback.resolve : callback.reject
      cb(value)
      return
    }

    try {
      ret = cb(value)
      callback.resolve(ret)
    } catch (e) {
      callback.reject(e)
    }
    
  }

  function resolve(newValue) {
    if(newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
      var then = newValue.then
      if(typeof then === 'function') {
        then.call(newValue, resolve)
        return
      }
      state = 'fulfilled'
      value = newValue
      excute()
    }
  }

  function reject(reason) {
    state = 'rejected'
    value = reason
    excute()
  }

  function excute() {
    setTimeout(function() {
      callbacks.forEach(function(callback) {
        handle(callback)
      })
    }, 0);
  }

  fn(resolve, reject)
}
```


16. xhr
```js
var xhr = new XMLHttpRequest();
xhr.open('GET', url);
xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200) {
        console.log(xhr.responseText) // 从服务器获取数据
    }
}
xhr.send()
```

17. fetch vs axios
ajax是使用 原生xhr 对象做异步操作

fetch 是一种浏览器原生实现的请求方式，是ajax 的替代品，但更加底层，提供了丰富的API。只对网络请求报错，对400，500都当做成功的请求，需要封装去处理; 默认不会带cookie，需要添加配置项; 不支持abort，不支持超时控制；没有办法原生监测请求的进度。

axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端。从浏览器中创建 XMLHttpRequest，从 nodejs 发出 http 请求，支持 Promise API， 转换/拦截/取消请求和响应，自动转换JSON数据，客户端支持防止CSRF。


18. PWA (Progressive Web App)
PWA的核心目标就是提升 Web App 的性能，改善 Web App 的用户体验。媲美native的流畅体验，将网络之长与应用之长相结合。

渐进式网页应用。PWA 不是特指某一项技术，而是应用了多项技术的 Web App。其核心技术包括 App Manifest、Service Worker、Web Push，等等。

19. Service Worker
Service workers 本质上充当客户端与服务器之间的代理服务器。可以在网络可用时作为浏览器和网络间的代理。使得能够创建有效的离线体验，拦截网络请求、向客户端发送消息、向服务器发起请求、推送通知，离线资源缓存，处理多页面所需的复杂数据。

Service worker运行在worker上下文，因此它不能访问DOM。相对于驱动应用的主JavaScript线程，它运行在其他线程中，所以不会造成阻塞。它设计为完全异步，大量使用Promise，同步API（如XHR和localStorage）不能在service worker中使用。Service workers只能由HTTPS承载或者本地的 localhost 环境下。


20. vue vs react
相同点:
都是用于创建UI的JavaScript库，集中在视图层
提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件
使用 Virtual DOM，有自己的diff渲染算法
将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。


主要区别:
运行时性能，react需使用PureComponent 和 shouldComponentUpdate 
类html模板 vs JSX
组件作用域内的 CSS: CSS-in-JS 的 styled-components vs  scoped css
状态管理 vs 对象属性: setState、data
原生渲染: rn vs weex
cra vs vue-cli
生态系统
构建一个大型应用程序: vue 的模板难以注意到的运行时错误、测试、重构和分解；React的immutable在大型应用中意义非凡,因为透明度和可测试性在大型项目中变得至关重要。


21. class vs interface
接口（Interfaces）是对类的一部分行为进行抽象，可以用于对 对象的形状 Shape 进行描述。接口具体如何行动需要由类（classes）去实现（implement）
一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。  


### oppo 2019.8.15

22. WebView
Android WebView在Android平台上是一个特殊的View， 基于webkit引擎、展现web页面的控件，这个类可以被用来在app中仅仅显示一张在线的网页，还可以用来开发浏览器。WebView内部实现是采用渲染引擎来展示view的内容，提供网页前进后退，网页放大，缩小，搜索。Android的Webview在低版本和高版本采用了不同的webkit版本内核，4.4后直接使用了Chrome。

现在很多APP都内置了Web网页，比如电商平台。WebView比较灵活，不需要升级客户端，只需要修改网页代码即可。一些经常变化的页面可以用WebView这种方式去加载网页。

Webview功能强大，可以直接使用html文件（本地sdcard/assets目录），还可以直接加载url，使用JavaScript可以html跟原生APP互调。

23. 快应用
快应用也叫免安装应用，即点即用。应用使用前端技术栈开发，原生渲染，同时具备H5页面和原生应用的双重优点。快应用是华为小米等联合狙击微信小程序开发的平台，快应用比微信小程序更进一步的是，使用native渲染而不是webview渲染。


24. 常见兼容性问题
IE: 
1、HTML5Shiv 允许IE 9之前的版本识别HTML5标记，并允许他们使用CSS样式
2、 获取元素高度
dom.currentStyle.width  只有IE浏览器
window.getComputedStyle(ele).width 
dom.offsetWidth  最常用的、兼容最好
3、清除浮动
zoom: 1;  IE
4、允许网页宽度自动调整
viewport
css3-mediaqueries.js   IE8及以下


25. JS 如何实现继承
* 原型链继承
引用类型的属性被所有实例共享; 在创建 Child 的实例时，不能向Parent传参
```js
function Parent () {
    this.name = 'kevin';
}

Parent.prototype.getName = function () {
    console.log(this.name);
}

function Child () {

}

Child.prototype = new Parent();
var child1 = new Child();
console.log(child1.getName()) // kevin
```

* 借用构造函数(经典继承)
避免了引用类型的属性被所有实例共享；可以在 Child 中向 Parent 传参
缺点: 方法都在构造函数中定义，每次创建实例都会创建一遍方法。
```js
function Parent (name) {
    this.name = name;
}

function Child (name) {
    Parent.call(this, name);
}

var child1 = new Child('kevin');
console.log(child1.name); // kevin

var child2 = new Child('daisy');
console.log(child2.name); // daisy
```

* 组合继承
融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式
```js
function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child (name, age) {
    Parent.call(this, name);
    this.age = age;
}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

var child1 = new Child('kevin', '18');
child1.colors.push('black');
console.log(child1.name); // kevin
console.log(child1.age); // 18
console.log(child1.colors); // ["red", "blue", "green", "black"]

var child2 = new Child('daisy', '20');
console.log(child2.name); // daisy
console.log(child2.age); // 20
console.log(child2.colors); // ["red", "blue", "green"]
```

* 原型式继承
Object.create 的实现，将传入的对象作为创建的对象的原型。
缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样
```js
function createObj(o) {
    function F(){}
    F.prototype = o;
    return new F();
}
```

* 寄生式继承
创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。
缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。
```js
function createObj (o) {
    var clone = Object.create(o);
    clone.sayName = function () {
        console.log('hi');
    }
    return clone;
}
```

* 寄生组合式继承
只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建多余的属性；原型链还能保持不变，因此还能够正常使用 instanceof 和 isPrototypeOf
开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式
```js
function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
    console.log(this.name)
}

function Child (name, age) {
    Parent.call(this, name);
    this.age = age;
}

// 关键的三步
var F = function () {};
F.prototype = Parent.prototype;
Child.prototype = new F();

var child1 = new Child('kevin', '18');
console.log(child1);
```

* ES6实现继承
书写简单，底层其实也是用寄生组合式继承来实现的
```js
// 父类
class SuperType {
  constructor(name) {
    this.name = name;
    this.colors = ["red", "blue", "green"];
  }

  sayName() {
    console.log(this.name);
  };
}

// 子类
class SubType extends SuperType {
  constructor(name, age) {
    super(name);   // 继承父类实例属性和prototype上的方法
    this.age = age;  // 子类实例属性
  }

  // 子类方法
  sayAge() {
    console.log(this.age);
  }
}

// 实例
var instance1 = new SubType('Tom', 20);
instance1.colors.push('black');
instance1.sayAge(); 
console.log(instance1.colors);  // ["red", "blue", "green", "black"]
```

26. 事件委托
利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件 
好处：给重复的节点添加相同操作，减少dom交互，提高性能 
实现思路：给父组件添加事件，通过事件冒泡，排查元素是否为指定元素，并进行系列操作

27. webpack
提取第三方库或通过引用外部文件的方式引入第三方库
代码压缩插件UglifyJsPlugin
服务器启用gzip压缩
按需加载资源文件 require.ensure
优化devtool中的source-map
剥离css文件，单独打包
去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致
开发环境采用增量构建，启用热更新
开发环境不做无意义的工作如提取css计算文件hash等
配置devtool
选择合适的loader
个别loader开启cache 如babel-loader
第三方库采用引入方式
提取公共代码
优化构建时的搜索路径 指明需要构建目录及不需要构建目录
模块化引入需要的部分


28. history vs hash 路由模式
hash 地址栏 URL 中的 # 符号，hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。监听onhashchange事件
history  利用了 HTML5 新增的 pushState() 和 replaceState() 方法。监听onpopstate事件，需要服务端配置路由支持覆盖

29. canvas
元素用于图形的绘制，动画、缩放、各种滤镜和像素转换等高级操作
```js
<canvas id="myCanvas" width="150" height="150"></canvas>
// 拿到 canvas 元素
var c=document.getElementById("myCanvas");
// 创建 context 对象
var ctx=c.getContext("2d");
// 绘制
ctx.fillStyle = "rgb(200,0,0)";
ctx.fillRect (10, 10, 55, 50);
```

30. ssr
服务端在返回 html 之前，在特定的区域，符号里用数据填充，再给客户端，客户端只负责解析 HTML 。
html 仅仅作为静态文件，客户端端在请求时，服务端不做任何处理，直接以原文件的形式返回给客户端客户端，然后根据 html 上的 JavaScript，生成 DOM 插入 html。

注意点:
服务端必须是 node.js 或者专门跑个 node.js 来支持；
document 对象找不到，由于前端使用的 window，在 node 环境不存在；
数据预获取时，组件尚未实例化（无法使用 this ），于是在 created 生命钩子调用 method 里的方法行不通，数据请求及格式化等操作都应该放置在专门的数据预取存储容器（data store）或"状态容器（state container）"中处理；
string-based 模板性能肯定要比 virtual-dom-based 模板的性能好。string-base 模板只要填数据即可，virtual-dom-based 模板需要经历 Vue 模板语法 ---> Vnode ---> 拼接字符串 html 的过程。


31. 防抖、节流
* 防抖 debounce
高频事件被触发后n秒内只执行一次，如果n秒内再次被触发，则重新计时
举例: 如果有人进电梯（触发事件），那电梯将在10秒钟后出发（执行事件监听器），这时如果又有人进电梯了（在10秒内再次触发该事件），又得等10秒再出发（重新计时）
思路: 每次触发事件时都取消之前的延时调用方法
场景: 搜索框搜索输入,只需用户最后一次输入完，再发送请求; 手机号、邮箱验证输入检测; 窗口大小resize，只需窗口调整完成后，计算窗口大小
```js
function debounce(fn) {
  let timer = null; // 创建一个标记用来存放定时器的返回值
  return function () {
    clearTimeout(timer); // 每当用户输入的时候把前一个 setTimeout clear 掉
    timer = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
      fn.apply(this, arguments);
    }, 500);
  };
}
function sayHi() {
  console.log('防抖成功');
}

var inp = document.getElementById('inp');
inp.addEventListener('input', debounce(sayHi)); // 防抖
```

* 节流 throttle
高频事件触发，但在单位时间内只会执行一次，下次执行要间隔一段时间，如果这个单位时间内触发多次函数，只有一次生效，相当于技能冷却
举例: 保证如果电梯第一个人进来后，10秒后准时运送一次，这个时间从第一个人上电梯开始计时，不等待，如果没有人，则不运行
思路: 每次触发事件时都判断当前是否有等待执行的延时函数
场景：滚动加载，是否滑到底部自动加载更多；鼠标不断点击触发，表单重复提交
```js
// 实现一
function throttle(fn) {
  let canRun = true  // 通过闭包保存一个标记
  return function() {
    if(!canRun) return   // 在函数开头判断标记是否为true，不为true则return
    canRun = false
    setTimeout(() => {
       // 当定时器没有执行的时候标记永远是false，在开头被return掉
      fn.apply(this, arguments)
      canRun = true  // setTimeout执行完毕后把标记设置为true 表示可以执行下一次循环了
    }, 500);
  }
}

// 实现二
function debounce(fn) {
  let timer = null, start = null
  return function() {
    let now = Date.now()
    if(!start) {
      start = now
    }
    clearTimeout(timer)  //总是干掉事件回调
    // 主动执行一次
    if(now - start > 500) {
      fn.apply(this, arguments)
      start = now
    } else {
      timer = setTimeout(() => {
        fn.apply(this, arguments)
      }, 500)
    }
  }
}
```

32. js为何是单线程
操作 DOM 必然会涉及到资源的竞争
引用多线程是为了充分利用硬件资源，但是作为js执行环境的浏览器是客户端的一个进程， 不需要考虑充分利用其硬件资源；
多线程带来了编程的复杂性，需要加锁，加锁本身也是消耗性能的


33. node 性能为何高
1、Nodejs与操作系统交互，我们在 Javascript中调用的方法，最终都会通过 process.binding 传递到 C/C++ 层面，最终由他们来执行真正的操作。Node.js 即这样与操作系统进行互动。
2、nodejs所谓的单线程，只是主线程是单线程，所有的网络请求或者异步任务都交给了内部的线程池去实现，本身只负责不断的往返调度，由事件循环不断驱动事件执行。
3、Nodejs之所以单线程可以处理高并发的原因，得益于libuv层的事件循环机制，和底层线程池实现。
4、Event loop就是主线程从主线程的事件队列里面不停循环的读取事件，驱动了所有的异步回调函数的执行，Event loop总共7个阶段，每个阶段都有一个任务队列，当所有阶段被顺序执行一次后，event loop 完成了一个 tick。


34. Webpack性能优化 
1、缩小文件的搜索范围
resolve字段告诉webpack怎么去搜索文件，所以首先要重视resolve字段的配置
设置resolve.modules:[path.resolve(__dirname, 'node_modules')]避免层层查找。
设置resolve.mainFields:['main']，设置尽量少的值可以减少入口文件的搜索步骤
合理配置resolve.extensions，减少文件查找
配置loader时，通过test、exclude、include缩小搜索范围
module.noParse字段告诉Webpack不必解析哪些文件，可以用来排除对非模块化库文件的解析
2、使用DllPlugin减少基础模块编译次数
把网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取
3、使用HappyPack开启多进程Loader转换
4、使用ParallelUglifyPlugin，开启多进程压缩JS文件
5、压缩代码 JS、ES、CSS
6、使用Tree Shaking剔除JS死代码


35. new 和 Object.create()
* new 
```js
var Fn = function () { };
var obj = new Fn();

function _new(Fn) {
  var obj = {} // new Object()  创建一个空对象
  obj.__prototype__ = Fn.prototype  // 设置原型链
  var ret = Fn.call(obj)  // 让Fn的this指向obj，并执行Fn的函数体
  if(typeof ret === 'Object') {   // 判断Fn的返回值类型，如果是引用类型，就返回这个引用类型的对象; 如果是值类型，返回obj
    return ret
  }
  return obj
}
```

* Objec.create()
```js
var o = Object.create(obj, props)

Objec.create = function(obj, props) {
  var Fn = function() {}
  Fn.prototype = obj
  if(props) {
    Object.defineProperties(Fn, props)
  }
  return new Fn()
}
```

36. vue 如何监听数组的变化
```js
var aryMethods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
var arrayAugmentations = Object.create(Array.prototype)

aryMethods.forEach((method)=> {
    var args = slice.call(arguments)
    var original = Array.prototype[method];
    arrayAugmentations[method] = function () {
        // console.log(`${method}方法被执行了`)
        return original.apply(this, args);
    };
});


var list = ['a', 'b', 'c'];
list.__proto__ = arrayAugmentations;
list.push('d');  // 我被改变啦！ 4
```


### TX 2019.8.20
1. 自我介绍
2. 最近的项目
3. vue react 对比
4. virtual dom
5. vuex
6. 小程序
7. 双向绑定
8. csrf 产生 预防 
9. 性能优化
10. 缓存 cache-control
11. 代理服务器
12. css 动画
13. 懒加载  图片
14. img的src为空或者#，都会发一次请求，浏览器会用当前路径发起一次请求。直接改为 img
15. vue3
16. flex 使得所有列包括两边间距一样
17. ES6
18. Vue3 新特性
更快、更小、更易于维护、更多的原生支持、更易于开发使用
1、虚拟 DOM 重写，mounting和patching的速度提高100％
2、更多的编译时的提示来减少运行时的开销
3、组件快速路径+单个调用+子类型检测。 跳过不必要的条件分支、JS引擎更容易优化
4、优化插槽的生成。 确保实例正确的跟踪依赖关系、避免不必要的父子组件重新渲染
5、静态树提升
6、静态属性提升
7、内联的事件提升
8、基于Proxy的观察者机制，全语言覆盖+更好的性能



### 追一科技 2019.8.10
ip正则  (\d{1,3}\.){3}\d{1,3}
虚拟dom的实现
双向绑定


### 明源云 2019.8.14
1. 写出下面代码执行结果
```js
// 一 
var a = 3
function change1(a) {
  a = 4
}
change1(a)
console.log(a)  // 3


// 二
var user = {age: 30}
function change2(user) {
  user.age = 40
}
change2(user)
console.log(user.age)  //  40


// 三
function change3(user) {
  user = {age: 50}
}
change3(user)
console.log(user.age)  //  40
```

2. 三栏布局，两边固定，中间自适应
* float实现
基于纯float实现的三栏布局需要将中间的内容放在HTML结构的最后，否则右侧会沉在中间内容的下侧
原理：元素浮动后，脱离文档流，后面的元素受浮动影响，设置受影响元素的margin值即可
```html
<div class="wrap">
  <div class="left"></div>
  <div class="right"></div>
  <div class="middle"></div>
</div>

<style>
  .wrap{
      overflow: hidden;
      height: 400px;
    }
    .left, .right {
      width: 200px;
      height: 100%;
    }
    .left{
      float: left;
      background: #00f;
    }
    .right{
      float: right;
      background: #0f0;
    }
    .middle{
      width: 100%;
      height: 100%;
      background: #f00;
    }
</style>
```
* 圣杯布局
三栏利用 float 和 负margin 并列，利用父容器设置 padding 给两边侧栏腾空间
先给这三个div都给一个float: left，让它们均左浮动
设置左盒子的margin-left: -100%，把左盒子拉上来，调整左盒子的浮动位置到中间盒子的左侧
设置右盒子的margin-left: -右盒子宽度px，把右盒子拉上来，调整右盒子的浮动位置到中间盒子的右侧
设置左右盒子position: relative，分别设置left和right，并且控制父元素的padding来为左右两边留白。中间盒子的左右两侧会被左右两个盒子覆盖，通过相对定位来避免覆盖
```html
  <div class="wrap">
    <div class="middle"></div>
    <div class="left"></div>
    <div class="right"></div>
  </div>
  <style>
    .wrap{
      overflow: hidden;
      height: 400px;
      width: 100%;

      padding: 0 200px 0 100px;
    }
    .left, .right, .middle {
      float: left;
    }
    .left{
      width: 100px;
      height: 100%;
      background: #00f;

      margin-left: -100%; 
      position: relative;
      left: -100px;
    }
    .right{
      width: 200px;
      height: 100%;
      background: #0f0;

      margin-left:-200px; 
      position: relative;
      right: -200px;
    }
    .middle{
      width: 100%;
      height: 100%;
      background: #f00;
    }
  </style>
  ```
* 双飞翼布局
三栏利用 float 和 负margin 并列，在中间栏加一层容器，利用 margain 给两栏腾空间
```html
 <div class="wrap">
    <div class="middle">  
      <div class="inner">pppp</div>
    </div>
    <div class="left"></div>
    <div class="right"></div>
  </div>
  <style>
    .wrap{
      overflow: hidden;
      height: 400px;
      width: 100%;
    }
    .left, .right, .middle {
      float: left;
    }
    .left{
      width: 100px;
      height: 100%;
      background: #00f;

      margin-left: -100%; 
    }
    .right{
      width: 200px;
      height: 100%;
      background: #0f0;

      margin-left: -200px; 
    }
    .middle{
      width: 100%;
      height: 100%;
      background: #f00;
    }
    .inner{
      margin: 0 200px 0 100px;
      background: #ff0;
    }
  </style>
```


* absolute 
基于绝对定位的三栏布局：注意绝对定位的元素脱离文档流，相对于最近的已经定位的祖先元素进行定位。无需考虑HTML中结构的顺序，niddle 可放在开头、中间或结尾
缺点：有顶部对齐问题，需要进行调整，注意中间的高度为整个内容的高度
```html
<div class="wrap">
    <div class="middle"></div>
    <div class="left"></div>
    <div class="right"></div>
  </div>
  <style>
    .wrap{
      overflow: hidden;
      height: 400px;
    }
    .left, .right {
      width: 200px;
      height: 100%;
      position: absolute;
      top: 0;
    }
    .left{
      background: #00f;
      left: 0;
    }
    .right{
      background: #0f0;
      right: 0;
    }
    .middle{
      height: 100%;
      background: #f00;
      left: 200px;
      right: 200px;
      margin: 0 200px;
    }
  </style>
```

* flex
```html
  <div class="wrap">
    <div class="left"></div>
    <div class="middle"></div>
    <div class="right"></div>
  </div>
  <style>
    .wrap{
      display: flex;
      height: 400px;
      flex-direction: row;
      justify-content: space-between;
    }
    .left, .right {
      width: 200px;
      height: 100%;
    }
    .left{
      background: #00f;
    }
    .right{
      background: #0f0;
    }
    .middle{
      height: 100%;
      background: #f00;
      flex: auto;
    }
  ```

3、写出弹框显示内容，都会有三次弹框
```js
function test(a,b) {
  alert(b)
  return {
    test: function(c, a) {
      return test(c, a)
    }
  }
}

// 一
var a = test(100,200) // 200
a.test(300) // undefined
a.test(300) // undefined

// 二
var b = test(101).test(201).test(401) // undefined undefined undefined

// 三
var c = test(102).test(201, 302) // undefined 302
c.test() // undefined
```

4、 设置 a 的值让条件 a == 2 && a == 3 成立
```js
// 方法一
var a = {
  i: 2,
  toString() {
    return a.i++
  }
}

// 方法二
var i = 1
Object.defineProperty(window, 'a', {
  get: function() {
    return ++i;
  }
});
```

5、不使用for 或 while，创建一个长度100的数组，并且每个元素的值等于它的下标
注意陷阱 map、forEach 不会跳过undefined和null，但是会跳过空位
```js
// 创建一个空的密集数组最正确姿势
var arr = Array.from({length: 100})
var arr = [...Array(100)]
var arr = Array.apply(null, {length: 100})  //  不能用 call
var arr = Object.keys(Array.apply(null,{length:100}))

var arr = Array.apply(null, {length: 100}).map(Number.call, Number) 

var arr = new Array(100).fill("").map(function(v,i){return i})
```

6、 将扁平的数据转为树形结构
```js
// 原始 list 如下
let list =[
    {id:1, parentId:0, value: 'a'},
    {id:2, parentId:1, value: 'b'},
    {id:3, parentId:1, value: 'c'},
    {id:4, parentId:1, value: 'd'},
    {id:5, parentId:2, value: 'e'},
    {id:6, parentId:3, value: 'f'},
    {id:7, parentId:2, value: 'g'},
    {id:8, parentId:4, value: 'h'}
];

// 转换成 parentId 为键的对象 
function buildTree(list){
	let temp = {};
	let tree = {};
	for(let i in list){
		temp[list[i].id] = list[i];
	}
	for(let i in temp){
		if(temp[i].parentId) {
			if(!temp[temp[i].parentId].children) {
				temp[temp[i].parentId].children = new Object();
			}
			temp[temp[i].parentId].children[temp[i].id] = temp[i];
		} else {
			tree[temp[i].id] =  temp[i];
		}
	}
	return tree;
}


// 转换成 内嵌children 的对象数组
function convert(list) {
	const res = []
	const map = list.reduce((res, v) => (res[v.id] = v, res), {})
	for (const item of list) {
		if (item.parentId === 0) {
			res.push(item)
			continue
		}
		if (item.parentId in map) {
			const parent = map[item.parentId]
			parent.children = parent.children || []
			parent.children.push(item)
		}
	}
	return res
}
```


### 大疆  2019.8.21
react 生命周期
高阶组件


### TCL  2019.8.21
1. null instanceof Object、{a:1} instanceof null
false、 error(Right-hand side of 'instanceof' is not an object)

2. 变量提升
函数及变量的声明都将被提升到函数的最顶部；变量可以在使用后声明（变量赋值不会提升，有多个函数声明的时候，是由最后面的函数声明来替代前面的；函数提升的优先级大于变量提升的优先级，即函数提升在变量提升之上
```js
var name = 'aa';
(function() {
  if(typeof name==='undefined') {
    var name = 'bb'
    console.log(name)
  } else {
    console.log(name)
  }
})()

// 相当于
var name = 'aa';
(function() {
  var name
  if(typeof name==='undefined') {
    name = 'bb'
    console.log(name)
  } else {
    console.log(name)
  }
})()

// 改动
var name = 'aa';
(function() {
  if(typeof name==='undefined') {
     name = 'bb'
    console.log(name)
  } else {
    console.log(name)
  }
})()
// aa
```

3. 作用域
```js
for(var i=0; i<3; i++) {
  setTimeout(() => {
    console.log(i)
  }, 0);
}
// 3 3 3


// 改动
for(var i=0; i<=3; i++) {
  setTimeout(() => {
    console.log(i)
  }, 0);
}
// 4, 4, 4, 4


// 改动
for(let i=0; i<3; i++) {
  setTimeout(() => {
    console.log(i)
  }, 0);
}
// 0, 1, 2
```

4. 数组非变异方法
变异方法:    push/pop/shift/unshift/sort/splice/reverse
非变异方法:  concat/slice/join; map/find/forEach/filter
```js
var a1 = [1, 3, 2]
var a2 = [4, 5]
a1.concat(a2)
a1.sort()
console.log(a1)  // [1, 2, 3]
```

5. 鼠标点击页面中的任意标签，弹出该标签名
```js
document.onclick = function(eve) {
  var e = eve || window.event
  var o = e.target || e.srcElement
  alert(o.tagName)
}

// 注意: e.target 当前实际点击触发的节点，  e.currentTarget 事件委托者
```

6. 标签弹出其索引值
```js
var oli = document.getElementsByTagName('li')
// 方法一
// 根据作用域的工作原理，尽管循环中的6个函数是在各个迭代中分别定义的，运行时都会捕获一个i的副本，但是他们都被封闭在一个共享的全局作用域中，因此实际上只有一个i
for(var i=0; i<oli.length; i++) {
  oli[i].index = i
  oli[i].onclick = function() {
    alert(index)
  }
}
// 方法二 闭包
// 在迭代内使用IIFE会为每一个迭代都生成一个新的作用域，使得点击函数可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问
for(var i=0; i<oli.length; i++) {
  (function(n) {
    oli[i].onclick = funtion() {
      alert(n)
    }
  })(i)
}
// 方法二 ES6
// for循环头部的let声明会有一个特殊的行为，变量在循环过程中不止被声明一次，每次迭代都会声明，随后的每个迭代都会用上一个迭代结束时的值来初始化这个变量
'use strict'
for(let i=0; i<oli.length; i++) {
  oli[i].onclick = function() {
    alert(i)
  }
}
```

7. Http 状态码
1** 信息，服务器收到请求，需要请求者继续执行操作
2**	成功，操作被成功接收并处理
3**	重定向，需要进一步的操作以完成请求
4**	客户端错误
5**	服务器错误


### 携程 2019.8.27
工作
团队 规模 选型 开发规范
如何与后端交互
vue vue-router vuex
react react-router-dom redux
vue 组价传值
react 生命周期
rn
xhr 
继承
箭头函数的特点
async await 实现 promise.all()  并行
css2 BFC
css3 画圆角、动画
flex 居中
跨域
数据结构
二叉树  无子节点即结束
队列、堆栈
设计模式
常见排序算法、时间复杂度、稳定性


### 京东 2019.8.28
#### 笔试题
* var/let/const 区别
* css 选择器  尽可能多的写出
* 让div水平垂直居中
* 实现千分位分隔符(尽可能用正则)，如 1000 展示位 1,000
分析：
– 从后往前每三个数字加一个逗号
– 如果恰好是3的倍数个数字，最前面不需要逗号
– 由于强制逗号后面必须跟3位数字，可能需要用到零宽断言找到符合条件的位置
零宽度正预测先行断言 (?=exp) 断言自身出现的位置的后面能匹配表达式exp，如 (?=ing) 查找 dacing 时 匹配dac
str.repalce(/(\d)(?=(\d{3})+$)/g,'$1,')

* 给定一个包含超过两个数字的数组，实现去重、按最后一个元素对称复制、求和
变异方法:    push/pop/shift/unshift/sort/splice/reverse
非变异方法:  concat/slice/join; map/find/forEach/filter
```js
var a = [1, 2, 3]
var b = a.slice(0, -1)  // [1, 2]
var b1 = b.reverse()  // [2, 1]
var c = a.concat(b1)  // [1, 2, 3, 2, 1]
```

* 将一个长度不超过5位数的正整数转换成对应的中文字符，如 20976，返回 两万零八百七十六

* js 在跨越方面有哪些方法

* 原生 js 实现类继承的方法

* 常用的前端优化方法有哪些

* 什么是 XSS、CSRF，怎么防范

* 下面的代码，输出的结果是什么
```js
(function test() {
  setTimeout(() => {console.log(4)}, 0);
  new Promise(function excutor(resolove) {
    console.log(1)
    for(var i=0; i<1000; i++) {
      i==9999 && resolove()
    }
    console.log(2)
  }).then(function() {
    console.log(5)
    
  })
  console.log(3)
})()

// 1  2  3  5 4
```


#### 面试题
* 顶层对象的属性
let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。
```js
let a = 1
window.a   // undefined
```

* const
const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了
```js
const obj = {a:1}
obj.a=2
obj // {a:2}
```

* ts any unknow never 断言

* python is  vs ==
is比较的是两个对象的id，也就是比较两个对象是否为同一个实例对象，是否指向同一个内存地址
==比较的是两个对象的内容，默认会调用对象的__eq__()方法





### todo 
虚拟dom的实现
双向绑定
vue 插件
移动端开发
微信公众号

要求
前端JS/CSS基础足够扎实
HTTP/HTTPS/TCP 等网络协议相关的常见知识点，XSS/CSRF等网络安全常见的知识点要掌握
前端的性能优化
Webpack的原理，性能优化
Vue/React至少能解释其中一个的基本实现原理，能说出他们的主要区别
Redux/Vuex至少掌握其中一个的实现原理
常见的数据结构和算法，以及他们的时间复杂度，比如手写快排或者DFS
如果有后端开发经验、Weex/RN等更好
上面这些都是技术的，一般还会问一些团队建设以及业务理解等问题。